// Drawing World with Babylon.js - UPDATED FOR CAMERA FOCUS FIX
// UNIT STANDARD: 1 unit = 1 cm (eventually selectable between metric/imperial)
console.log("🚀 DRAWING-WORLD.JS LOADED - CAMERA FIX VERSION 2024-07-14 18:43:00 TIMESTAMP");
import { GridSystem } from './grid/GridSystem.js';
import { Shape2D } from './modules/Shape2D.js?v=20250112001';
import { CutToolSystem } from './modules/CutToolSystem.js';
import { RouterBitSystem } from './modules/RouterBitSystem.js';
import { ScrollCuttingSystem } from './modules/ScrollCuttingSystem.js';
import { PlaneToolSystem } from './modules/PlaneToolSystem.js';
import { JoinToolSystem } from './modules/JoinToolSystem.js';
import { DrillPressSystem } from './modules/DrillPressSystem.js';

/**
 * Modern Gizmo System Redesign
 * - Smooth, professional appearance
 * - Easy to grab with larger hit zones
 * - Buttery smooth movement
 * - Visual feedback on hover and drag
 */

class ModernGizmoSystem {
    constructor(scene, camera, canvas) {
        this.scene = scene;
        // Modern gizmo system
        this.modernGizmo = null;
        
        // Pointer tool system for compatibility
        this.pointerToolSystem = {
            setMode: (mode) => {
                console.log('Pointer tool mode set to:', mode);
                this.pointerMode = mode;
            },
            showPositionGizmo: (mesh) => {
                console.log('Showing position gizmo for mesh:', mesh.name);
                if (this.selectedPart) {
                    this.createDragHandles(mesh);
                }
            }
        };

        this.camera = camera;
        this.canvas = canvas;
        
        // Gizmo components
        this.gizmoRoot = null;
        this.axisHandles = [];
        this.planeHandles = [];
        this.centerSphere = null;
        
        // Interaction state
        this.isDragging = false;
        this.hoveredHandle = null;
        this.activeHandle = null;
        this.targetMesh = null;
        
        // Drag state
        this.dragStartPosition = null;
        this.dragPlane = null;
        this.dragOffset = null;
        
        // Visual settings
        this.axisLength = 3;
        this.axisThickness = 0.15;
        this.arrowSize = 0.5;
        this.planeSize = 0.8;
        this.centerSize = 0.3;
        
        // Colors
        this.colors = {
            x: new BABYLON.Color3(0.9, 0.2, 0.2),      // Soft red
            y: new BABYLON.Color3(0.2, 0.9, 0.2),      // Soft green
            z: new BABYLON.Color3(0.2, 0.2, 0.9),      // Soft blue
            xy: new BABYLON.Color3(0.9, 0.9, 0.2),     // Yellow
            xz: new BABYLON.Color3(0.9, 0.2, 0.9),     // Magenta
            yz: new BABYLON.Color3(0.2, 0.9, 0.9),     // Cyan
            hover: new BABYLON.Color3(1, 1, 0),        // Bright yellow
            active: new BABYLON.Color3(1, 0.5, 0),     // Orange
            center: new BABYLON.Color3(0.8, 0.8, 0.8)  // Light gray
        };
        
        this.setupObservables();
    }
    
    createGizmo(targetMesh) {
        this.dispose();
        this.targetMesh = targetMesh;
        
        // Create root node at mesh position
        this.gizmoRoot = new BABYLON.TransformNode("gizmoRoot", this.scene);
        this.updateGizmoPosition();
        
        // Create axis handles
        this.createAxisHandles();
        
        // Create plane handles
        this.createPlaneHandles();
        
        // Create center sphere for free movement
        this.createCenterSphere();
        
        // Setup scaling based on camera distance
        this.setupCameraDistanceScaling();
    }
    
    createAxisHandles() {
        const axes = [
            { name: 'x', direction: new BABYLON.Vector3(1, 0, 0), color: this.colors.x },
            { name: 'y', direction: new BABYLON.Vector3(0, 1, 0), color: this.colors.y },
            { name: 'z', direction: new BABYLON.Vector3(0, 0, 1), color: this.colors.z }
        ];
        
        axes.forEach(axis => {
            // Create axis line
            const line = BABYLON.MeshBuilder.CreateCylinder(`axis_${axis.name}`, {
                height: this.axisLength,
                diameter: this.axisThickness,
                tessellation: 8
            }, this.scene);
            
            // Position and orient
            line.parent = this.gizmoRoot;
            line.position = axis.direction.scale(this.axisLength / 2);
            
            if (axis.name === 'x') line.rotation.z = Math.PI / 2;
            else if (axis.name === 'z') line.rotation.x = Math.PI / 2;
            
            // Create arrow cone
            const arrow = BABYLON.MeshBuilder.CreateCylinder(`arrow_${axis.name}`, {
                height: this.arrowSize,
                diameterTop: 0,
                diameterBottom: this.arrowSize,
                tessellation: 8
            }, this.scene);
            
            arrow.parent = this.gizmoRoot;
            arrow.position = axis.direction.scale(this.axisLength);
            
            if (axis.name === 'x') arrow.rotation.z = -Math.PI / 2;
            else if (axis.name === 'z') arrow.rotation.x = -Math.PI / 2;
            
            // Create material
            const material = new BABYLON.StandardMaterial(`mat_${axis.name}`, this.scene);
            material.diffuseColor = new BABYLON.Color3(1, 1, 1); // Pure white
            material.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            material.emissiveColor = new BABYLON.Color3(1, 1, 1); // Self-illuminated white
            material.disableLighting = true; // No shadows or lighting
            
            line.material = material;
            arrow.material = material;
            
            // Add black outline for halo effect
            line.renderOutline = true;
            line.outlineWidth = 0.1;
            line.outlineColor = new BABYLON.Color3(0, 0, 0);
            
            arrow.renderOutline = true;
            arrow.outlineWidth = 0.1;
            arrow.outlineColor = new BABYLON.Color3(0, 0, 0);
            
            // Create invisible hit box for easier selection
            const hitBox = BABYLON.MeshBuilder.CreateBox(`hitbox_${axis.name}`, {
                width: axis.name === 'x' ? this.axisLength : this.axisThickness * 3,
                height: axis.name === 'y' ? this.axisLength : this.axisThickness * 3,
                depth: axis.name === 'z' ? this.axisLength : this.axisThickness * 3
            }, this.scene);
            
            hitBox.parent = this.gizmoRoot;
            hitBox.position = axis.direction.scale(this.axisLength / 2);
            hitBox.isVisible = false;
            hitBox.isPickable = true;
            
            // Store references
            const handle = {
                axis: axis.name,
                direction: axis.direction,
                line: line,
                arrow: arrow,
                hitBox: hitBox,
                material: material,
                defaultColor: axis.color.clone(),
                type: 'axis'
            };
            
            // Tag meshes
            [line, arrow, hitBox].forEach(mesh => {
                mesh.gizmoHandle = handle;
                mesh.isGizmo = true;
            });
            
            this.axisHandles.push(handle);
        });
    }
    
    createPlaneHandles() {
        const planes = [
            { name: 'xy', normal: new BABYLON.Vector3(0, 0, 1), color: this.colors.xy },
            { name: 'xz', normal: new BABYLON.Vector3(0, 1, 0), color: this.colors.xz },
            { name: 'yz', normal: new BABYLON.Vector3(1, 0, 0), color: this.colors.yz }
        ];
        
        planes.forEach(plane => {
            const planeMesh = BABYLON.MeshBuilder.CreatePlane(`plane_${plane.name}`, {
                size: this.planeSize
            }, this.scene);
            
            planeMesh.parent = this.gizmoRoot;
            planeMesh.position = BABYLON.Vector3.Zero();
            
            // Orient plane
            if (plane.name === 'xz') {
                planeMesh.rotation.x = Math.PI / 2;
            } else if (plane.name === 'yz') {
                planeMesh.rotation.y = Math.PI / 2;
            }
            
            // Create material
            const material = new BABYLON.StandardMaterial(`mat_plane_${plane.name}`, this.scene);
            material.diffuseColor = new BABYLON.Color3(1, 1, 1); // Pure white
            material.alpha = 0.3;
            material.backFaceCulling = false;
            material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            material.disableLighting = true;
            
            planeMesh.material = material;
            
            // Store reference
            const handle = {
                name: plane.name,
                normal: plane.normal,
                mesh: planeMesh,
                material: material,
                defaultColor: plane.color.clone(),
                defaultAlpha: 0.3,
                type: 'plane'
            };
            
            planeMesh.gizmoHandle = handle;
            planeMesh.isGizmo = true;
            
            this.planeHandles.push(handle);
        });
    }
    
    createCenterSphere() {
        this.centerSphere = BABYLON.MeshBuilder.CreateSphere("gizmo_center", {
            diameter: this.centerSize,
            segments: 16
        }, this.scene);
        
        this.centerSphere.parent = this.gizmoRoot;
        
        const material = new BABYLON.StandardMaterial("mat_center", this.scene);
        material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        material.specularColor = new BABYLON.Color3(0, 0, 0);
        material.emissiveColor = new BABYLON.Color3(1, 1, 1);
        material.disableLighting = true;
        
        this.centerSphere.material = material;
        
        const handle = {
            type: 'center',
            mesh: this.centerSphere,
            material: material,
            defaultColor: this.colors.center.clone()
        };
        
        this.centerSphere.gizmoHandle = handle;
        this.centerSphere.isGizmo = true;
    }
    
    setupCameraDistanceScaling() {
        // Scale gizmo based on distance from camera
        this.scene.registerBeforeRender(() => {
            if (!this.gizmoRoot || !this.targetMesh) return;
            
            const distance = BABYLON.Vector3.Distance(
                this.camera.position,
                this.gizmoRoot.position
            );
            
            // Scale factor based on distance
            const scale = Math.max(distance * 0.05, 1);
            this.gizmoRoot.scaling = new BABYLON.Vector3(scale, scale, scale);
        });
    }
    
    setupObservables() {
        // Pointer move for hover effects
        this.scene.onPointerObservable.add((pointerInfo) => {
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.handlePointerMove(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    this.handlePointerDown(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    this.handlePointerUp(pointerInfo);
                    break;
            }
        });
    }
    
    handlePointerMove(pointerInfo) {
        if (this.isDragging) {
            this.updateDrag(pointerInfo);
            return;
        }
        
        // Check for hover
        const pickInfo = this.scene.pick(
            this.scene.pointerX,
            this.scene.pointerY,
            (mesh) => mesh.isGizmo
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh.gizmoHandle) {
            this.setHoveredHandle(pickInfo.pickedMesh.gizmoHandle);
        } else {
            this.setHoveredHandle(null);
        }
    }
    
    handlePointerDown(pointerInfo) {
        if (pointerInfo.event.button !== 0) return; // Only left click
        
        const pickInfo = pointerInfo.pickInfo;
        if (pickInfo.hit && pickInfo.pickedMesh.isGizmo) {
            this.startDrag(pickInfo.pickedMesh.gizmoHandle, pickInfo);
        }
    }
    
    handlePointerUp(pointerInfo) {
        if (this.isDragging) {
            this.endDrag();
        }
    }
    
    setHoveredHandle(handle) {
        if (this.hoveredHandle === handle) return;
        
        // Reset previous hover
        if (this.hoveredHandle) {
            this.resetHandleAppearance(this.hoveredHandle);
        }
        
        this.hoveredHandle = handle;
        
        // Apply hover effect
        if (handle && !this.isDragging) {
            this.applyHoverEffect(handle);
        }
    }
    
    applyHoverEffect(handle) {
        if (handle.type === 'axis') {
            // Change to axis color on hover
            const axisColor = this.colors[handle.axis];
            handle.material.emissiveColor = axisColor;
            handle.material.diffuseColor = axisColor;
            handle.material.emissiveColor = axisColor;
            handle.material.diffuseColor = axisColor;
        } else if (handle.type === 'plane') {
            handle.material.alpha = 0.5;
            handle.material.emissiveColor = this.colors.hover.scale(0.3);
        } else if (handle.type === 'center') {
            handle.material.emissiveColor = this.colors.hover.scale(0.5);
            handle.mesh.scaling = new BABYLON.Vector3(1.2, 1.2, 1.2);
        }
    }
    
    resetHandleAppearance(handle) {
        if (handle.type === 'axis') {
            handle.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            handle.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            handle.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            handle.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            handle.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            handle.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        } else if (handle.type === 'plane') {
            handle.material.alpha = handle.defaultAlpha;
            handle.material.emissiveColor = handle.defaultColor.scale(0.2);
        } else if (handle.type === 'center') {
            handle.material.emissiveColor = handle.defaultColor.scale(0.2);
            handle.mesh.scaling = BABYLON.Vector3.One();
        }
    }
    
    startDrag(handle, pickInfo) {
        this.isDragging = true;
        this.activeHandle = handle;
        this.dragStartPosition = this.targetMesh.position.clone();
        
        // Disable camera control
        this.camera.detachControl(this.canvas);
        
        // Apply active appearance
        handle.material.emissiveColor = this.colors.active.scale(0.6);
        
        // Setup drag plane based on handle type
        this.setupDragPlane(handle, pickInfo);
    }
    
    setupDragPlane(handle, pickInfo) {
        const meshPosition = this.targetMesh.position;
        
        if (handle.type === 'axis') {
            // Create plane perpendicular to camera that contains the axis
            const cameraDirection = this.camera.position.subtract(meshPosition).normalize();
            const normal = BABYLON.Vector3.Cross(handle.direction, cameraDirection).normalize();
            
            // If axis is parallel to camera, use alternate plane
            if (normal.length() < 0.1) {
                normal.copyFrom(BABYLON.Vector3.Cross(handle.direction, BABYLON.Vector3.Up()).normalize());
            }
            
            this.dragPlane = BABYLON.Plane.FromPositionAndNormal(meshPosition, normal);
            
        } else if (handle.type === 'plane') {
            // Use the plane's normal
            this.dragPlane = BABYLON.Plane.FromPositionAndNormal(meshPosition, handle.normal);
            
        } else if (handle.type === 'center') {
            // Use screen-aligned plane
            const cameraDirection = this.camera.position.subtract(meshPosition).normalize();
            this.dragPlane = BABYLON.Plane.FromPositionAndNormal(meshPosition, cameraDirection);
        }
    }
    
    updateDrag(pointerInfo) {
        if (!this.isDragging || !this.activeHandle || !this.dragPlane) return;
        
        // Create ray from mouse position
        const ray = this.scene.createPickingRay(
            this.scene.pointerX,
            this.scene.pointerY,
            BABYLON.Matrix.Identity(),
            this.camera
        );
        
        // Find intersection with drag plane
        const distance = this.dragPlane.intersectsLine(ray);
        if (!distance) return;
        
        const pickedPoint = ray.origin.add(ray.direction.scale(distance));
        let newPosition = pickedPoint.add(this.dragOffset);
        
        // Apply constraints based on handle type
        if (this.activeHandle.type === 'axis') {
            // Project movement onto axis
            const movement = newPosition.subtract(this.dragStartPosition);
            const axisMovement = BABYLON.Vector3.Dot(movement, this.activeHandle.direction);
            newPosition = this.dragStartPosition.add(
                this.activeHandle.direction.scale(axisMovement)
            );
            
        } else if (this.activeHandle.type === 'plane') {
            // Constrain to plane (remove component along normal)
            const movement = newPosition.subtract(this.dragStartPosition);
            const normalComponent = BABYLON.Vector3.Dot(movement, this.activeHandle.normal);
            newPosition = newPosition.subtract(
                this.activeHandle.normal.scale(normalComponent)
            );
        }
        
        // Apply position
        this.targetMesh.position = newPosition;
        this.updateGizmoPosition();
        
        // Update part data if exists
        if (this.targetMesh.partData) {
            this.targetMesh.partData.meshGeometry = this.targetMesh.partData.meshGeometry || {};
            this.targetMesh.partData.meshGeometry.position = {
                x: newPosition.x,
                y: newPosition.y,
                z: newPosition.z
            };
        }
    }
    
    endDrag() {
        this.isDragging = false;
        
        // Re-enable camera control
        this.camera.attachControl(this.canvas, true);
        
        // Reset appearance
        if (this.activeHandle) {
            this.resetHandleAppearance(this.activeHandle);
        }
        
        this.activeHandle = null;
        this.dragPlane = null;
        this.dragOffset = null;
    }
    
    updateGizmoPosition() {
        if (this.gizmoRoot && this.targetMesh) {
            this.gizmoRoot.position = this.targetMesh.position.clone();
            // Add Y-axis offset to position gizmo above the object
            this.gizmoRoot.position.y += 10; // 10 units above the object center
        }
    }
    
    show() {
        if (this.gizmoRoot) {
            this.gizmoRoot.setEnabled(true);
        }
    }
    
    hide() {
        if (this.gizmoRoot) {
            this.gizmoRoot.setEnabled(false);
        }
    }
    
    dispose() {
        if (this.gizmoRoot) {
            this.gizmoRoot.dispose();
            this.gizmoRoot = null;
        }
        
        this.axisHandles = [];
        this.planeHandles = [];
        this.centerSphere = null;
        this.hoveredHandle = null;
        this.activeHandle = null;
        this.targetMesh = null;
    }
}

class DrawingWorld {
    constructor() {
        this.canvas = document.getElementById('renderCanvas');
        this.engine = null;
        this.scene = null;
        this.camera = null;
        this.grid = null;
        this.currentMode = 'model'; // Always start in 3D modeling mode
        this.sketchPlanes = [];
        this.selectedObject = null;
        
        // Initialize sketch drawing state
        this.closedShapes = [];
        
        // Initialize grid system
        this.lastGridCenter = null;
        
        // Initialize shape2D system
        this.shape2D = null;
        
        // Sketch tool state
        this.sketchToolSelected = false;
        this.waitingForSurface = false;
        this.isExtruding = false;
        
        // Active tool state
        this.activeTool = null;
        
        // Default sketch planes
        this.defaultSketchPlanes = null;
        
        // Materials system
        this.materialsLibrary = null;
        this.boardFactory = null;
        this.projectParts = [];
        this.workBenchParts = [];
        this.selectedMaterial = null;
        
        // Bench system
        this.currentBench = 'work'; // 'work' or 'assembly'
        this.currentWorkPart = null;
        
        // 3D Manipulation system
        this.selectedPart = null;
        this.manipulationGUI = null;
        this.dragHandles = null;
        
        // Cut tool system
        this.cutToolSystem = null;
        
        // Router bit system
        this.routerBitSystem = null;
        
        // Scroll cutting system
        this.scrollCuttingSystem = null;
        
        // Join tool system
        this.joinToolSystem = null;
        
        this.init();
    }

    async init() {
        // Initialize Babylon.js
        this.engine = new BABYLON.Engine(this.canvas, true);
        this.scene = new BABYLON.Scene(this.engine);
        // Enable outline renderer for gizmo halo effect
        this.scene.outlineRenderer = new BABYLON.OutlineRenderer(this.scene);
        
        // Set light background color
        this.scene.clearColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        
        // Try to increase line width globally  
        const gl = this.engine._gl;
        if (gl) {
            gl.lineWidth(4.0); // Attempt to set thicker lines
        }
        
        // Also try setting line width at engine level
        this.engine.setHardwareScalingLevel(1.0);
        
        // Set up custom line material for thick lines
        this.setupThickLineMaterial();
        
        // Set up camera
        this.setupCamera();
        
        // Initialize grid LOD system
        this.initializeGridLOD();
        
        // Set up lighting
        this.setupLighting();
        
        // Set up grid
        this.setupGrid();
        
        // Set up sketch planes - DISABLED for now
        // this.setupSketchPlanes();
        
        // Set up event listeners
        
        // Set up selection system
        this.setupSelectionSystem();
        
        // Initialize materials system
        await this.initializeMaterialsSystem();

        // Set up event listeners (moved after materials system)
        this.setupEventListeners();
        
        // Initialize drag handle interaction
        this.enableDragHandleInteraction();
        
        // Initialize cut tool system
        this.cutToolSystem = new CutToolSystem(this);
        
        // Initialize router bit system
        this.routerBitSystem = new RouterBitSystem(this);
        
        // Initialize scroll cutting system
        this.scrollCuttingSystem = new ScrollCuttingSystem(this);
        
        // Initialize plane tool system
        this.planeToolSystem = new PlaneToolSystem(this);
        
        
        // Initialize join tool system
        this.joinToolSystem = new JoinToolSystem(this);
        
        // Initialize drill press system
        this.drillPressSystem = new DrillPressSystem(this);
        
        // Initialize preferences system
        this.initializePreferencesSystem();
        
        // Start render loop (simplified - no render loop modifications)
        this.engine.runRenderLoop(() => {
            // Update gizmo scaling based on camera distance
            this.updateExtrusionGizmoScale();
            
            // Enforce camera height constraint - cannot go below 4 units above XY plane
            this.enforceMinimumCameraHeight();
            
            this.scene.render();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.engine.resize();
        });
        
        // Initialize tool groups to correct state
        this.updateToolGroups();
        
        // DRAMATIC OPENING: Professional opening animation
        this.performOpeningAnimation();
        
    }
    
    /**
     * Create a native chamfered box using vertex geometry - no CSG
     */
    createChamferedBoardPrimitive() {
        // Create a simple box with chamfered front edge using vertices/indices
        const L = 50;  // Length
        const W = 15;  // Width
        const H = 5;   // Height
        const C = 3;   // Chamfer size
        
        // Define 12 vertices for a box with front edge chamfered
        const positions = [
            // Bottom vertices (6 vertices due to chamfer)
            -L/2, -H/2, -W/2 + C,     // 0: front-left bottom (chamfered)
            -L/2 + C, -H/2, -W/2,     // 1: front-left bottom (chamfer point)
            L/2 - C, -H/2, -W/2,      // 2: front-right bottom (chamfer point)
            L/2, -H/2, -W/2 + C,      // 3: front-right bottom (chamfered)
            L/2, -H/2, W/2,           // 4: back-right bottom
            -L/2, -H/2, W/2,          // 5: back-left bottom
            
            // Top vertices (6 vertices due to chamfer)
            -L/2, H/2, -W/2 + C,      // 6: front-left top (chamfered)
            -L/2 + C, H/2, -W/2,      // 7: front-left top (chamfer point)
            L/2 - C, H/2, -W/2,       // 8: front-right top (chamfer point)
            L/2, H/2, -W/2 + C,       // 9: front-right top (chamfered)
            L/2, H/2, W/2,            // 10: back-right top
            -L/2, H/2, W/2,           // 11: back-left top
        ];
        
        // Define triangular faces (each face needs 2 triangles)
        const indices = [
            // Bottom face (4 triangles for chamfered hexagon)
            0, 1, 5,  1, 2, 5,  2, 4, 5,  2, 3, 4,
            
            // Top face (4 triangles for chamfered hexagon)
            6, 11, 7,  7, 11, 10,  7, 10, 8,  8, 10, 9,
            
            // Side faces
            0, 5, 6,  5, 11, 6,    // Left face
            3, 9, 4,  4, 9, 10,    // Right face  
            4, 10, 5, 5, 10, 11,   // Back face
            
            // Chamfered front faces
            0, 6, 1,  1, 6, 7,     // Left chamfer
            1, 7, 2,  2, 7, 8,     // Front face
            2, 8, 3,  3, 8, 9,     // Right chamfer
            
            // Connect top and bottom chamfer
            0, 3, 6,  3, 9, 6,     // Connect chamfered corners
        ];
        
        // Create the mesh
        const chamferedBox = new BABYLON.Mesh("native_chamfered_box", this.scene);
        
        const vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        
        // Compute normals
        const normals = [];
        BABYLON.VertexData.ComputeNormals(positions, indices, normals);
        vertexData.normals = normals;
        
        vertexData.applyToMesh(chamferedBox);
        
        // Position and material
        chamferedBox.position = new BABYLON.Vector3(0, H/2, 0);
        
        // Apply material with texture
        material.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
        chamferedBox.material = material;
        
        chamferedBox.isWorkBenchPart = true;
        
        console.log('DrawingWorld: Created NATIVE chamfered box with vertex geometry - no original box exists');
        
        return chamferedBox;
    }

    setupCamera() {
        // Arc rotate camera (perfect for CAD applications)
        this.camera = new BABYLON.ArcRotateCamera(
            'camera',
            -Math.PI / 4, // 45 degrees from front-left angle
            Math.PI / 3,  // 60 degrees elevation
            200, // Start 2 meters away (200cm = 2m)
            BABYLON.Vector3.Zero(),
            this.scene
        );
        
        // COMPLETELY DISABLE default controls - we'll implement proper CAD controls
        // Don't attach controls at all to avoid conflicts
        // this.camera.attachControl(this.canvas, false);
        
        // Set camera limits - prevent going below bench surface
        this.camera.setTarget(BABYLON.Vector3.Zero());
        this.camera.lowerBetaLimit = 0.01;
        this.camera.upperBetaLimit = Math.PI / 2 - 0.1;
        this.camera.lowerRadiusLimit = 2;
        this.camera.upperRadiusLimit = 1000;
        
        // Set near/far planes to reduce clipping issues
        this.camera.minZ = 0.01;
        this.camera.maxZ = 1000;
        
        // Responsive camera movement - almost no inertia
        this.camera.inertia = 0.1;
        this.camera.wheelPrecision = 2;
        this.camera.pinchPrecision = 25;
        
        // Setup PROFESSIONAL camera controls like Shapr3D/Blender
        this.setupProfessionalCameraControls();
    }

    setupProfessionalCameraControls() {
        // Camera control state
        this.cameraState = {
            isOrbiting: false,
            isPanning: false,
            lastPointerX: 0,
            lastPointerY: 0
        };

        // Mouse/pointer event handlers for professional CAD controls
        this.canvas.addEventListener('pointerdown', (evt) => this.onCameraPointerDown(evt));
        this.canvas.addEventListener('pointermove', (evt) => this.onCameraPointerMove(evt));
        this.canvas.addEventListener('pointerup', (evt) => this.onCameraPointerUp(evt));
        this.canvas.addEventListener('wheel', (evt) => this.onCameraWheel(evt));
        
        // Prevent context menu on right-click
        this.canvas.addEventListener('contextmenu', (evt) => evt.preventDefault());
        
        console.log('Shapr3D-style camera controls enabled:');
        console.log('- LEFT CLICK: Tools and picking ONLY');
        console.log('- RIGHT CLICK + DRAG: Spin the world (orbit around object)'); 
        console.log('- MIDDLE CLICK + DRAG: Pan view');
        console.log('- WHEEL: Zoom in/out');
    }
    
    /**
     * Update camera target to center of visible objects for better orbiting
     */
    updateCameraTargetToObjects() {
        // Find all visible project parts and work bench parts
        const allParts = this.scene.meshes.filter(mesh => 
            (mesh.isProjectPart || mesh.isWorkBenchPart) && mesh.isVisible
        );
        
        if (allParts.length === 0) {
            console.log('No visible parts found, keeping current target');
            return;
        }
        
        // Calculate center of all parts
        let totalX = 0, totalY = 0, totalZ = 0;
        let validParts = 0;
        
        allParts.forEach(part => {
            if (part.position) {
                totalX += part.position.x;
                totalY += part.position.y;
                totalZ += part.position.z;
                validParts++;
            }
        });
        
        if (validParts > 0) {
            const centerX = totalX / validParts;
            const centerY = totalY / validParts;
            const centerZ = totalZ / validParts;
            
            const newTarget = new BABYLON.Vector3(centerX, centerY, centerZ);
            this.camera.setTarget(newTarget);
            
            console.log(`Updated camera target to center of ${validParts} objects:`, newTarget);
        }
    }
    
    /**
     * Initialize preferences system for user-configurable settings
     */
    initializePreferencesSystem() {
        // Default preferences
        this.preferences = {
            panSpeed: 0.3,
            rotateSpeed: 0.003,
            zoomSpeed: 12,
            units: "imperial"
        };
        
        // Load preferences from localStorage
        this.loadPreferences();
        
        // Setup preferences modal
        this.setupPreferencesModal();
        
        console.log('Preferences system initialized:', this.preferences);
    }
    
    /**
     * Load preferences from localStorage
     */
    loadPreferences() {
        const saved = localStorage.getItem('cutlist-preferences');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                this.preferences = { ...this.preferences, ...parsed };
                console.log('Loaded preferences from localStorage:', this.preferences);
            } catch (e) {
                console.warn('Failed to load preferences from localStorage:', e);
            }
        }
    }
    
    /**
     * Save preferences to localStorage
     */
    savePreferences() {
        localStorage.setItem('cutlist-preferences', JSON.stringify(this.preferences));
        console.log('Saved preferences to localStorage:', this.preferences);
    }
    
    /**
     * Setup preferences modal and event listeners
     */
    setupPreferencesModal() {
        const preferencesBtn = document.getElementById('preferences-btn');
        const preferencesModal = document.getElementById('preferences-modal');
        const closeBtn = document.getElementById('close-preferences-modal');
        const applyBtn = document.getElementById('apply-preferences');
        const resetBtn = document.getElementById('reset-preferences');
        
        // Open modal
        preferencesBtn.addEventListener('click', () => {
            this.showPreferencesModal();
        });
        
        // Close modal
        closeBtn.addEventListener('click', () => {
            this.hidePreferencesModal();
        });
        
        // Close on outside click
        preferencesModal.addEventListener('click', (e) => {
            if (e.target === preferencesModal) {
                this.hidePreferencesModal();
            }
        });
        
        // Apply changes
        applyBtn.addEventListener('click', () => {
            this.applyPreferences();
        });
        
        // Reset to defaults
        resetBtn.addEventListener('click', () => {
            this.resetPreferences();
        });
        
        // Update slider values in real-time
        const sliders = ['pan-speed', 'rotate-speed', 'zoom-speed'];
        sliders.forEach(sliderId => {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(sliderId + '-value');
            
            slider.addEventListener('input', (e) => {
                valueDisplay.textContent = e.target.value;
            });
        });
    }
    
    /**
     * Show preferences modal
     */
    showPreferencesModal() {
        const modal = document.getElementById('preferences-modal');
        
        // Load current values into sliders
        document.getElementById('pan-speed').value = this.preferences.panSpeed;
        document.getElementById('pan-speed-value').textContent = this.preferences.panSpeed;
        
        document.getElementById('rotate-speed').value = this.preferences.rotateSpeed;
        document.getElementById('rotate-speed-value').textContent = this.preferences.rotateSpeed;
        
        document.getElementById('zoom-speed').value = this.preferences.zoomSpeed;
        document.getElementById('zoom-speed-value').textContent = this.preferences.zoomSpeed;
        
        modal.style.display = 'flex';
    }
    
    /**
     * Hide preferences modal
     */
    hidePreferencesModal() {
        const modal = document.getElementById('preferences-modal');
        modal.style.display = 'none';
    }
    
    /**
     * Apply preferences from modal
     */
    applyPreferences() {
        // Get values from sliders
        this.preferences.panSpeed = parseFloat(document.getElementById('pan-speed').value);
        this.preferences.rotateSpeed = parseFloat(document.getElementById('rotate-speed').value);
        this.preferences.zoomSpeed = parseFloat(document.getElementById('zoom-speed').value);
        
        // Save to localStorage
        this.savePreferences();
        
        // Hide modal
        this.hidePreferencesModal();
        
        console.log('Applied preferences:', this.preferences);
    }
    
    /**
     * Reset preferences to defaults
     */
    resetPreferences() {
        this.preferences = {
            panSpeed: 0.3,
            rotateSpeed: 0.003,
            zoomSpeed: 12
        };
        
        // Update sliders
        document.getElementById('pan-speed').value = this.preferences.panSpeed;
        document.getElementById('pan-speed-value').textContent = this.preferences.panSpeed;
        
        document.getElementById('rotate-speed').value = this.preferences.rotateSpeed;
        document.getElementById('rotate-speed-value').textContent = this.preferences.rotateSpeed;
        
        document.getElementById('zoom-speed').value = this.preferences.zoomSpeed;
        document.getElementById('zoom-speed-value').textContent = this.preferences.zoomSpeed;
        
        console.log('Reset preferences to defaults');
    }

    /**
     * DRAMATIC OPENING: Professional opening animation for CutList
     * Creates a cinematic introduction that showcases the precision and quality of the CAD system
     */
    performOpeningAnimation() {
        console.log('Starting dramatic opening animation for CutList');
        
        // Start from a dramatic wide shot
        const startPosition = new BABYLON.Vector3(0, 300, 500);
        const startTarget = new BABYLON.Vector3(0, 0, 0);
        
        // End at professional working position - centered
        const endPosition = new BABYLON.Vector3(80, 60, 120);
        const endTarget = new BABYLON.Vector3(0, 0, 0);
        
        // Set initial dramatic position immediately - no flash
        this.camera.position = startPosition;
        this.camera.setTarget(startTarget);
        
        // Animation parameters - crisp 2.5 second cutscene
        const animationDuration = 150; // 2.5 seconds at 60fps
        const startTime = Date.now();
        
        // Professional ease-in-out cubic (slow start, fast middle, slow end)
        const easeInOutCubic = (t) => {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        };
        
        // Cinematic opening animation
        const animateOpening = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / (animationDuration * 1000 / 60), 1);
            const easedProgress = easeInOutCubic(progress);
            
            // Smooth camera descent and approach
            this.camera.position = BABYLON.Vector3.Lerp(startPosition, endPosition, easedProgress);
            this.camera.setTarget(BABYLON.Vector3.Lerp(startTarget, endTarget, easedProgress));
            
            // Continue animation
            if (progress < 1) {
                requestAnimationFrame(animateOpening);
            } else {
                console.log('CutList opening animation complete - Ready for work!');
                // No bounce - just clean finish
            }
        };
        
        // Start the opening animation
        requestAnimationFrame(animateOpening);
    }
    
    /**
     * Subtle bounce animation to indicate system is ready
     */
    performReadyBounce() {
        // Removed bounce - clean cutscene finish
        console.log('CutList is ready for professional woodworking!');
    }

    onCameraPointerDown(evt) {
        // Don't interfere with drag handle operations
        if (this.isDragging) return;

        this.cameraState.lastPointerX = evt.offsetX;
        this.cameraState.lastPointerY = evt.offsetY;

        // Reset camera states first
        this.cameraState.isOrbiting = false;
        this.cameraState.isPanning = false;

        if (evt.button === 0) {
            // LEFT MOUSE: Tools and picking ONLY - no camera control
            return; // Let tools handle left mouse
        } else if (evt.button === 1) {
            // MIDDLE MOUSE: Pan (move camera and target together)
            this.cameraState.isPanning = true;
            console.log('Started panning');
        } else if (evt.button === 2) {
            // RIGHT MOUSE: Spin the world (orbit around target) - Shapr3D style
            this.cameraState.isOrbiting = true;
            console.log('Started spinning world');
        }

        evt.preventDefault();
    }

    onCameraPointerMove(evt) {
        if (this.isDragging) return; // Don't interfere with object dragging

        const deltaX = evt.offsetX - this.cameraState.lastPointerX;
        const deltaY = evt.offsetY - this.cameraState.lastPointerY;
        
        const sensitivity = this.preferences ? this.preferences.rotateSpeed : 0.003;

        if (this.cameraState.isOrbiting) {
            // RIGHT MOUSE: Spin the world - orbit camera around target (Shapr3D style)
            this.camera.alpha += deltaX * sensitivity;
            this.camera.beta += deltaY * sensitivity;
            
            // Enforce limits
            this.camera.beta = Math.max(this.camera.lowerBetaLimit, 
                                      Math.min(this.camera.upperBetaLimit, this.camera.beta));
            
        } else if (this.cameraState.isPanning) {
            // TRUE PAN: Move camera position only, keep looking in same direction
            const panSensitivity = this.preferences ? this.preferences.panSpeed : 0.3;
            const cameraRight = this.camera.getDirection(BABYLON.Vector3.Right());
            const cameraUp = this.camera.getDirection(BABYLON.Vector3.Up());
            
            const panVector = cameraRight.scale(-deltaX * panSensitivity)
                                       .add(cameraUp.scale(deltaY * panSensitivity));
            
            // Move camera position AND target by the same amount (true pan)
            const currentTarget = this.camera.getTarget();
            const currentPosition = this.camera.position.clone();
            
            this.camera.position = currentPosition.add(panVector);
            this.camera.setTarget(currentTarget.add(panVector));
        }

        this.cameraState.lastPointerX = evt.offsetX;
        this.cameraState.lastPointerY = evt.offsetY;
    }

    onCameraPointerUp(evt) {
        console.log('Pointer up - stopping camera movement');
        this.cameraState.isOrbiting = false;
        this.cameraState.isPanning = false;
        
        // Enforce camera height constraint after any movement
        this.enforceMinimumCameraHeight();
    }

    onCameraWheel(evt) {
        if (this.isDragging) return;

        // ZOOM: Move camera toward/away from target
        const zoomSensitivity = this.preferences ? this.preferences.zoomSpeed : 12;
        const delta = evt.deltaY > 0 ? zoomSensitivity : -zoomSensitivity;
        
        this.camera.radius += delta;
        this.camera.radius = Math.max(this.camera.lowerRadiusLimit, 
                                    Math.min(this.camera.upperRadiusLimit, this.camera.radius));
        
        evt.preventDefault();
    }

    enforceMinimumCameraHeight() {
        // Calculate camera world position
        const cameraPosition = this.camera.globalPosition;
        
        // If camera is below 4 units above the XY plane, adjust it
        if (cameraPosition.y < 4) {
            // Calculate the camera position relative to target
            const targetPosition = this.camera.getTarget();
            const direction = cameraPosition.subtract(targetPosition).normalize();
            const distance = this.camera.radius;
            
            // Adjust beta angle to keep camera at minimum height
            const minHeight = 4;
            const horizontalDistance = Math.sqrt(
                Math.pow(cameraPosition.x - targetPosition.x, 2) + 
                Math.pow(cameraPosition.z - targetPosition.z, 2)
            );
            
            if (horizontalDistance > 0) {
                const minBeta = Math.atan2(horizontalDistance, minHeight - targetPosition.y);
                if (this.camera.beta > minBeta) {
                    this.camera.beta = minBeta;
                }
            }
        }
    }
    
    setupCustomMouseControls() {
        // Disable built-in camera controls
        this.camera.detachControl(this.canvas);
        
        // Custom mouse state
        this.mouseState = {
            isDown: false,
            button: -1,
            lastX: 0,
            lastY: 0
        };
        
        // Add custom mouse event listeners
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.onMouseWheel(e));
        
        // Prevent context menu on right click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
    }
    
    setupThickLineMaterial() {
        // Create a material that can make lines appear thicker
        this.thickLineMaterial = new BABYLON.StandardMaterial('thickLineMaterial', this.scene);
        this.thickLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.5, 1); // Blue color
        this.thickLineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 1); // Make it glow slightly
        this.thickLineMaterial.disableLighting = true;
        this.thickLineMaterial.backFaceCulling = false;
        
        // Store reference for sketch tools
        this.sketchLineMaterial = this.thickLineMaterial;
    }
    
    createThickLineLoop(points, name, material) {
        // Create thick lines using ribbons for closed shapes
        const ribbons = [];
        
        for (let i = 0; i < points.length; i++) {
            const start = points[i];
            const end = points[(i + 1) % points.length];
            const distance = BABYLON.Vector3.Distance(start, end);
            
            if (distance > 0.01) {
                const direction = end.subtract(start).normalize();
                const perpendicular = BABYLON.Vector3.Cross(direction, this.sketchForward).normalize();
                const halfWidth = 0.04;
                
                // Extend lines by half the border width for proper mitered corners
                const extension = halfWidth; // Extension equals half the border width
                const extendedStart = start.subtract(direction.scale(extension));
                const extendedEnd = end.add(direction.scale(extension));
                
                const path1 = [
                    extendedStart.add(perpendicular.scale(halfWidth)),
                    extendedEnd.add(perpendicular.scale(halfWidth))
                ];
                const path2 = [
                    extendedStart.subtract(perpendicular.scale(halfWidth)),
                    extendedEnd.subtract(perpendicular.scale(halfWidth))
                ];
                
                const ribbon = BABYLON.MeshBuilder.CreateRibbon(name + '_segment_' + i, {
                    pathArray: [path1, path2],
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, this.scene);
                
                ribbon.material = material;
                ribbons.push(ribbon);
            }
        }
        
        // Merge all ribbons into one mesh
        if (ribbons.length > 0) {
            const mergedMesh = BABYLON.Mesh.MergeMeshes(ribbons, true);
            mergedMesh.name = name;
            return mergedMesh;
        }
        
        return null;
    }
    
    createFilledRectangle(points, name, borderMaterial) {
        
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledRectangle(points, name, borderMaterial);
        } else {
            // Fallback to corrected original method
            
            // Create the thick border
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create fill material
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Make it glow to ensure visibility
            fillMaterial.backFaceCulling = false;
            fillMaterial.disableLighting = true;
            fillMaterial.alpha = 0.5; // Semi-transparent fill
            
            // Calculate rectangle dimensions more carefully
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            const minZ = Math.min(...points.map(p => p.z));
            const maxZ = Math.max(...points.map(p => p.z));
            
            // Better width/height calculation - use the larger dimension spans
            const xSpan = maxX - minX;
            const ySpan = maxY - minY;
            const zSpan = maxZ - minZ;
            
            // Choose the two largest spans (ignore the dimension with minimal variation)
            let width, height;
            if (xSpan >= ySpan && xSpan >= zSpan) {
                width = xSpan;
                height = Math.max(ySpan, zSpan);
            } else if (ySpan >= xSpan && ySpan >= zSpan) {
                width = Math.max(xSpan, zSpan);
                height = ySpan;
            } else {
                width = Math.max(xSpan, ySpan);
                height = zSpan;
            }
            
            // Rectangle center
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            // Create plane fill that matches the rectangle dimensions
            const fillMesh = BABYLON.MeshBuilder.CreatePlane(name + '_fill', {
                width: Math.max(width, 0.1),
                height: Math.max(height, 0.1),
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Position the fill at the rectangle center
            fillMesh.position.x = centerX;
            fillMesh.position.y = centerY - 0.001; // Slightly behind to avoid z-fighting
            fillMesh.position.z = centerZ;
            fillMesh.material = fillMaterial;
            fillMesh.renderingGroupId = 0; // Behind border
            fillMesh.isPickable = true;
            
            
            // Create parent to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (borderMesh) borderMesh.parent = parentMesh;
            if (fillMesh) fillMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    createFilledCircle(center, radius, name, borderMaterial) {
        
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledCircle(center, radius, name, borderMaterial);
        } else {
            // Fallback to original method
            
            // Create the thick border
            const points = this.getCirclePoints(center, radius);
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create fill material
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.7, 1.0);
            fillMaterial.backFaceCulling = false;
            fillMaterial.disableLighting = true;
            fillMaterial.alpha = 0.5; // Semi-transparent fill
            
            // Create disc fill
            const fillMesh = BABYLON.MeshBuilder.CreateDisc(name + '_fill', {
                radius: radius,
                tessellation: 32,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Position the fill at the circle center
            fillMesh.position = center.clone();
            fillMesh.position.y -= 0.001; // Slightly behind to avoid z-fighting
            fillMesh.material = fillMaterial;
            fillMesh.renderingGroupId = 0; // Behind border
            fillMesh.isPickable = true;
            
            // Create parent to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (borderMesh) borderMesh.parent = parentMesh;
            if (fillMesh) fillMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    createFilledEllipse(center, radiusX, radiusY, name, borderMaterial) {
        
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledEllipse(center, radiusX, radiusY, name, borderMaterial);
        } else {
            // Fallback to original method
            
            // Create the thick border
            const points = this.getEllipsePoints(center, radiusX, radiusY);
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create fill material
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.7, 1.0);
            fillMaterial.backFaceCulling = false;
            fillMaterial.disableLighting = true;
            fillMaterial.alpha = 0.5; // Semi-transparent fill
            
            // Create disc fill and scale it to create an ellipse
            const fillMesh = BABYLON.MeshBuilder.CreateDisc(name + '_fill', {
                radius: Math.max(radiusX, radiusY),
                tessellation: 32,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Scale the disc to create an ellipse
            const scaleX = radiusX / Math.max(radiusX, radiusY);
            const scaleY = radiusY / Math.max(radiusX, radiusY);
            fillMesh.scaling = new BABYLON.Vector3(scaleX, scaleY, 1);
            
            // Position the fill at the ellipse center
            fillMesh.position = center.clone();
            fillMesh.position.y -= 0.001; // Slightly behind to avoid z-fighting
            fillMesh.material = fillMaterial;
            fillMesh.renderingGroupId = 0; // Behind border
            fillMesh.isPickable = true;
            
            // Create parent to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (borderMesh) borderMesh.parent = parentMesh;
            if (fillMesh) fillMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    createFilledShape(points, name, borderMaterial) {
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledPolygon(points, name, borderMaterial);
        } else {
            // Fallback to original method
            
            // Create ultra-thin extruded shape for filled appearance
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.backFaceCulling = false; // Show both sides
            fillMaterial.disableLighting = true; // Don't use lighting
            
            // Create 2D shape path for extrusion - fixed to handle any coordinate system
            const shape2D = points.map(p => new BABYLON.Vector2(p.x, p.z));
            
            let fillMesh;
            try {
                // Create ultra-thin extruded mesh (0.001 units thick)
                fillMesh = BABYLON.MeshBuilder.ExtrudePolygon(name + '_fill', {
                    shape: shape2D,
                    depth: 0.001,
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, this.scene);
                
                // Position at the sketch plane
                fillMesh.position.y = points[0].y;
                fillMesh.material = fillMaterial;
                fillMesh.renderingGroupId = 0; // Render behind the border
                fillMesh.isPickable = true;
                
            } catch (error) {
                fillMesh = null;
            }
            
            // Create thick border using ribbons
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create parent mesh to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (fillMesh) fillMesh.parent = parentMesh;
            if (borderMesh) borderMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    onMouseDown(event) {
        this.mouseState.isDown = true;
        this.mouseState.button = event.button;
        this.mouseState.lastX = event.clientX;
        this.mouseState.lastY = event.clientY;
        
        // Only handle middle (1) and right (2) buttons
        if (event.button === 1 || event.button === 2) {
            event.preventDefault();
        }
    }
    
    onMouseMove(event) {
        if (!this.mouseState.isDown) return;
        
        const deltaX = event.clientX - this.mouseState.lastX;
        const deltaY = event.clientY - this.mouseState.lastY;
        
        if (this.mouseState.button === 2) {
            // Right mouse = rotate
            this.camera.alpha += deltaX * 0.01;
            this.camera.beta += deltaY * 0.01;
            
            // Clamp beta
            this.camera.beta = Math.max(0.1, Math.min(Math.PI - 0.1, this.camera.beta));
            
        } else if (this.mouseState.button === 1) {
            // Middle mouse = pan
            const sensitivity = 0.001 * this.camera.radius;
            
            const forward = this.camera.getTarget().subtract(this.camera.position).normalize();
            const right = BABYLON.Vector3.Cross(forward, this.camera.upVector).normalize();
            const up = BABYLON.Vector3.Cross(right, forward).normalize();
            
            const panVector = right.scale(-deltaX * sensitivity).add(up.scale(deltaY * sensitivity));
            
            this.camera.target = this.camera.target.add(panVector);
            this.camera.setTarget(this.camera.target);
        }
        
        this.mouseState.lastX = event.clientX;
        this.mouseState.lastY = event.clientY;
    }
    
    onMouseUp(event) {
        this.mouseState.isDown = false;
        this.mouseState.button = -1;
    }
    
    onMouseWheel(event) {
        event.preventDefault();
        
        const delta = event.deltaY;
        const zoomSensitivity = 0.15;  // Increased for more sensitive zooming
        
        this.camera.radius += delta * zoomSensitivity;
        this.camera.radius = Math.max(2, Math.min(1000, this.camera.radius));
    }

    setupLighting() {
        // Hemispheric light for general illumination
        const hemiLight = new BABYLON.HemisphericLight(
            'hemiLight',
            new BABYLON.Vector3(0, 1, 0),
            this.scene
        );
        hemiLight.intensity = 0.7;
        
        // Directional light for shadows and definition
        const dirLight = new BABYLON.DirectionalLight(
            'dirLight',
            new BABYLON.Vector3(-1, -1, -1),
            this.scene
        );
        dirLight.intensity = 0.5;
        dirLight.position = new BABYLON.Vector3(10, 10, 10);
    }

    setupGrid() {
        // Create modular grid system
        this.gridSystem = new GridSystem(this.scene, this.camera);
        
        // Create legacy grid object for compatibility
        this.grid = { 
            isVisible: true,
            setVisible: (visible) => this.gridSystem.setVisible(visible)
        };
        
        // Initialize shape2D system
        this.shape2D = new Shape2D(this.scene, null); // Will be updated by sketch mode
        
        // Create coordinate axes
        this.createAxes();
        
        // Sketch ground will be created when entering sketch mode
    }

    toggleGrid() {
        if (this.gridSystem) {
            this.gridSystem.isVisible = !this.gridSystem.isVisible;
            this.gridSystem.setVisible(this.gridSystem.isVisible);
            console.log("Grid toggled:", this.gridSystem.isVisible ? "ON" : "OFF");
        } else {
            console.error("GridSystem not initialized");
        }
    }

    
    
    
    
    // Grid clipping function - REMOVED
    // New approach: generate grid lines that are guaranteed to be in front of camera
    // instead of clipping lines that extend behind the camera
    
    initializeGridLOD() {
        // Metric measurement scale (in cm - 1 unit = 1 cm)
        this.gridScales = [
            { minor: 0.1, major: 1, label: "1mm" },        // Finest detail - 1mm minor, 1cm major
            { minor: 0.2, major: 2, label: "2mm" },        
            { minor: 0.5, major: 5, label: "5mm" },        
            { minor: 1, major: 10, label: "1cm" },         // 1cm minor, 10cm major
            { minor: 2, major: 20, label: "2cm" },         
            { minor: 5, major: 50, label: "5cm" },         
            { minor: 10, major: 100, label: "10cm" },      // 10cm minor, 1m major
            { minor: 20, major: 200, label: "20cm" },      
            { minor: 50, major: 500, label: "50cm" },      
            { minor: 100, major: 1000, label: "1m" },      // 1m minor, 10m major
            { minor: 200, major: 2000, label: "2m" },      
            { minor: 500, major: 5000, label: "5m" },      
            { minor: 1000, major: 10000, label: "10m" }    // Large scale
        ];
        
        this.currentGridScale = 0;
        this.currentGridInfo = this.gridScales[0];
    }
    
    updateGridLOD() {
        const cameraDistance = this.camera.radius;
        
        // Calculate appropriate grid scale based on camera distance
        // The goal is to keep minor grid lines at a reasonable screen density
        let targetScale = 0;
        
        // Scale selection based on camera distance (cm units)
        if (cameraDistance < 5) targetScale = 0;        // 1mm
        else if (cameraDistance < 10) targetScale = 1;   // 2mm
        else if (cameraDistance < 20) targetScale = 2;   // 5mm
        else if (cameraDistance < 50) targetScale = 3;   // 1cm
        else if (cameraDistance < 100) targetScale = 4;  // 2cm
        else if (cameraDistance < 200) targetScale = 5;  // 5cm
        else if (cameraDistance < 500) targetScale = 6;  // 10cm
        else if (cameraDistance < 1000) targetScale = 7; // 20cm
        else if (cameraDistance < 2000) targetScale = 8; // 50cm
        else if (cameraDistance < 5000) targetScale = 9; // 1m
        else if (cameraDistance < 10000) targetScale = 10; // 2m
        else if (cameraDistance < 20000) targetScale = 11; // 5m
        else targetScale = 12; // 10m
        
        // Only update if scale changed
        if (targetScale !== this.currentGridScale) {
            this.currentGridScale = targetScale;
            this.currentGridInfo = this.gridScales[targetScale];
            
            // Update properties panel
            this.updateGridProperties();
            

        }
    }
    
    updateGridProperties() {
        const gridInfoElement = document.getElementById('grid-info');
        if (gridInfoElement) {
            gridInfoElement.textContent = `Grid: ${this.currentGridInfo.label}`;
        }
    }
    

    createAxes() {
        // X axis (red)
        const xAxis = BABYLON.MeshBuilder.CreateLines('xAxis', {
            points: [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(5, 0, 0)
            ]
        }, this.scene);
        xAxis.color = new BABYLON.Color3(0.8, 0, 0);
        xAxis.isPickable = false;
        
        // Y axis (green)
        const yAxis = BABYLON.MeshBuilder.CreateLines('yAxis', {
            points: [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 5, 0)
            ]
        }, this.scene);
        yAxis.color = new BABYLON.Color3(0, 0.7, 0);
        yAxis.isPickable = false;
        
        // Z axis (blue)
        const zAxis = BABYLON.MeshBuilder.CreateLines('zAxis', {
            points: [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 0, 5)
            ]
        }, this.scene);
        zAxis.color = new BABYLON.Color3(0, 0, 0.8);
        zAxis.isPickable = false;
    }

    setupSketchPlanes() {
        // Create three orthographic sketch plane indicators
        this.createSketchPlaneIndicators();
    }

    createSketchPlaneIndicators() {
        const planeSize = 0.5;
        const planeDistance = 3;
        
        // XY plane (front view)
        const xyPlane = BABYLON.MeshBuilder.CreatePlane('xyPlane', {
            size: planeSize
        }, this.scene);
        xyPlane.position = new BABYLON.Vector3(0, 0, planeDistance);
        xyPlane.billboardMode = BABYLON.AbstractMesh.BILLBOARD_NONE;
        
        // XZ plane (top view)
        const xzPlane = BABYLON.MeshBuilder.CreatePlane('xzPlane', {
            size: planeSize
        }, this.scene);
        xzPlane.position = new BABYLON.Vector3(0, planeDistance, 0);
        xzPlane.rotation.x = Math.PI / 2;
        
        // YZ plane (side view)
        const yzPlane = BABYLON.MeshBuilder.CreatePlane('yzPlane', {
            size: planeSize
        }, this.scene);
        yzPlane.position = new BABYLON.Vector3(planeDistance, 0, 0);
        yzPlane.rotation.y = Math.PI / 2;
        
        // Create materials for sketch planes
        const planeMaterial = new BABYLON.StandardMaterial('planeMaterial', this.scene);
        planeMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
        planeMaterial.alpha = 0.7;
        planeMaterial.backFaceCulling = false;
        planeMaterial.doubleSided = true;
        
        xyPlane.material = planeMaterial;
        xzPlane.material = planeMaterial;
        yzPlane.material = planeMaterial;
        
        // Store planes for interaction
        this.sketchPlanes = [xyPlane, xzPlane, yzPlane];
        
        // Add click handlers with proper surface detection
        this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK && pointerInfo.pickInfo.hit) {
                const pickedMesh = pointerInfo.pickInfo.pickedMesh;
                
                // Check if it's one of our sketch plane indicators
                if (this.sketchPlanes.includes(pickedMesh)) {
                    const pickInfo = pointerInfo.pickInfo;
                    this.selectSketchPlane(pickedMesh, pickInfo);
                }
            }
        });
    }

    selectSketchPlane(mesh, pickInfo) {


        
        // Prevent entering sketch mode if already in sketch mode
        if (this.isSketchMode) {

            return;
        }
        
        // Get the surface normal at the picked point
        const surfaceNormal = pickInfo.getNormal(true, true);
        const pickPoint = pickInfo.pickedPoint;
        

        
        // Update selection info
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            selectionInfo.textContent = `${mesh.name} selected`;
        }
        
        // Enter sketch mode with surface data - DISABLED
        // Only enter sketch mode via the sketch tool now
        // this.enterSketchMode(mesh, pickPoint, surfaceNormal);

    }

    enterSketchMode(mesh, pickPoint, surfaceNormal) {

        
        this.currentSketchSurface = {
            mesh: mesh,
            point: pickPoint,
            normal: surfaceNormal.normalize()
        };
        this.isSketchMode = true;
        
        // Grid updates are managed by GridSystem internally
        
        // Update UI
        this.setMode('sketch');
        
        // STEP 1: Create coordinate system for the surface
        this.createSketchCoordinateSystem(surfaceNormal);
        
        // STEP 2: Animate camera to surface position
        this.animateCameraToSurface(pickPoint, surfaceNormal, () => {
            // STEP 3: After camera animation completes, create grid and enable tools
            this.createSketchEnvironment();
        });
        

    }

    createSketchCoordinateSystem(surfaceNormal) {

        
        // Create a robust coordinate system for any surface orientation
        const normal = surfaceNormal.normalize();

        
        // Choose the most stable reference vector based on the normal
        let up = new BABYLON.Vector3(0, 1, 0); // World up
        
        // If surface normal is nearly vertical, use a different reference
        const dotProduct = Math.abs(BABYLON.Vector3.Dot(normal, up));

        
        if (dotProduct > 0.9) {
            up = new BABYLON.Vector3(1, 0, 0); // World X if normal is too close to Y

        }
        
        // Create orthonormal basis using Gram-Schmidt process
        this.sketchForward = normal.clone(); // Surface normal points "out" from surface
        this.sketchRight = BABYLON.Vector3.Cross(up, this.sketchForward);
        

        
        if (this.sketchRight.length() < 0.001) {

            // Use a perpendicular vector
            if (Math.abs(normal.x) < 0.9) {
                this.sketchRight = BABYLON.Vector3.Cross(new BABYLON.Vector3(1, 0, 0), this.sketchForward);
            } else {
                this.sketchRight = BABYLON.Vector3.Cross(new BABYLON.Vector3(0, 0, 1), this.sketchForward);
            }
        }
        
        this.sketchRight = this.sketchRight.normalize();
        this.sketchUp = BABYLON.Vector3.Cross(this.sketchForward, this.sketchRight).normalize();
        
        // Verify we have a valid orthonormal basis
        if (this.sketchRight.length() < 0.1 || this.sketchUp.length() < 0.1) {

            // Fallback to a simple XY plane
            this.sketchRight = new BABYLON.Vector3(1, 0, 0);
            this.sketchUp = new BABYLON.Vector3(0, 1, 0);
            this.sketchForward = new BABYLON.Vector3(0, 0, 1);
        }
        
        // Store surface origin (the picked point)
        this.sketchOrigin = this.currentSketchSurface.point.clone();
        
        // Update Shape2D coordinate system
        if (this.shape2D) {
            
            this.shape2D.sketchSystem = {
                sketchForward: this.sketchForward,
                sketchRight: this.sketchRight,
                sketchUp: this.sketchUp,
                sketchOrigin: this.sketchOrigin
            };
        }

    }
    
    animateCameraToSurface(pickPoint, surfaceNormal, onComplete) {
        const normal = surfaceNormal.normalize();
        
        // Calculate the vector from pick point to current camera position
        const pickPointToCamera = this.camera.position.subtract(pickPoint);
        const normalDot = BABYLON.Vector3.Dot(pickPointToCamera, normal);
        
        // If dot product is positive, camera is on the side the normal points to
        // If negative, camera is on the opposite side - we want to keep it there
        const correctNormal = normalDot > 0 ? normal : normal.scale(-1);
        
        // Maintain the same distance from target as when picking
        const currentDistance = BABYLON.Vector3.Distance(this.camera.position, pickPoint);
        const targetPosition = pickPoint.add(correctNormal.scale(currentDistance));
        
        // Target should be the face center passed in (not the original picked point)
        const targetTarget = pickPoint.clone();
        const targetUp = this.sketchUp.clone();
        
        // Store current camera state
        const startPosition = this.camera.position.clone();
        const startTarget = this.camera.getTarget().clone();
        const startUp = this.camera.upVector.clone();
        
        // Animation timing - smooth and elegant but not too dramatic
        const animationDuration = 1800; // 1.8 seconds total
        const startTime = Date.now();
        
        // Start 3D grid fade out immediately
        this.beginGridFadeTransition();
        
        // Single-phase smooth animation - orientation and subtle position change together
        const animateCamera = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            const easedProgress = this.easeInOutCubic(progress);
            
            // Smooth orientation alignment
            this.camera.setTarget(BABYLON.Vector3.Lerp(startTarget, targetTarget, easedProgress));
            this.camera.upVector = BABYLON.Vector3.Lerp(startUp, targetUp, easedProgress);
            
            // Subtle position adjustment - only 10% closer
            this.camera.position = BABYLON.Vector3.Lerp(startPosition, targetPosition, easedProgress);
            
            if (progress < 1) {
                // Continue animation
                requestAnimationFrame(animateCamera);
            } else {
                // Animation complete - finalize camera setup
                this.finalizeCameraSetup(pickPoint, surfaceNormal);
                onComplete();
            }
        };
        
        // Start animation
        requestAnimationFrame(animateCamera);
    }
    
    // Beautiful easing function for smooth animations
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    // Begin the gentle fade transition between 3D grid and sketch grid
    beginGridFadeTransition() {
        // Fade out 3D grid slowly and beautifully
        if (this.grid && this.grid.gridLines) {
            const fadeOutDuration = 2000; // 2 seconds for beautiful fade out
            const startTime = Date.now();
            const initialAlpha = this.grid.gridLines[0]?.material?.alpha || 1;
            
            const fadeOut3DGrid = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / fadeOutDuration, 1);
                const easedProgress = this.easeInOutCubic(progress);
                
                // Fade out 3D grid
                const newAlpha = initialAlpha * (1 - easedProgress);
                this.grid.gridLines.forEach(line => {
                    if (line.material) {
                        line.material.alpha = newAlpha;
                    }
                });
                
                if (progress < 1) {
                    requestAnimationFrame(fadeOut3DGrid);
                }
            };
            
            requestAnimationFrame(fadeOut3DGrid);
        }
    }
    
    finalizeCameraSetup(pickPoint, surfaceNormal) {

        
        // Switch to orthographic projection
        this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        
        // Set orthographic bounds based on camera distance to maintain same scale
        const cameraDistance = BABYLON.Vector3.Distance(this.camera.position, pickPoint);
        const viewSize = cameraDistance * 0.4; // Scale factor to match perspective view
        const aspectRatio = this.engine.getAspectRatio(this.camera);
        this.camera.orthoLeft = -viewSize * aspectRatio;
        this.camera.orthoRight = viewSize * aspectRatio;
        this.camera.orthoBottom = -viewSize;
        this.camera.orthoTop = viewSize;
        
        // Disable camera animations and inertia for precise control
        this.camera.inertia = 0;
        this.camera.panningInertia = 0;
        
        
        // Setup sketch-specific camera controls
        this.setupSketchCameraControls();
    }

    createSketchEnvironment() {

        
        // Initialize sketching system - preserve existing elements if any
        this.currentSketch = {
            surface: this.currentSketchSurface,
            elements: this.closedShapes || [], // Preserve existing shapes
            isDrawing: false,
            currentTool: 'line',
            // Reset tool-specific state
            startPoint: null,
            trianglePoints: []
        };
        
        // Create sketch plane grid with fade-in effect
        this.createSketchPlaneGrid();
        
        // Add sketch drawing toolbar
        this.showSketchToolbar();
        
        // Set up mouse handlers for sketching
        this.setupSketchingMouseHandlers();
        

    }

    showSketchToolbar() {
        // Add sketch tools to the toolbar
        const toolbar = document.querySelector('.toolbar');
        
        // Clear existing tools
        toolbar.innerHTML = '';
        
        // Add sketch tools
        const tools = [
            { name: 'line', label: 'Line', icon: '📏' },
            { name: 'rectangle', label: 'Rectangle', icon: '▭' },
            { name: 'circle', label: 'Circle', icon: '○' },
            { name: 'ellipse', label: 'Ellipse', icon: '⬭' },
            { name: 'triangle', label: 'Triangle', icon: '△' },
            { name: 'exit', label: 'Exit Sketch', icon: '✓' }
        ];
        
        tools.forEach(tool => {
            const btn = document.createElement('button');
            btn.className = 'tool-btn';
            btn.id = `${tool.name}-tool`;
            btn.innerHTML = `${tool.icon} ${tool.label}`;
            
            if (tool.name === 'line') {
                btn.classList.add('active');
            }
            
            btn.addEventListener('click', () => {
                if (tool.name === 'exit') {
                    this.exitSketchMode();
                } else {
                    this.selectSketchTool(tool.name);
                }
            });
            
            toolbar.appendChild(btn);
        });
    }

    selectSketchTool(toolName) {
        console.log('selectSketchTool called with toolName:', toolName);
        
        if (toolName === 'sketch') {
            // Sketch tool selected - enter surface selection mode
            this.sketchToolSelected = true;
            this.waitingForSurface = true;
            
            // Show the 3 default sketch planes
            this.showSketchTargets();
            
            // Update mode indicator
            const modeIndicator = document.getElementById('mode-indicator');
            if (modeIndicator) {
                modeIndicator.textContent = 'Select a surface for sketching';
            }
            
            // Update properties panel
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Click on a flat surface to create a sketch';
            }
            
            
        } else if (toolName === 'exit-sketch') {
            // Exit sketch mode
            this.exitSketchMode();
            
        } else if (toolName === 'extrude') {
            // Activate extrude tool
            console.log('EXTRUDE TOOL ACTIVATED! selectedFace:', this.selectedFace?.name);
            this.activeTool = 'extrude';
            
            // Update button visual state
            this.updateToolButtonStates();
            
            if (this.selectedFace) {
                console.log('Starting extrusion for face:', this.selectedFace.name);
                this.startBidirectionalExtrusion();
            } else {
                console.log('Extrude tool active - waiting for face selection');
                // Show instruction in UI
                const selectionInfo = document.getElementById('selection-info');
                if (selectionInfo) {
                    selectionInfo.textContent = 'Extrude tool active - Click on a 2D face to extrude';
                }
            }
            
        } else if (toolName === 'rip-cut') {
            // Activate rip cut tool (cut along grain/length)
            console.log('RIP CUT TOOL ACTIVATED!');
            this.activeTool = 'rip-cut';
            
            // Clear drag handles and manipulation buttons since cut tools don't use them
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate cut tool system
            this.cutToolSystem.activate('rip');
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Rip Cut active - Hover over lumber to preview cut line, click to cut';
            }
            
        } else if (toolName === 'cross-cut') {
            // Activate cross cut tool (cut across grain/width)
            console.log('CROSS CUT TOOL ACTIVATED!');
            this.activeTool = 'cross-cut';
            
            // Clear drag handles and manipulation buttons since cut tools don't use them
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate cut tool system
            this.cutToolSystem.activate('cross');
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Cross Cut active - Hover over lumber to preview cut line, click to cut';
            }
            
        } else if (toolName === 'pointer') {
            // Activate pointer tool (default selection)
            console.log('POINTER TOOL ACTIVATED!');
            this.activeTool = 'pointer';
            
            // Deactivate cut tool if it's active
            if (this.cutToolSystem) {
                this.cutToolSystem.deactivate();
            }
            
            // CRITICAL: Deactivate router tool if it's active 
            if (this.routerBitSystem) {
                this.routerBitSystem.deactivate();
            }
            
            // Clear drag handles and manipulation buttons since pointer tool doesn't use them
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Pointer active - Click to select parts';
            }
            
        } else if (toolName === 'move') {
            // Activate move tool (shows manipulation buttons immediately)
            console.log('MOVE TOOL ACTIVATED!');
            this.activeTool = 'move';
            
            // Deactivate cut tool if it's active
            if (this.cutToolSystem) {
                this.cutToolSystem.deactivate();
            }
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Show manipulation buttons immediately (even without selection)
            this.showManipulationInPropertiesPanel(null);
            
            // Show gizmos if part is selected
            if (this.selectedPart) {
                const selectedMesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                this.createDragHandles(selectedMesh);
                // Update panel with selected part info
                this.showManipulationInPropertiesPanel(selectedMesh);
            }
            
        } else if (toolName === 'router') {
            // Activate router tool for edge shaping
            console.log('ROUTER TOOL ACTIVATED!');
            console.log('DEBUG: selectedPart before router activation:', this.selectedPart);
            this.activeTool = 'router';
            
            // Clear drag handles and manipulation buttons but preserve part selection
            this.clearDragHandles();
            this.clearManipulationButtons();
            console.log('DEBUG: selectedPart after clearing handles:', this.selectedPart);
            
            // Update button visual state
            this.updateToolButtonStates();
            console.log('DEBUG: selectedPart after updateToolButtonStates:', this.selectedPart);
            
            // Activate router bit system with default roundover profile
            this.routerBitSystem.activate('roundover');
            
            // If a part is already selected, focus edge detection on that part
            if (this.selectedPart) {
                const selectedMesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (selectedMesh) {
                    this.routerBitSystem.setFocusPart(selectedMesh);
                    console.log('RouterBitSystem: Focused on selected part for edge detection');
                }
            }
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                if (this.selectedPart) {
                    selectionInfo.textContent = 'Router tool active - Click edges of selected board to select them, then press R';
                } else {
                    selectionInfo.textContent = 'Router tool active - Select a board first, then click its edges';
                }
            }
            
        } else if (toolName === 'scroll-cut') {
            // Activate scroll cutting tool for freehand cutting
            console.log('🎨 SCROLL CUTTING TOOL ACTIVATED!');
            this.activeTool = 'scroll-cut';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Check if a part is selected
            if (this.selectedPart) {
                const selectedMesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (selectedMesh && selectedMesh.isWorkBenchPart) {
                    // Activate scroll cutting on the selected part
                    const success = this.scrollCuttingSystem.activate(selectedMesh);
                    if (success) {
                        console.log('🎨 Scroll cutting activated on:', selectedMesh.partData?.materialName);
                    } else {
                        console.warn('🎨 Failed to activate scroll cutting');
                    }
                } else {
                    console.warn('🎨 Selected part is not suitable for scroll cutting');
                }
            } else {
                // No part selected - try to find any workbench part
                console.log('🎨 No part selected, looking for workbench parts...');
                const workBenchParts = this.workBenchParts.filter(part => part.isWorkBenchPart);
                
                if (workBenchParts.length > 0) {
                    // Use the first workbench part
                    const firstPart = workBenchParts[0];
                    const success = this.scrollCuttingSystem.activate(firstPart);
                    if (success) {
                        console.log('🎨 Scroll cutting activated on first workbench part:', firstPart.partData?.materialName);
                    } else {
                        console.warn('🎨 Failed to activate scroll cutting on first workbench part');
                    }
                } else {
                    console.warn('🎨 No workbench parts available for scroll cutting');
                    
                    // Show message to select a part first
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        selectionInfo.innerHTML = '<strong style="color: red;">⚠️ No Parts Available</strong><br><span style="font-size: 0.9em;">Please add a part to the workbench first to use scroll cutting.</span>';
                    }
                }
            }
            
        } else if (toolName === 'plane') {
            // Activate planing tool for thickness reduction
            console.log('🪚 PLANE TOOL ACTIVATED!');
            this.activeTool = 'plane';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate plane tool system
            this.planeToolSystem.activate();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Plane tool active - Hover over lumber to preview thickness removal, click to plane';
            }
            
        } else if (toolName === 'join') {
            // Activate join tool for precision part alignment
            console.log('🧩 JOIN TOOL ACTIVATED!');
            this.activeTool = 'join';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate join tool system
            this.joinToolSystem.activate();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Join tool active - Click first piece to join';
            }
            
        } else if (toolName === 'drill') {
            // Activate drill press tool for precision hole drilling
            console.log('🔩 DRILL PRESS ACTIVATED!');
            this.activeTool = 'drill';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate drill press system
            this.drillPressSystem.activate();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Drill press active - Click on surface to position orthographic view, then place hole markers';
            }
            
        } else {
            // Deactivate scroll cutting system when switching away from scroll-cut tool
            if (this.scrollCuttingSystem && this.activeTool === 'scroll-cut') {
                this.scrollCuttingSystem.deactivate();
            }
            
            // Deactivate plane tool system when switching away from plane tool
            if (this.planeToolSystem && this.activeTool === 'plane') {
                this.planeToolSystem.deactivate();
            }
            
            // Deactivate saw tool system when switching away from saw tool
            if (this.sawToolSystem && this.activeTool === 'saw') {
                this.sawToolSystem.deactivate();
            }
            
            // Deactivate join tool system when switching away from join tool
            if (this.joinToolSystem && this.activeTool === 'join') {
                this.joinToolSystem.deactivate();
            }
            
            // Deactivate drill press system when switching away from drill tool
            if (this.drillPressSystem && this.activeTool === 'drill') {
                this.drillPressSystem.deactivate();
            }
            
            // Other tools selected - clear active tool and sketch tool
            this.activeTool = null;
            this.sketchToolSelected = false;
            this.waitingForSurface = false;
            
            // Clear drag handles and manipulation buttons since we're switching away from Move tool
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Deactivate cut tool system
            if (this.cutToolSystem) {
                this.cutToolSystem.deactivate();
            }
            
            // Deactivate router bit system
            if (this.routerBitSystem) {
                this.routerBitSystem.deactivate();
            }
            
            // Hide the default sketch planes
            this.hideSketchTargets();
            
            // Reset mode indicator
            const modeIndicator = document.getElementById('mode-indicator');
            if (modeIndicator) {
                modeIndicator.textContent = '3D Modeling';
            }
            
            // Reset properties panel
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Nothing selected';
            }
            
            // Handle regular sketch drawing tools if in sketch mode
            if (this.currentMode === 'sketch' && this.currentSketch) {
                this.currentSketch.currentTool = toolName;
            }
        }
    }
    
    updateToolButtonStates() {
        // Clear all active states
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set active state for current tool
        if (this.activeTool) {
            const activeButton = document.querySelector(`[data-tool="${this.activeTool}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
                console.log('Set active state for tool:', this.activeTool);
            }
        }
    }

    enterSketchModeOnSurface(mesh, pickPoint, normal) {
        
        // Clear sketch tool selection state
        this.sketchToolSelected = false;
        this.waitingForSurface = false;
        
        // Hide the sketch targets
        this.hideSketchTargets();
        
        // Deselect the sketch tool button
        document.querySelectorAll('[data-tool="sketch"]').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // For the cube, just use the position + half size in the normal direction
        const cubePosition = mesh.position;
        const cubeSize = 4; // 8cm cube = 4cm from center to face
        
        const faceCenter = cubePosition.add(normal.scale(cubeSize));
        
        this.setMode('sketch');
        this.enterSketchMode(mesh, faceCenter, normal);
    }

    createDefaultSketchTarget() {
        // UNITS: 1 unit = 1 cm
        const cubeSize = 8; // 8cm cube for easy selection
        
        // Force dispose any existing cube first
        const existingCube = this.scene.getMeshByName('sketchTarget');
        if (existingCube) {
            existingCube.dispose();
        }
        
        // Create completely solid target material with new name
        const targetMaterial = new BABYLON.StandardMaterial('solidCubeMaterial_' + Date.now(), this.scene);
        targetMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8); // Solid dark blue
        targetMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        targetMaterial.backFaceCulling = false;
        targetMaterial.disableLighting = false;
        
        // Create the cube - this is just the default target, any geometry can be used
        const sketchTarget = BABYLON.MeshBuilder.CreateBox('sketchTarget', {
            size: cubeSize
        }, this.scene);
        
        sketchTarget.position = new BABYLON.Vector3(0, cubeSize/2 + 2, 0); // Above grid with 2cm clearance
        sketchTarget.material = targetMaterial;
        sketchTarget.isPickable = true;
        sketchTarget.setEnabled(false); // Hidden by default
        
        // Add metadata to identify this as a sketch target (generic approach)
        sketchTarget.metadata = {
            isSketchTarget: true,
            targetType: 'default'
        };
        
        // Store reference
        this.defaultSketchTarget = sketchTarget;
        
    }

    showSketchTargets() {
        // Show default sketch target if no other geometry exists
        if (!this.defaultSketchTarget) {
            this.createDefaultSketchTarget();
        }
        
        // Enable and animate the target to fade in
        this.defaultSketchTarget.setEnabled(true);
        
        // Start with alpha 0 and animate to solid
        const material = this.defaultSketchTarget.material;
        const targetAlpha = 1.0; // Solid opacity
        material.alpha = 0;
        
        // Animate fade in
        BABYLON.Animation.CreateAndStartAnimation(
            'fadeInSketchTarget',
            material,
            'alpha',
            60, // 60 fps
            30, // 0.5 seconds
            0,  // start alpha
            targetAlpha, // end alpha
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            null,
            null
        );
        
    }

    hideSketchTargets() {
        // Hide default sketch target
        if (this.defaultSketchTarget && this.defaultSketchTarget.isEnabled()) {
            const material = this.defaultSketchTarget.material;
            
            // Animate fade out
            BABYLON.Animation.CreateAndStartAnimation(
                'fadeOutSketchTarget',
                material,
                'alpha',
                60, // 60 fps
                15, // 0.25 seconds (faster fade out)
                material.alpha, // current alpha
                0,  // end alpha
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                null,
                () => {
                    // Disable the target after animation
                    this.defaultSketchTarget.setEnabled(false);
                }
            );
        }
        
        // Future: Could also handle hiding other sketch targets from existing geometry
    }
    
    // Generic method to determine if any mesh can be used for sketching
    isMeshSketchable(mesh) {
        // Basic requirements for any sketchable surface
        if (!mesh || !mesh.isPickable || !mesh.isEnabled()) {
            return false;
        }
        
        // Exclude system meshes (grid, axes, etc.)
        const systemMeshNames = ['sketchGround', 'gridGround', 'gridGroundBelow', 'xAxis', 'yAxis', 'zAxis'];
        if (systemMeshNames.includes(mesh.name)) {
            return false;
        }
        
        // Exclude sketch preview meshes
        if (mesh.name.includes('Preview') || mesh.name.includes('preview')) {
            return false;
        }
        
        // Any other mesh with proper geometry is sketchable
        // This includes: default sketch targets, user-created geometry, imported models, etc.
        return true;
    }

    setupSketchingMouseHandlers() {

        
        // Track mouse down/up for drag detection
        this.mouseDownTime = 0;
        this.mouseDownPos = null;
        this.isDragging = false;
        
        // Unified mouse down handler for both drawing and camera
        this.sketchMouseDownHandler = (e) => {

            if (!this.isSketchMode) return;
            
            // Prevent Babylon.js from handling this event
            e.preventDefault();
            e.stopPropagation();
            
            if (e.button === 0) {
                // Left click - drawing
                this.mouseDownTime = Date.now();
                this.mouseDownPos = { x: e.clientX, y: e.clientY };
                this.isDragging = false;

            } else if (e.button === 1 || e.button === 2) {
                // Middle or right click - camera panning
                this.sketchCameraState.isPanning = true;
                this.sketchCameraState.lastX = e.clientX;
                this.sketchCameraState.lastY = e.clientY;
                e.preventDefault();

            }
        };
        
        // Unified mouse up handler for both drawing and camera
        this.sketchMouseUpHandler = (e) => {

            if (!this.isSketchMode) return;
            
            // Prevent Babylon.js from handling this event
            e.preventDefault();
            e.stopPropagation();
            
            if (e.button === 0) {
                // Left click - drawing
                const timeDiff = Date.now() - this.mouseDownTime;
                const posDiff = this.mouseDownPos ? 
                    Math.sqrt(Math.pow(e.clientX - this.mouseDownPos.x, 2) + 
                             Math.pow(e.clientY - this.mouseDownPos.y, 2)) : 0;
                

                
                // If it's a quick click (not a drag)
                if (timeDiff < 200 && posDiff < 5) {

                    e.preventDefault();
                    e.stopPropagation();
                    this.handleSketchClick(e);
                } else if (this.isDragging && this.currentSketch.currentTool === 'rectangle') {
                    // End drag for rectangle

                    this.handleSketchClick(e);
                }
                
                this.isDragging = false;
                this.mouseDownPos = null;
            } else if (e.button === 1 || e.button === 2) {
                // Middle or right click - stop camera panning
                this.sketchCameraState.isPanning = false;

            }
        };
        
        // Unified mouse move handler for both drawing and camera
        this.sketchMoveHandler = (e) => {
            if (!this.isSketchMode) return;
            
            // Handle camera panning
            if (this.sketchCameraState.isPanning) {
                const deltaX = e.clientX - this.sketchCameraState.lastX;
                const deltaY = e.clientY - this.sketchCameraState.lastY;
                
                // Pan along the sketch plane
                const panSensitivity = 0.01;
                const panVector = this.sketchRight.scale(-deltaX * panSensitivity)
                    .add(this.sketchUp.scale(deltaY * panSensitivity));
                
                this.camera.position = this.camera.position.add(panVector);
                this.camera.setTarget(this.camera.getTarget().add(panVector));
                
                this.sketchCameraState.lastX = e.clientX;
                this.sketchCameraState.lastY = e.clientY;
                return; // Don't process drawing when panning
            }
            
            // Handle drawing interactions
            if (this.currentSketch) {
                // Rectangle drawing is already started on mouse down, just continue updating
                // No need for drag detection threshold
                
                // Update preview if drawing
                if (this.currentSketch.isDrawing) {
                    this.updateSketchPreview(e);
                }
            }
        };
        
        // Unified wheel handler for camera zoom
        this.sketchWheelHandler = (e) => {
            if (!this.isSketchMode) return;
            
            e.preventDefault();
            
            // Zoom by adjusting orthographic bounds - more responsive
            const zoomFactor = e.deltaY > 0 ? 1.05 : 0.95;  // Smaller steps for smoother zoom
            const aspectRatio = this.engine.getAspectRatio(this.camera);
            
            const currentHeight = this.camera.orthoTop - this.camera.orthoBottom;
            const newHeight = currentHeight * zoomFactor;
            const newWidth = newHeight * aspectRatio;
            
            this.camera.orthoLeft = -newWidth / 2;
            this.camera.orthoRight = newWidth / 2;
            this.camera.orthoBottom = -newHeight / 2;
            this.camera.orthoTop = newHeight / 2;
        };
        
        // Use Babylon.js pointer event system instead of direct mouse events
        this.scene.onPointerObservable.add((pointerInfo) => {

            
            if (!this.isSketchMode) return;
            
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:

                    this.handleBabylonPointerDown(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:

                    this.handleBabylonPointerUp(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.handleBabylonPointerMove(pointerInfo);
                    break;
            }
        });
        

        
        // Test that canvas is receiving events
        // Removed duplicate click handler
    }
    
    handleBabylonPointerDown(pointerInfo) {
        try {
            const event = pointerInfo.event;
            
            // Handle surface selection for sketch tool
            if (this.waitingForSurface && event.button === 0) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                
                // Pick any surface in the scene
                const pickInfo = this.scene.pick(x, y, (mesh) => {
                    // Accept any pickable mesh that could be a surface, including default sketch planes
                    const isValid = mesh.isPickable && mesh.name !== 'sketchGround';
                    return isValid;
                });
                
                
                if (pickInfo.hit && pickInfo.pickedMesh) {
                    this.enterSketchModeOnSurface(pickInfo.pickedMesh, pickInfo.pickedPoint, pickInfo.getNormal());
                    return; // Stop processing - we handled the surface selection
                } else {
                }
            }

            // Check for part selection (only if not waiting for surface)
            if (!this.waitingForSurface && event.button === 0) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Check if we clicked on a mesh with partData property
                const partPickInfo = this.scene.pick(x, y, (mesh) => mesh && mesh.partData);
                
                if (partPickInfo.hit && partPickInfo.pickedMesh && partPickInfo.pickedMesh.partData) {
                    this.selectPart(partPickInfo.pickedMesh.partData);
                    return; // Stop processing - we handled the part selection
                }
            }

            if (event.button === 0) {
                // Left click - drawing
                console.log('LEFT CLICK - sketch mode:', this.isSketchMode, 'current tool:', this.currentSketch?.currentTool);
                try {
                    this.mouseDownTime = Date.now();
                    this.mouseDownPos = { x: event.clientX, y: event.clientY };
                    this.isDragging = false;
                
                
                // For rectangle tool, start drawing immediately on mouse down
                if (this.currentSketch && this.currentSketch.currentTool === 'rectangle') {
                    console.log('RECTANGLE TOOL DETECTED');
                    const rect = this.canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                    console.log('PICK RESULT:', pickInfo.hit, pickInfo.pickedMesh?.name);
                    
                    if (pickInfo.hit) {
                        console.log('STARTING RECTANGLE DRAW');
                        // Start rectangle drawing immediately on mouse down
                        this.currentSketch.isDrawing = true;
                        // Apply grid snapping to start point (half-grid if Shift is held)
                        this.currentSketch.startPoint = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);
                        this.isDragging = true; // Set dragging immediately
                        
                        // Clear any existing preview
                        if (this.shapePreview) {
                            this.shapePreview.dispose();
                            this.shapePreview = null;
                        }
                        
                        this.createRectanglePreview(pickInfo.pickedPoint, pickInfo.pickedPoint);
                    }
                }
                
                // For circle tool, start drawing immediately on mouse down
                if (this.currentSketch && this.currentSketch.currentTool === 'circle') {
                    console.log('CIRCLE TOOL DETECTED');
                    const rect = this.canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                    console.log('CIRCLE PICK RESULT:', pickInfo.hit, pickInfo.pickedMesh?.name);
                    
                    if (pickInfo.hit) {
                        console.log('STARTING CIRCLE DRAW');
                        // Start circle drawing immediately on mouse down
                        this.currentSketch.isDrawing = true;
                        // Apply grid snapping to start point (half-grid if Shift is held)
                        this.currentSketch.startPoint = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);
                        this.isDragging = true; // Set dragging immediately
                        
                        // Clear any existing preview
                        if (this.shapePreview) {
                            this.shapePreview.dispose();
                            this.shapePreview = null;
                        }
                        
                        this.createCirclePreview(pickInfo.pickedPoint, 0);
                    }
                }
            
            } catch (error) {

            }
            

        } else if (event.button === 1 || event.button === 2) {
            // Middle or right click - camera panning
            this.sketchCameraState.isPanning = true;
            this.sketchCameraState.lastX = event.clientX;
            this.sketchCameraState.lastY = event.clientY;

        }
        
        } catch (error) {

        }
    }
    
    handleBabylonPointerUp(pointerInfo) {
        const event = pointerInfo.event;

        
        if (event.button === 0) {
            // Left click - drawing
            const timeDiff = Date.now() - this.mouseDownTime;
            const posDiff = this.mouseDownPos ? 
                Math.sqrt(Math.pow(event.clientX - this.mouseDownPos.x, 2) + 
                         Math.pow(event.clientY - this.mouseDownPos.y, 2)) : 0;
            

            



            
            // For rectangle tool, finish drawing on mouse up if we were dragging
            if (this.currentSketch && this.currentSketch.currentTool === 'rectangle' && this.currentSketch.isDrawing) {

                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                if (pickInfo.hit) {
                    // Apply grid snapping to end point (half-grid if Shift is held)
                    const snappedPoint = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);
                    this.finishRectangle(snappedPoint);
                    this.currentSketch.isDrawing = false;
                } else {

                }
            }
            // For circle tool, finish drawing on mouse up if we were dragging
            else if (this.currentSketch && this.currentSketch.currentTool === 'circle' && this.currentSketch.isDrawing) {
                console.log('FINISHING CIRCLE DRAW');
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                if (pickInfo.hit) {
                    // Apply grid snapping to end point
                    const snappedPoint = this.snapToGrid(pickInfo.pickedPoint);
                    // Calculate radius from start point to snapped end point
                    const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, snappedPoint);
                    console.log('Circle radius:', radius);
                    this.finishCircle(radius);
                    this.currentSketch.isDrawing = false;
                }
            }
            // For NON-rectangle/circle tools, use the old click system
            else if (this.currentSketch && this.currentSketch.currentTool !== 'rectangle' && this.currentSketch.currentTool !== 'circle' && 
                     timeDiff < 1000 && posDiff < 20) {

                this.handleSketchClick(event);
            }
            // For rectangle tool with quick clicks, also avoid the old system
            else if (this.currentSketch && this.currentSketch.currentTool === 'rectangle') {

            }
            else {

            }
            
            this.isDragging = false;
            this.mouseDownPos = null;
        } else if (event.button === 1 || event.button === 2) {
            // Middle or right click - stop camera panning
            this.sketchCameraState.isPanning = false;

        }
    }
    
    handleBabylonPointerMove(pointerInfo) {
        const event = pointerInfo.event;
        
        // Handle camera panning
        if (this.sketchCameraState.isPanning) {
            const deltaX = event.clientX - this.sketchCameraState.lastX;
            const deltaY = event.clientY - this.sketchCameraState.lastY;
            
            // Pan along the sketch plane
            const panSensitivity = 0.01;
            const panVector = this.sketchRight.scale(-deltaX * panSensitivity)
                .add(this.sketchUp.scale(deltaY * panSensitivity));
            
            this.camera.position = this.camera.position.add(panVector);
            this.camera.setTarget(this.camera.getTarget().add(panVector));
            
            this.sketchCameraState.lastX = event.clientX;
            this.sketchCameraState.lastY = event.clientY;
            return;
        }
        
        // Handle drawing preview with proper coordinate handling
        if (this.currentSketch && this.currentSketch.isDrawing) {

            
            // Get canvas coordinates from Babylon pointer event
            const rect = this.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Pick the sketch ground for preview
            const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
            
            if (pickInfo.hit) {
                // Apply grid snapping to preview point (half-grid if Shift is held)
                const point = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);

                this.updateSketchPreviewWithPoint(point);
            } else {

            }
        }
    }
    
    setupSketchCameraControls() {
        // Disable default camera controls for sketch mode
        this.camera.detachControl(this.canvas);
        
        // Custom sketch camera controls for pan and zoom only
        this.sketchCameraState = {
            isPanning: false,
            lastX: 0,
            lastY: 0
        };
        
        // Note: Mouse handlers are now handled via Babylon.js pointer system

        
        // Add escape key handler
        this.sketchEscapeHandler = (e) => {
            if (e.key === 'Escape' && this.isSketchMode) {
                if (this.currentSketch && this.currentSketch.isDrawing) {
                    {
                        // Cancel current drawing
                        this.cancelCurrentDrawing();
                    }
                } else {
                    this.exitSketchMode();
                }
            }
        };
        document.addEventListener('keydown', this.sketchEscapeHandler);
    }
    
    setupSketchCameraControls() {
        // Disable default camera controls for sketch mode
        this.camera.detachControl(this.canvas);
        
        // Custom sketch camera controls for pan and zoom only
        this.sketchCameraState = {
            isPanning: false,
            lastX: 0,
            lastY: 0
        };
        
        // Note: Mouse handlers will be set up in setupSketchingMouseHandlers to avoid conflicts

    }
    
    createSketchPlaneGrid() {
        // Remove existing sketch grid if it exists
        if (this.sketchGrid) {
            this.sketchGrid.dispose();
            this.sketchGrid = null;
        }
        
        // Hide the main grid when in sketch mode
        if (this.gridSystem.gridGround) {
            this.gridSystem.gridGround.setEnabled(false);
        }
        
        // DIM NON-SKETCH MESHES BUT KEEP THEM VISIBLE FOR REFERENCE
        this.scene.meshes.forEach(mesh => {
            // Keep sketch shapes visible (rectangles, circles, etc.)
            const isSketchShape = mesh.name.includes('sketch') || mesh.name.includes('Sketch');
            
            if (!mesh.name.includes('Plane') && mesh.name !== 'sketchGround' && !isSketchShape) {
                // Dim background objects instead of hiding them
                if (mesh.material && !mesh.originalAlpha) {
                    // Store original alpha for restoration later
                    mesh.originalAlpha = mesh.material.alpha !== undefined ? mesh.material.alpha : 1.0;
                    // Dim to 30% opacity
                    mesh.material.alpha = mesh.originalAlpha * 0.3;
                }
                // Make them non-pickable during sketch mode
                mesh.isPickable = false;
            }
            
            // Hide the sketch plane indicators after entering sketch mode
            if (mesh.name.includes('Plane')) {
                mesh.isVisible = false;
                mesh.isPickable = false; // Also make them non-pickable
            }
        });
        
        // Create or update the sketch ground plane for picking
        this.updateSketchGround();
        
        // Create sketch grid lines
        this.createSketchGridLines();
        
        // Force the ground to update
        this.sketchGround.computeWorldMatrix(true);
    }
    
    createSketchGridLines() {
        // Create grid lines for sketch mode - positioned on the sketch surface
        const gridSize = 300; // 300cm grid (3 meters) - large area for sketching
        const divisions = 60; // 60 divisions = 5cm spacing
        const lineSpacing = gridSize / divisions;
        
        // Store grid spacing for snapping
        this.gridSpacing = lineSpacing; // 5cm
        this.halfGridSpacing = lineSpacing / 2; // 2.5cm
        
        this.sketchGridLines = [];
        
        // Get the sketch surface position and orientation
        const surfacePosition = this.currentSketchSurface.point;
        const surfaceNormal = this.currentSketchSurface.normal;
        
        // Create grid material
        const gridMaterial = new BABYLON.StandardMaterial('sketchGridMaterial', this.scene);
        gridMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
        gridMaterial.emissiveColor = new BABYLON.Color3(0.7, 0.7, 0.7);
        gridMaterial.disableLighting = true;
        gridMaterial.alpha = 0.8;
        
        // Use sketch coordinate system for proper grid orientation
        const right = this.sketchRight;
        const up = this.sketchUp;
        
        // Create horizontal lines (along the right direction)
        for (let i = 0; i <= divisions; i++) {
            const upOffset = -gridSize/2 + i * lineSpacing;
            const start = surfacePosition.add(right.scale(-gridSize/2)).add(up.scale(upOffset));
            const end = surfacePosition.add(right.scale(gridSize/2)).add(up.scale(upOffset));
            
            const points = [start, end];
            const line = BABYLON.MeshBuilder.CreateLines(`sketchGridH${i}`, {points: points}, this.scene);
            line.material = gridMaterial;
            line.isPickable = false;
            this.sketchGridLines.push(line);
        }
        
        // Create vertical lines (along the up direction)
        for (let i = 0; i <= divisions; i++) {
            const rightOffset = -gridSize/2 + i * lineSpacing;
            const start = surfacePosition.add(right.scale(rightOffset)).add(up.scale(-gridSize/2));
            const end = surfacePosition.add(right.scale(rightOffset)).add(up.scale(gridSize/2));
            
            const points = [start, end];
            const line = BABYLON.MeshBuilder.CreateLines(`sketchGridV${i}`, {points: points}, this.scene);
            line.material = gridMaterial;
            line.isPickable = false;
            this.sketchGridLines.push(line);
        }
    }
    
    snapToGrid(point, useHalfGrid = false) {
        if (!this.gridSpacing || !this.sketchRight || !this.sketchUp || !this.currentSketchSurface) return point;
        
        const spacing = useHalfGrid ? this.halfGridSpacing : this.gridSpacing;
        
        // Convert world point to sketch plane coordinates
        const sketchOrigin = this.currentSketchSurface.point;
        const localVector = point.subtract(sketchOrigin);
        
        // Project onto sketch plane axes
        const rightComponent = BABYLON.Vector3.Dot(localVector, this.sketchRight);
        const upComponent = BABYLON.Vector3.Dot(localVector, this.sketchUp);
        
        // Snap in sketch plane coordinates
        const snappedRight = Math.round(rightComponent / spacing) * spacing;
        const snappedUp = Math.round(upComponent / spacing) * spacing;
        
        // Convert back to world coordinates
        const snappedPoint = sketchOrigin
            .add(this.sketchRight.scale(snappedRight))
            .add(this.sketchUp.scale(snappedUp));
            
        return snappedPoint;
    }
    
    updateSketchGround() {
        // Remove existing sketch ground if it exists
        const existingGround = this.scene.getMeshByName('sketchGround');
        if (existingGround) {
            existingGround.dispose();
        }
        
        // Create a ground plane aligned with the selected surface - make it much larger
        this.sketchGround = BABYLON.MeshBuilder.CreatePlane('sketchGround', {
            width: 1000,  // 10 meter wide sketch area
            height: 1000  // 10 meter tall sketch area
        }, this.scene);
        
        // Position at the picked point on the surface
        this.sketchGround.position = this.currentSketchSurface.point.clone();
        
        // Align the ground plane with the surface normal
        // Create rotation to align plane normal with surface normal
        const surfaceNormal = this.currentSketchSurface.normal.normalize();
        const defaultNormal = new BABYLON.Vector3(0, 0, 1); // Default plane normal
        
        // Calculate rotation quaternion to align default normal with surface normal
        const rotationAxis = BABYLON.Vector3.Cross(defaultNormal, surfaceNormal);
        const rotationAngle = Math.acos(BABYLON.Vector3.Dot(defaultNormal, surfaceNormal));
        
        if (rotationAxis.length() > 0.001) {
            // Non-parallel normals - create rotation
            rotationAxis.normalize();
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.RotationAxis(rotationAxis, rotationAngle);
        } else if (BABYLON.Vector3.Dot(defaultNormal, surfaceNormal) < 0) {
            // Opposite normals - rotate 180 degrees around X axis
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(1, 0, 0), Math.PI);
        } else {
            // Same direction - no rotation needed
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.Identity();
        }
        
        // Create material for ground plane
        const groundMaterial = new BABYLON.StandardMaterial('sketchGroundMat', this.scene);
        groundMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 1.0); // Light blue tint
        groundMaterial.alpha = 0.001; // Nearly invisible but still pickable
        groundMaterial.backFaceCulling = false;
        this.sketchGround.material = groundMaterial;
        
        this.sketchGround.isVisible = true; // Must be visible for picking
        this.sketchGround.isPickable = true;
        

    }
    
    createLineGrid() {

        
        const gridSize = 20;
        const lineSpacing = 1;
        
        // Grid center at the surface origin (picked point) - CRITICAL for 3D geometry placement
        const gridCenter = this.sketchOrigin.clone();

        
        // Create arrays to hold all line segments
        const verticalLines = [];
        const horizontalLines = [];
        

        
        // Create grid lines aligned with the surface coordinate system
        for (let i = -gridSize; i <= gridSize; i += lineSpacing) {
            // Vertical lines (along sketch Up direction)
            const vStart = gridCenter
                .add(this.sketchRight.scale(i))
                .add(this.sketchUp.scale(-gridSize));
            const vEnd = gridCenter
                .add(this.sketchRight.scale(i))
                .add(this.sketchUp.scale(gridSize));
            verticalLines.push([vStart, vEnd]);
            
            // Horizontal lines (along sketch Right direction)
            const hStart = gridCenter
                .add(this.sketchRight.scale(-gridSize))
                .add(this.sketchUp.scale(i));
            const hEnd = gridCenter
                .add(this.sketchRight.scale(gridSize))
                .add(this.sketchUp.scale(i));
            horizontalLines.push([hStart, hEnd]);
        }
        

        
        // Log first few line positions for debugging
        if (verticalLines.length > 0) {

        }
        if (horizontalLines.length > 0) {

        }
        
        // Create line systems for better performance
        const verticalLineSystem = BABYLON.MeshBuilder.CreateLineSystem("verticalSketchGrid", {
            lines: verticalLines
        }, this.scene);
        verticalLineSystem.color = new BABYLON.Color3(0.6, 0.6, 0.6); // Grid lines
        verticalLineSystem.isPickable = false;
        
        const horizontalLineSystem = BABYLON.MeshBuilder.CreateLineSystem("horizontalSketchGrid", {
            lines: horizontalLines
        }, this.scene);
        horizontalLineSystem.color = new BABYLON.Color3(0.6, 0.6, 0.6); // Grid lines
        horizontalLineSystem.isPickable = false;
        
        // Create center axis lines with different colors
        const centerLines = [];
        
        // X axis (red) - along surface Right direction
        centerLines.push(BABYLON.MeshBuilder.CreateLines("sketchCenterX", {
            points: [
                gridCenter.add(this.sketchRight.scale(-gridSize)),
                gridCenter.add(this.sketchRight.scale(gridSize))
            ]
        }, this.scene));
        centerLines[0].color = new BABYLON.Color3(0.9, 0.2, 0.2); // Red
        centerLines[0].isPickable = false;
        
        // Y axis (green) - along surface Up direction
        centerLines.push(BABYLON.MeshBuilder.CreateLines("sketchCenterY", {
            points: [
                gridCenter.add(this.sketchUp.scale(-gridSize)),
                gridCenter.add(this.sketchUp.scale(gridSize))
            ]
        }, this.scene));
        centerLines[1].color = new BABYLON.Color3(0.2, 0.9, 0.2); // Green
        centerLines[1].isPickable = false;
        
        // Store all grid elements for cleanup
        this.sketchGridLines = [verticalLineSystem, horizontalLineSystem, ...centerLines];
        
        // Add fade-in effect for grid
        this.animateGridFadeIn();
        

    }
    
    animateGridFadeIn() {
        // Start with invisible grid
        this.sketchGridLines.forEach(gridLine => {
            gridLine.alpha = 0;
        });
        
        // Beautiful slow fade-in synchronized with camera movement
        const fadeInDuration = 1800; // 1.8 seconds for gentle appearance
        const startDelay = 800; // Start fade after 0.8s (during camera alignment phase)
        const startTime = Date.now();
        
        const fadeIn = () => {
            const elapsed = Date.now() - startTime;
            
            if (elapsed < startDelay) {
                // Wait for camera alignment to progress before starting fade
                requestAnimationFrame(fadeIn);
                return;
            }
            
            const fadeProgress = Math.min((elapsed - startDelay) / fadeInDuration, 1);
            
            // Beautiful ease-in-out effect
            const easedProgress = this.easeInOutCubic(fadeProgress);
            
            // Update alpha of all grid lines with gentle fade
            this.sketchGridLines.forEach(gridLine => {
                gridLine.alpha = easedProgress * 0.8; // Slightly more subtle than full opacity
            });
            
            if (fadeProgress < 1) {
                requestAnimationFrame(fadeIn);
            }
        };
        
        requestAnimationFrame(fadeIn);
    }

    handleSketchClick(event) {



        
        if (!this.isSketchMode || !this.currentSketch) {

            return;
        }
        
        // Get canvas-relative coordinates from the Babylon pointer event
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        

        
        // Use Babylon's picking with proper coordinates
        const pickInfo = this.scene.pick(x, y, (mesh) => {
            // Only pick the sketch ground for drawing
            return mesh.name === 'sketchGround';
        });
        
        
        if (pickInfo.hit && pickInfo.pickedMesh.name === 'sketchGround') {
            const point = pickInfo.pickedPoint;
            
            // Use the picked point directly since it's on the sketch plane
            const sketchPoint = point.clone();
            

            
            // Handle different tools
            switch (this.currentSketch.currentTool) {
                case 'line':

                    this.handleLineDrawing(sketchPoint);
                    break;
                case 'rectangle':

                    this.handleRectangleDrawing(sketchPoint);
                    break;
                case 'circle':

                    this.handleCircleDrawing(sketchPoint);
                    break;
                case 'ellipse':
                    this.handleEllipseDrawing(sketchPoint);
                    break;
                case 'triangle':
                    this.handleTriangleDrawing(sketchPoint);
                    break;
            }
        } else {

            
            const generalPick = this.scene.pick(x, y);
        }

    }

    projectToSketchPlane(point) {
        // Project the 3D point onto the sketch plane using the surface coordinate system
        // The sketch plane is defined by the surface origin and normal
        
        // Vector from surface origin to the point
        const toPoint = point.subtract(this.sketchOrigin);
        
        // Project out the component along the surface normal (keep point on the plane)
        const normalComponent = BABYLON.Vector3.Dot(toPoint, this.sketchForward);
        const projectedPoint = point.subtract(this.sketchForward.scale(normalComponent));
        
        return projectedPoint;
    }

    handleLineDrawing(point) {

        
        if (!this.currentSketch.isDrawing) {
            // Start line
            this.currentSketch.startPoint = point;
            this.currentSketch.isDrawing = true;

            
            // Create temporary line preview
            this.createLinePreview(point, point);
        } else {
            // End line

            this.finishLine(point);
            this.currentSketch.isDrawing = false;
        }
    }

    createLinePreview(start, end) {
        // Remove existing preview
        if (this.linePreview) {
            this.linePreview.dispose();
        }
        
        // Create new line preview using ribbon for thickness
        const distance = BABYLON.Vector3.Distance(start, end);
        if (distance > 0.01) { // Only create if line has meaningful length
            const direction = end.subtract(start).normalize();
            
            // Create a perpendicular vector for ribbon width
            const perpendicular = BABYLON.Vector3.Cross(direction, this.sketchForward).normalize();
            const halfWidth = 0.02; // Thin ribbon width for 2D appearance
            
            // Create ribbon path with slight width
            const path1 = [
                start.add(perpendicular.scale(halfWidth)),
                end.add(perpendicular.scale(halfWidth))
            ];
            const path2 = [
                start.subtract(perpendicular.scale(halfWidth)),
                end.subtract(perpendicular.scale(halfWidth))
            ];
            
            this.linePreview = BABYLON.MeshBuilder.CreateRibbon('linePreview', {
                pathArray: [path1, path2],
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Apply thick line material
            this.linePreview.material = this.thickLineMaterial.clone('previewMaterial');
            this.linePreview.material.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green preview
            this.linePreview.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
            this.linePreview.isPickable = false;
            this.linePreview.renderingGroupId = 2;
        }
    }

    finishLine(endPoint) {
        // Remove preview
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        
        // Create final line using ribbon for thickness
        const start = this.currentSketch.startPoint;
        const distance = BABYLON.Vector3.Distance(start, endPoint);
        
        if (distance > 0.01) { // Only create if line has meaningful length
            const direction = endPoint.subtract(start).normalize();
            
            // Create a perpendicular vector for ribbon width
            const perpendicular = BABYLON.Vector3.Cross(direction, this.sketchForward).normalize();
            const halfWidth = 0.02; // Thin ribbon width for 2D appearance
            
            // Create ribbon path with slight width
            const path1 = [
                start.add(perpendicular.scale(halfWidth)),
                endPoint.add(perpendicular.scale(halfWidth))
            ];
            const path2 = [
                start.subtract(perpendicular.scale(halfWidth)),
                endPoint.subtract(perpendicular.scale(halfWidth))
            ];
            
            const line = BABYLON.MeshBuilder.CreateRibbon('sketchLine', {
                pathArray: [path1, path2],
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Apply thick line material
            line.material = this.thickLineMaterial.clone('lineMaterial');
            line.isPickable = true;
            line.renderingGroupId = 2;
            
            // Add to sketch elements
            this.currentSketch.elements.push({
                type: 'line',
                start: this.currentSketch.startPoint,
                end: endPoint,
                mesh: line
            });
        }
        

    }
    
    createRectanglePreview(start, end) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        // Calculate rectangle corners
        const corners = this.getRectangleCorners(start, end);
        
        // Create thick line loop for rectangle preview
        const previewMaterial = this.thickLineMaterial.clone('rectPreviewMaterial');
        previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
        previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
        
        this.shapePreview = this.createThickLineLoop(corners, 'rectPreview', previewMaterial);
        
        if (this.shapePreview) {
            this.shapePreview.isPickable = false;
            this.shapePreview.renderingGroupId = 2;
        }
        

    }
    
    finishRectangle(endPoint) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        const corners = this.getRectangleCorners(this.currentSketch.startPoint, endPoint);
        
        // Create thick rectangle with filled face
        const rect = this.createFilledRectangle(corners, 'sketchRectangle', this.thickLineMaterial.clone('rectMaterial'));
        
        if (rect) {
            rect.isPickable = true;
            rect.renderingGroupId = 1;
            
            // Store as closed shape
            this.currentSketch.elements.push({
                type: 'rectangle',
                points: corners,
                mesh: rect,
                closed: true
            });
        }
    }
    
    createCirclePreview(center, radius) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (radius > 0.1) { // Only show circle preview if radius is meaningful
            const points = this.getCirclePoints(center, radius);
            
            // Create thick line loop for circle preview
            const previewMaterial = this.thickLineMaterial.clone('circlePreviewMaterial');
            previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
            previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
            
            this.shapePreview = this.createThickLineLoop(points, 'circlePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        } else {
            // Show center point indicator when radius is too small
            const centerIndicator = BABYLON.MeshBuilder.CreateSphere('circleCenterPreview', {
                diameter: 0.2
            }, this.scene);
            centerIndicator.position = center.clone();
            
            const centerMaterial = new BABYLON.StandardMaterial('centerMaterial', this.scene);
            centerMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green
            centerMaterial.emissiveColor = new BABYLON.Color3(0, 1, 0);
            centerMaterial.disableLighting = true;
            
            centerIndicator.material = centerMaterial;
            centerIndicator.isPickable = false;
            centerIndicator.renderingGroupId = 2;
            
            this.shapePreview = centerIndicator;
        }
    }
    
    finishCircle(radius) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        const points = this.getCirclePoints(this.currentSketch.startPoint, radius);
        
        // Create filled circle
        const circle = this.createFilledCircle(this.currentSketch.startPoint, radius, 'sketchCircle', this.thickLineMaterial.clone('circleMaterial'));
        
        if (circle) {
            circle.isPickable = true;
            circle.renderingGroupId = 1;
            
            this.currentSketch.elements.push({
                type: 'circle',
                center: this.currentSketch.startPoint,
                radius: radius,
                mesh: circle,
                closed: true
            });
        }
    }
    
    createEllipsePreview(center, radiusX, radiusY) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (radiusX > 0 || radiusY > 0) {
            const points = this.getEllipsePoints(center, radiusX, radiusY);
            
            // Create thick line loop for ellipse preview
            const previewMaterial = this.thickLineMaterial.clone('ellipsePreviewMaterial');
            previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
            previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
            
            this.shapePreview = this.createThickLineLoop(points, 'ellipsePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    finishEllipse(endPoint) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        const center = this.currentSketch.startPoint;
        
        // Calculate radii using surface coordinate system
        const endOffset = endPoint.subtract(center);
        const radiusX = Math.abs(BABYLON.Vector3.Dot(endOffset, this.sketchRight));
        const radiusY = Math.abs(BABYLON.Vector3.Dot(endOffset, this.sketchUp));
        
        const points = this.getEllipsePoints(center, radiusX, radiusY);
        
        // Create filled ellipse
        const ellipse = this.createFilledEllipse(center, radiusX, radiusY, 'sketchEllipse', this.thickLineMaterial.clone('ellipseMaterial'));
        
        if (ellipse) {
            ellipse.isPickable = true;
            ellipse.renderingGroupId = 1;
            
            this.currentSketch.elements.push({
                type: 'ellipse',
                center: center,
                radiusX: radiusX,
                radiusY: radiusY,
                mesh: ellipse,
                closed: true
            });
        }
    }
    
    
    createTrianglePreview(points) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (points.length >= 2) {
            const previewPoints = [...points];
            if (points.length === 2) {
                // Show two sides of triangle
                previewPoints.push(points[0]);
            } else if (points.length === 3) {
                // Complete triangle
                previewPoints.push(points[0]);
            }
            
            // Create thick line loop for triangle preview
            const previewMaterial = this.thickLineMaterial.clone('trianglePreviewMaterial');
            previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
            previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
            
            this.shapePreview = this.createThickLineLoop(previewPoints.slice(0, -1), 'trianglePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    finishTriangle() {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        // Create filled triangle using filled shape
        const triangle = this.createFilledShape(this.currentSketch.trianglePoints, 'sketchTriangle', this.thickLineMaterial.clone('triangleMaterial'));
        
        if (triangle) {
            triangle.isPickable = true;
            triangle.renderingGroupId = 1;
            
            this.currentSketch.elements.push({
                type: 'triangle',
                points: this.currentSketch.trianglePoints,
                mesh: triangle,
                closed: true
            });
        }
        
        this.currentSketch.trianglePoints = [];
    }
    
    // Helper methods for shape generation using surface coordinate system
    getRectangleCorners(start, end) {
        
        // Use Shape2D method for proper coordinate system handling
        if (this.shape2D) {
            const corners = this.shape2D.getRectangleCorners(start, end);
            if (!corners || corners.length !== 4) {
                // Fallback if Shape2D method fails
                return this.getFallbackRectangleCorners(start, end);
            }
            return corners;
        }
        
        return this.getFallbackRectangleCorners(start, end);
    }
    
    getFallbackRectangleCorners(start, end) {
        // Create proper rectangle corners using sketch coordinate system
        if (this.sketchRight && this.sketchUp) {
            // Calculate dimensions in the sketch coordinate system
            const startToEnd = end.subtract(start);
            const rightComponent = BABYLON.Vector3.Dot(startToEnd, this.sketchRight);
            const upComponent = BABYLON.Vector3.Dot(startToEnd, this.sketchUp);
            
            // Calculate the actual corners based on the min/max of the two points
            const minRight = Math.min(0, rightComponent);
            const maxRight = Math.max(0, rightComponent);
            const minUp = Math.min(0, upComponent);
            const maxUp = Math.max(0, upComponent);
            
            // Create proper rectangle corners using the sketch coordinate system
            const corners = [
                start.add(this.sketchRight.scale(minRight)).add(this.sketchUp.scale(minUp)),     // Bottom-left
                start.add(this.sketchRight.scale(maxRight)).add(this.sketchUp.scale(minUp)),     // Bottom-right
                start.add(this.sketchRight.scale(maxRight)).add(this.sketchUp.scale(maxUp)),     // Top-right
                start.add(this.sketchRight.scale(minRight)).add(this.sketchUp.scale(maxUp))      // Top-left
            ];
            
            return corners;
        } else {
            // Final fallback to XZ plane
            const corners = [
                start.clone(),                                // Corner 1 (start)
                new BABYLON.Vector3(end.x, start.y, start.z), // Corner 2 (end.x, start.y)
                end.clone(),                                  // Corner 3 (end)
                new BABYLON.Vector3(start.x, start.y, end.z)  // Corner 4 (start.x, end.z) - FIXED!
            ];
            
            return corners;
        }
    }
    
    getCirclePoints(center, radius, segments = 32) {
        const points = [];
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            
            // Generate circle points in the surface coordinate system
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            
            // Convert to world coordinates using surface vectors
            const worldPoint = center
                .add(this.sketchRight.scale(x))
                .add(this.sketchUp.scale(y));
            
            points.push(worldPoint);
        }
        
        return points;
    }
    
    getEllipsePoints(center, radiusX, radiusY, segments = 32) {
        const points = [];
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            
            // Generate ellipse points in the surface coordinate system
            const x = radiusX * Math.cos(angle);
            const y = radiusY * Math.sin(angle);
            
            // Convert to world coordinates using surface vectors
            const worldPoint = center
                .add(this.sketchRight.scale(x))
                .add(this.sketchUp.scale(y));
            
            points.push(worldPoint);
        }
        
        return points;
    }
    
    updateSketchPreview(event) {
        const pickInfo = this.scene.pick(event.clientX, event.clientY, (mesh) => mesh.name === 'sketchGround');
        
        if (pickInfo.hit) {
            const point = pickInfo.pickedPoint; // Use direct coordinates - no double transformation
            
            switch (this.currentSketch.currentTool) {
                case 'line':
                    if (this.linePreview) {
                        this.linePreview.dispose();
                        this.createLinePreview(this.currentSketch.startPoint, point);
                    }
                    break;
                    
                case 'rectangle':
                    if (this.currentSketch.startPoint) {
                        this.createRectanglePreview(this.currentSketch.startPoint, point);
                    }
                    break;
                    
                case 'circle':
                    if (this.currentSketch.startPoint) {
                        const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, point);
                        this.createCirclePreview(this.currentSketch.startPoint, radius);
                    }
                    break;
                    
                case 'ellipse':
                    if (this.currentSketch.startPoint) {
                        const offset = point.subtract(this.currentSketch.startPoint);
                        const radiusX = Math.abs(BABYLON.Vector3.Dot(offset, this.sketchRight));
                        const radiusY = Math.abs(BABYLON.Vector3.Dot(offset, this.sketchUp));
                        this.createEllipsePreview(this.currentSketch.startPoint, radiusX, radiusY);
                    }
                    break;
            }
        }
    }
    
    cancelCurrentDrawing() {
        // Clean up any preview shapes
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        // Reset drawing state
        this.currentSketch.isDrawing = false;
        this.currentSketch.startPoint = null;
        this.currentSketch.trianglePoints = [];
    }
    
    processSketchGeometry() {
        // Analyze sketch elements and remove non-closed geometry
        const closedElements = [];
        const elementsToRemove = [];
        
        for (const element of this.currentSketch.elements) {
            if (element.closed) {
                // Keep closed shapes (rectangles, circles, triangles)
                closedElements.push(element);
            } else if (element.type === 'line') {
                // Check if this line is part of a closed shape
                if (!this.isLinePartOfClosedShape(element)) {
                    elementsToRemove.push(element);
                }
            }
        }
        
        // Remove non-closed geometry
        for (const element of elementsToRemove) {
            if (element.mesh) {
                element.mesh.dispose();
            }
            const index = this.currentSketch.elements.indexOf(element);
            if (index > -1) {
                this.currentSketch.elements.splice(index, 1);
            }
        }
        

        
        // Store the closed shapes for potential extrusion
        this.closedShapes = closedElements;
    }
    
    isLinePartOfClosedShape(line) {
        // This is a simplified check - in a full implementation,
        // you would check if the line connects with other lines to form a closed shape
        // For now, we'll just remove all standalone lines
        return false;
    }

    handleRectangleDrawing(point) {


        
        if (!this.currentSketch.isDrawing) {
            // Start rectangle

            this.currentSketch.startPoint = point.clone();
            this.currentSketch.isDrawing = true;
            this.createRectanglePreview(point, point);
        } else {
            // End rectangle

            this.finishRectangle(point);
            this.currentSketch.isDrawing = false;
        }
    }

    handleCircleDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start circle (center point)
            this.currentSketch.startPoint = point;
            this.currentSketch.isDrawing = true;
            this.createCirclePreview(point, 0);
        } else {
            // End circle (radius point)
            const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, point);
            
            // Only create circle if radius is meaningful (prevent accidental tiny circles)
            if (radius > 0.1) {
                this.finishCircle(radius);
                this.currentSketch.isDrawing = false;
            }
            // If radius is too small, stay in drawing mode - user needs to move mouse further
        }
    }
    
    handleEllipseDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start ellipse (center point)
            this.currentSketch.startPoint = point;
            this.currentSketch.isDrawing = true;
            this.createEllipsePreview(point, 0, 0);
        } else {
            // End ellipse
            this.finishEllipse(point);
            this.currentSketch.isDrawing = false;
        }
    }
    
    
    handleTriangleDrawing(point) {
        if (!this.currentSketch.trianglePoints) {
            this.currentSketch.trianglePoints = [];
        }
        
        this.currentSketch.trianglePoints.push(point);
        
        if (this.currentSketch.trianglePoints.length === 1) {
            this.currentSketch.isDrawing = true;
            this.createTrianglePreview([point]);
        } else if (this.currentSketch.trianglePoints.length === 2) {
            this.createTrianglePreview(this.currentSketch.trianglePoints);
        } else if (this.currentSketch.trianglePoints.length === 3) {
            // Complete triangle
            this.finishTriangle();
            this.currentSketch.isDrawing = false;
            this.currentSketch.trianglePoints = [];
        }
    }

    exitSketchMode() {
        // Check for closed geometry before exiting
        if (this.currentSketch && this.currentSketch.elements) {
            this.processSketchGeometry();
            // Preserve shapes for next sketch session
            this.closedShapes = this.currentSketch.elements;
        }
        
        this.isSketchMode = false;
        this.currentSketchPlane = null;
        this.currentSketch = null;
        
        // Return to modeling mode - this will restore the Sketch tool button
        this.setMode('model');
        
        // Reset sketch tool selection state
        this.sketchToolSelected = false;
        this.waitingForSurface = false;
        
        // Hide any sketch targets that might still be visible
        this.hideSketchTargets();
        
        // Remove sketch mouse handlers
        if (this.sketchMouseDownHandler) {
            this.canvas.removeEventListener('mousedown', this.sketchMouseDownHandler, true);
            this.sketchMouseDownHandler = null;
        }
        
        if (this.sketchMouseUpHandler) {
            this.canvas.removeEventListener('mouseup', this.sketchMouseUpHandler, true);
            this.sketchMouseUpHandler = null;
        }
        
        if (this.sketchMoveHandler) {
            this.canvas.removeEventListener('mousemove', this.sketchMoveHandler, true);
            this.sketchMoveHandler = null;
        }
        
        // Remove escape key handler
        if (this.sketchEscapeHandler) {
            document.removeEventListener('keydown', this.sketchEscapeHandler);
            this.sketchEscapeHandler = null;
        }
        
        // Remove unified sketch handlers
        if (this.sketchMouseDownHandler) {
            this.canvas.removeEventListener('mousedown', this.sketchMouseDownHandler, true);
            this.canvas.removeEventListener('mouseup', this.sketchMouseUpHandler, true);
            this.canvas.removeEventListener('mousemove', this.sketchMoveHandler, true);
            this.canvas.removeEventListener('wheel', this.sketchWheelHandler, true);
            
            this.sketchMouseDownHandler = null;
            this.sketchMouseUpHandler = null;
            this.sketchMoveHandler = null;
            this.sketchWheelHandler = null;
        }
        
        // Restore perspective projection
        this.camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
        
        // Re-attach normal camera controls
        // this.camera.attachControl(this.canvas, true); // Commented out to prevent conflicts with custom camera controls
        
        // Remove sketch grid and restore main grid
        if (this.sketchGrid) {
            this.sketchGrid.dispose();
            this.sketchGrid = null;
        }
        
        // Remove sketch grid lines
        if (this.sketchGridLines) {
            this.sketchGridLines.forEach(line => line.dispose());
            this.sketchGridLines = null;
        }
        
        // Re-enable the main grid
        if (this.grid.isVisible) {
            if (this.gridSystem.gridGround) {
                // Dispose and recreate grid to ensure visibility
                this.gridSystem.recreate();
            } else {
                this.gridSystem.updateDynamicGrid();
            }
        }
        
        // Make all hidden meshes visible and pickable again
        this.scene.meshes.forEach(mesh => {
            if (mesh.name.includes('Plane')) {
                mesh.isVisible = true;
                mesh.isPickable = true; // Re-enable picking for target planes
            }
            // Also make sketch shapes visible and pickable
            if (mesh.name.includes('sketch') || mesh.name.includes('Rectangle') || mesh.name.includes('Circle')) {
                mesh.isVisible = true;
                mesh.isPickable = true;
            }
            // Restore original alpha for dimmed background objects
            if (mesh.originalAlpha !== undefined && mesh.material) {
                mesh.material.alpha = mesh.originalAlpha;
                mesh.originalAlpha = undefined; // Clean up
                mesh.isPickable = true; // Re-enable picking
            }
        });
        
        // Grid updates are managed by GridSystem internally
        
        // Restore original toolbar
        this.restoreMainToolbar();
        
        // Update properties panel to show kept shapes
        if (this.closedShapes && this.closedShapes.length > 0) {
            document.getElementById('selection-info').textContent = 
                `${this.closedShapes.length} shape(s) ready - Click to select and extrude`;
        } else {
            document.getElementById('selection-info').textContent = 
                'No shapes available - Enter sketch mode to draw';
        }
        

    }

    restoreMainToolbar() {
        const toolbar = document.querySelector('.toolbar');
        toolbar.innerHTML = `
            <button id="sketch-btn" class="tool-btn active">Sketch</button>
            <button id="model-btn" class="tool-btn">Model</button>
        `;
        
        // Re-add event listeners
        // Mode switching removed - sketch is now a tool, not a mode
    }

    setupEventListeners() {
        // Mode switching removed - sketch is now a tool, not a mode
        
        // Grid toggle
        document.getElementById('grid-toggle').addEventListener('click', () => {
            this.toggleGrid();
        });
        
        // Reset view
        document.getElementById('reset-view').addEventListener('click', () => {
            this.resetView();
        });
        
        // Back to dashboard
        document.getElementById('back-btn').addEventListener('click', () => {
            window.location.href = 'index.php';
        });
        
        // Bench switching
        document.getElementById('work-bench-btn').addEventListener('click', () => {
            this.switchBench('work');
        });
        
        document.getElementById('assembly-bench-btn').addEventListener('click', () => {
            this.switchBench('assembly');
        });
        
        // Include in project button (removed from UI - now handled via context menu)
        
        // Mouse position tracking
        this.canvas.addEventListener('mousemove', (event) => {
            this.updateCoordinates(event);
        });
        
        // Tool selection
        document.querySelectorAll('[data-tool]').forEach(button => {
            button.addEventListener('click', () => {
                // Update active tool button
                document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Set the current tool
                const tool = button.dataset.tool;
                this.selectSketchTool(tool);
            });
        });

        // Project Explorer part selection
        const projectPartsList = document.getElementById('project-parts-list');
        if (projectPartsList) {
            projectPartsList.addEventListener('click', (event) => {
                const listItem = event.target.closest('li');
                if (listItem) {
                    // Find the part based on the list item content
                    const partName = listItem.textContent.trim();
                    let selectedPart = null;
                    
                    // Search in project parts
                    selectedPart = this.projectParts.find(part => 
                        (part.name && part.name === partName) || 
                        (part.title && part.title === partName)
                    );
                    
                    // If not found in project parts, search in work bench parts
                    if (!selectedPart) {
                        selectedPart = this.workBenchParts.find(part => 
                            (part.name && part.name === partName) || 
                            (part.title && part.title === partName)
                        );
                    }
                    
                    if (selectedPart) {
                        this.selectPart(selectedPart);
                    }
                }
            });
        }

        // Escape key handler for deselecting parts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                // Deselect parts and faces
                if (this.selectedPart) {
                    this.deselectPart();
                }
                if (this.selectedFace) {
                    this.deselectFace();
                }
            } else if (event.key === 'r' || event.key === 'R') {
                // Router bit library is now in properties panel - show message
                if (this.activeTool === 'router' && this.routerBitSystem) {
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        if (this.routerBitSystem.selectedEdges.length > 0) {
                            selectionInfo.innerHTML = '<strong>Router Tool:</strong><br>Router bit library is now available in the Properties panel →';
                        } else {
                            selectionInfo.innerHTML = '<strong>Router Tool:</strong><br>Select edges first - router bits will appear in Properties panel';
                        }
                    }
                }
            }
        });

        // Material Modal Event Handlers
        this.setupMaterialModalListeners();
    }

    async openMaterialModal() {
        const modal = document.getElementById('material-modal');
        if (!modal) return;

        // Load materials database if not loaded
        if (!this.materialsLibrary.isLoaded) {
            const loaded = await this.materialsLibrary.loadDatabase();
            if (!loaded) {
                console.error('Failed to load materials database');
                return;
            }
        }

        // Show modal
        modal.style.display = 'flex';
        
        // Reset modal state
        this.showMaterialGrid();
        
        // Populate materials and categories
        this.populateMaterialCategories();
        this.populateMaterialGrid();
        
        // Clear search
        const searchInput = document.getElementById('material-search');
        if (searchInput) {
            searchInput.value = '';
        }
    }

    closeMaterialModal() {
        const modal = document.getElementById('material-modal');
        if (modal) {
            modal.style.display = 'none';
        }
        
        // Reset state
        this.selectedMaterialId = null;
        this.selectedMaterial = null;
        this.showMaterialGrid();
    }

    populateMaterialCategories() {
        const tabsContainer = document.getElementById('material-category-tabs');
        if (!tabsContainer || !this.materialsLibrary.categories) return;

        tabsContainer.innerHTML = '';
        
        // Add "All" tab
        const allTab = document.createElement('div');
        allTab.className = 'category-tab active';
        allTab.dataset.category = 'all';
        allTab.textContent = 'All';
        tabsContainer.appendChild(allTab);

        // Add category tabs
        Object.entries(this.materialsLibrary.categories).forEach(([categoryId, category]) => {
            const tab = document.createElement('div');
            tab.className = 'category-tab';
            tab.dataset.category = categoryId;
            tab.textContent = category.name;
            tabsContainer.appendChild(tab);
        });
    }

    populateMaterialGrid(filteredMaterials = null) {
        const grid = document.getElementById('material-grid');
        if (!grid || !this.materialsLibrary.materials) return;

        let materials;
        if (filteredMaterials && typeof filteredMaterials === 'string') {
            // Filter by category
            materials = {};
            Object.entries(this.materialsLibrary.materials).forEach(([materialId, material]) => {
                if (material.category === filteredMaterials) {
                    materials[materialId] = material;
                }
            });
        } else {
            materials = filteredMaterials || this.materialsLibrary.materials;
        }
        grid.innerHTML = '';

        Object.entries(materials).forEach(([materialId, material]) => {
            const card = document.createElement('div');
            card.className = 'material-card';
            card.dataset.materialId = materialId;
            
            // Get proper thumbnail and material info
            const thumbnail = material.visual_assets?.thumbnail || 'placeholder-material.jpg';
            const materialName = material.name || 'Unknown Material';
            const scientificName = material.basic_info?.scientific_name || material.species || '';
            const pricePerBF = material.cost_structure?.base_price_bf || 'N/A';
            
            console.log("🔍 Material ID:", materialId, "- Name:", materialName);
            console.log("🔍 Full material object:", material);
            // Debug logging for thumbnails
            if (material.visual_assets?.thumbnail) {
                console.log(`Material ${materialName} has thumbnail:`, material.visual_assets.thumbnail.substring(0, 50) + '...');
            } else {
                console.log(`Material ${materialName} has no thumbnail, using placeholder`);
            }
            
            card.innerHTML = `
                <div class="material-image">
                    <img src="${thumbnail}" alt="${materialName}" loading="lazy" onerror="this.style.display='none'; console.error('Failed to load material image:', this.src)">
                </div>
                <div class="material-info">
                    <h4>${materialName}</h4>
                    <p class="material-species">${scientificName}</p>
                    <p class="material-price">Starting at $${pricePerBF}/bf</p>
                </div>
            `;
            
            grid.appendChild(card);
        });
    }

    filterMaterials(searchTerm) {
        if (!this.materialsLibrary.materials) return;

        const filtered = {};
        const term = searchTerm.toLowerCase();

        Object.entries(this.materialsLibrary.materials).forEach(([id, material]) => {
            if (material.name.toLowerCase().includes(term) ||
                (material.species && material.species.toLowerCase().includes(term)) ||
                (material.description && material.description.toLowerCase().includes(term))) {
                filtered[id] = material;
            }
        });

        this.populateMaterialGrid(filtered);
    }

    filterByCategory(categoryId) {
        // Update active tab
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelector(`[data-category="${categoryId}"]`).classList.add('active');

        if (categoryId === 'all') {
            this.populateMaterialGrid();
            return;
        }

        if (!this.materialsLibrary.materials) return;

        const filtered = {};
        Object.entries(this.materialsLibrary.materials).forEach(([id, material]) => {
            if (material.category === categoryId) {
                filtered[id] = material;
            }
        });

        this.populateMaterialGrid(filtered);
    }

    selectMaterial(materialId) {
        this.selectedMaterialId = materialId;
        const material = this.materialsLibrary.materials[materialId];
        
        if (!material) return;

        // Show configuration panel
        this.showMaterialConfig(material);
    }

    showMaterialConfig(material) {
        const grid = document.getElementById('material-grid');
        const config = document.getElementById('material-config');
        const materialName = document.getElementById('selected-material-name');

        if (grid) grid.style.display = 'none';
        if (config) config.style.display = 'block';
        if (materialName) materialName.textContent = `${material.name} Configuration`;

        // Populate configuration options
        this.populateConfigOptions(material.id);
        this.updateMaterialCost();
    }

    showMaterialGrid() {
        const grid = document.getElementById('material-grid');
        const config = document.getElementById('material-config');

        if (grid) grid.style.display = 'grid';
        if (config) config.style.display = 'none';
    }

    updateMaterialCost() {
        if (!this.selectedMaterialId) return;

        const material = this.materialsLibrary.materials[this.selectedMaterialId];
        const length = parseFloat(document.getElementById('config-length')?.value || 0);
        const width = parseFloat(document.getElementById('config-width')?.value || 0);
        const thickness = parseFloat(document.getElementById('config-thickness')?.value || 0);
        const grade = document.getElementById('config-grade')?.value || '';

        if (length && width && thickness) {
            // Calculate board feet: (length × width × thickness) / 144
            const boardFeet = (length * width * thickness) / 144;
            const basePriceBF = material.base_price_per_bf || 0;
            
            // Apply grade multiplier if available
            let gradeMultiplier = 1;
            if (material.grade_multipliers && material.grade_multipliers[grade]) {
                gradeMultiplier = material.grade_multipliers[grade];
            }
            
            const totalCost = boardFeet * basePriceBF * gradeMultiplier;

            // Display cost information
            const costDisplay = document.getElementById('cost-display');
            if (costDisplay) {
                costDisplay.innerHTML = `
                    <div class="cost-breakdown">
                        <p><strong>Dimensions:</strong> ${length}" × ${width}" × ${thickness}"</p>
                        <p><strong>Board Feet:</strong> ${boardFeet.toFixed(2)} bf</p>
                        <p><strong>Grade:</strong> ${grade}</p>
                        <p><strong>Price per BF:</strong> $${(basePriceBF * gradeMultiplier).toFixed(2)}</p>
                        <p class="total-cost"><strong>Total Cost: $${totalCost.toFixed(2)}</strong></p>
                    </div>
                `;
            }
        }
    }

    addMaterialToProject() {
        if (!this.selectedMaterialId) return;

        const material = this.materialsLibrary.materials[this.selectedMaterialId];
        const length = document.getElementById('config-length')?.value;
        const width = document.getElementById('config-width')?.value;
        const thickness = document.getElementById('config-thickness')?.value;
        const grade = document.getElementById('config-grade')?.value;

        if (!length || !width || !thickness || !grade) {
            alert('Please select all configuration options');
            return;
        }

        // Create material entry for project
        const materialEntry = {
            id: Date.now(), // Simple ID generation
            materialId: this.selectedMaterialId,
            name: material.name,
            species: material.species,
            length: parseFloat(length),
            width: parseFloat(width),
            thickness: parseFloat(thickness),
            grade: grade,
            boardFeet: (parseFloat(length) * parseFloat(width) * parseFloat(thickness)) / 144,
            cost: this.calculateMaterialCost(material, length, width, thickness, grade),
            dateAdded: new Date().toISOString()
        };

        // Add to project parts list (you may need to implement this method)
        this.addToProjectPartsList(materialEntry);

        // Show success message
        alert(`${material.name} added to project successfully!`);

        // Close modal
        this.closeMaterialModal();
    }

    calculateMaterialCost(material, length, width, thickness, grade) {
        const boardFeet = (parseFloat(length) * parseFloat(width) * parseFloat(thickness)) / 144;
        const basePriceBF = material.base_price_per_bf || 0;
        
        let gradeMultiplier = 1;
        if (material.grade_multipliers && material.grade_multipliers[grade]) {
            gradeMultiplier = material.grade_multipliers[grade];
        }
        
        return boardFeet * basePriceBF * gradeMultiplier;
    }

    addToProjectPartsList(materialEntry) {
        // Initialize project parts list if it doesn't exist
        if (!this.projectPartsList) {
            this.projectPartsList = [];
        }

        // Add material to parts list
        this.projectPartsList.push(materialEntry);

        // Update parts list display
        this.updatePartsListDisplay();

        console.log('Material added to project:', materialEntry);
    }

    updatePartsListDisplay() {
        const partsList = document.getElementById('parts-list');
        if (!partsList || !this.projectPartsList) return;

        partsList.innerHTML = '';

        this.projectPartsList.forEach(part => {
            const listItem = document.createElement('li');
            listItem.className = 'parts-list-item';
            listItem.innerHTML = `
                <div class="part-info">
                    <strong>${part.name}</strong>
                    <span class="part-dimensions">${part.length}" × ${part.width}" × ${part.thickness}"</span>
                    <span class="part-cost">$${part.cost.toFixed(2)}</span>
                </div>
            `;
            partsList.appendChild(listItem);
        });
    }

    setMode(mode) {
        this.currentMode = mode;
        
        // Update UI
        const modeIndicator = document.getElementById('mode-indicator');
        if (modeIndicator) {
            modeIndicator.textContent = mode === 'sketch' ? 'Sketch Mode' : '3D Modeling';
        }
        
        // Update context-sensitive tool groups
        this.updateToolGroups();

    }
    
    updateToolGroups() {
        // Debug logging
        console.log('updateToolGroups called - currentMode:', this.currentMode, 'selectedFace:', this.selectedFace?.name, 'isSketchMode:', this.isSketchMode);
        
        // FORCE OVERRIDE - if mode is sketch but we're not in sketch mode, fix it
        if (this.currentMode === 'sketch' && !this.isSketchMode) {
            this.currentMode = 'model';
            console.log('Mode corrected to model');
        }
        
        
        // Hide all tool groups first
        const allGroups = [
            'sketch-tools',
            'model-tools-main', 
            'model-tools-face',
            'model-tools-object'
        ];
        
        allGroups.forEach(groupId => {
            const group = document.getElementById(groupId);
            if (group) {
                group.style.display = 'none';
            }
        });
        
        // Show appropriate group based on mode and selection state
        if (this.currentMode === 'sketch') {
            // In sketch mode, always show drawing tools
            const sketchTools = document.getElementById('sketch-tools');
            if (sketchTools) {
                sketchTools.style.display = 'block';
            }
        } else {
            // In model mode, always show main tools
            const mainTools = document.getElementById('model-tools-main');
            if (mainTools) {
                mainTools.style.display = 'block';
            }
            
            // Additionally show context tools based on selection
            if (this.selectedFace) {
                // Face selected - show selection info
                console.log('Showing face info for selected face:', this.selectedFace.name);
                const faceTools = document.getElementById('model-tools-face');
                if (faceTools) {
                    faceTools.style.display = 'block';
                    // Update the info text
                    const faceInfo = document.getElementById('face-selection-info');
                    if (faceInfo) {
                        faceInfo.textContent = `${this.selectedFace.name} selected - Use active tool`;
                    }
                }
            } else if (this.selectedObject) {
                // 3D object selected - show transform tools
                const objectTools = document.getElementById('model-tools-object');
                if (objectTools) {
                    objectTools.style.display = 'block';
                }
            }
        }
    }

    resetView() {
        this.camera.setTarget(BABYLON.Vector3.Zero());
        this.camera.alpha = -Math.PI / 2;
        this.camera.beta = Math.PI / 2.5;
        this.camera.radius = Math.max(200, this.camera.radius); // Ensure minimum radius
        console.log('resetView: Set camera radius to', this.camera.radius);
    }

    switchBench(benchType) {
        // Update current bench property
        this.currentBench = benchType;
        
        // Update bench button states
        document.querySelectorAll('.bench-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        if (benchType === 'work') {
            document.getElementById('work-bench-btn').classList.add('active');
            // Show work bench tools, hide assembly bench tools
            document.getElementById('work-bench-tools').style.display = 'block';
            document.getElementById('assembly-bench-tools').style.display = 'none';
        } else if (benchType === 'assembly') {
            document.getElementById('assembly-bench-btn').classList.add('active');
            // Show assembly bench tools, hide work bench tools
            document.getElementById('work-bench-tools').style.display = 'none';
            document.getElementById('assembly-bench-tools').style.display = 'block';
        }
        
        // Clear any active tool selections when switching benches
        document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
        this.activeTool = null;
        
        // DRAMATIC BENCH REVEAL: Animate camera to showcase the bench contents
        this.animateCameraToShowcaseBench(benchType);
        
        console.log(`Switched to ${benchType} bench`);
    }

    /**
     * DRAMATIC BENCH REVEAL: Professional camera animation to showcase bench contents
     * Automatically frames all parts optimally with cinematic camera movement
     */
    animateCameraToShowcaseBench(benchType) {
        console.log(`Starting dramatic bench reveal animation for ${benchType} bench`);
        
        // Get all parts on the current bench
        const parts = benchType === 'work' ? 
            this.scene.meshes.filter(m => m.isWorkBenchPart) : 
            this.scene.meshes.filter(m => m.isProjectPart);
        
        if (parts.length === 0) {
            console.log(`No parts to showcase on ${benchType} bench`);
            // Still animate to origin for clean empty bench view
            this.animateCameraToPosition(new BABYLON.Vector3(0, 50, 100), BABYLON.Vector3.Zero());
            return;
        }
        
        // Calculate bounding box of all parts
        const partPositions = parts.map(part => part.position);
        const bounds = this.calculateSceneBounds(partPositions, parts);
        
        // Calculate optimal camera position for dramatic showcase
        const centerPoint = bounds.center;
        const sceneSize = bounds.size;
        const maxDimension = Math.max(sceneSize.x, sceneSize.y, sceneSize.z);
        
        // Professional camera positioning for multiple parts
        const cameraDistance = maxDimension * 2.2; // Extra distance for multiple parts
        const cameraHeight = maxDimension * 0.6;   // Elevated perspective
        
        // Create cinematic camera angle
        const targetCameraPosition = new BABYLON.Vector3(
            centerPoint.x + cameraDistance * 0.8,
            centerPoint.y + cameraHeight,
            centerPoint.z + cameraDistance * 0.6
        );
        
        // Animate to showcase position
        this.animateCameraToPosition(targetCameraPosition, centerPoint);
        
        console.log(`Showcasing ${parts.length} parts on ${benchType} bench`);
    }
    
    /**
     * Calculate bounding box for multiple parts
     */
    calculateSceneBounds(positions, parts) {
        if (positions.length === 0) {
            return { center: BABYLON.Vector3.Zero(), size: new BABYLON.Vector3(10, 10, 10) };
        }
        
        // Find min/max across all parts
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        
        parts.forEach(part => {
            const bounds = part.getBoundingInfo();
            const worldMin = part.position.add(bounds.minimum);
            const worldMax = part.position.add(bounds.maximum);
            
            minX = Math.min(minX, worldMin.x);
            maxX = Math.max(maxX, worldMax.x);
            minY = Math.min(minY, worldMin.y);
            maxY = Math.max(maxY, worldMax.y);
            minZ = Math.min(minZ, worldMin.z);
            maxZ = Math.max(maxZ, worldMax.z);
        });
        
        const center = new BABYLON.Vector3(
            (minX + maxX) / 2,
            (minY + maxY) / 2,
            (minZ + maxZ) / 2
        );
        
        const size = new BABYLON.Vector3(
            maxX - minX,
            maxY - minY,
            maxZ - minZ
        );
        
        return { center, size };
    }
    
    /**
     * Smooth camera animation to specific position and target
     */
    animateCameraToPosition(targetPosition, targetLookAt) {
        // Store current camera state
        const startPosition = this.camera.position.clone();
        const startTarget = this.camera.getTarget().clone();
        
        // Crisp 2-second cutscene animation
        const animationDuration = 2000; // 2 seconds in milliseconds
        const startTime = Date.now();
        
        // Professional ease-in-out cubic (slow-fast-slow)
        const easeInOutCubic = (t) => {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        };
        
        // Immediate camera position set to prevent flash
        this.camera.position = startPosition;
        this.camera.setTarget(startTarget);
        
        // Smooth camera animation
        const animateCamera = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            const easedProgress = easeInOutCubic(progress);
            
            // Interpolate camera position
            this.camera.position = BABYLON.Vector3.Lerp(startPosition, targetPosition, easedProgress);
            
            // Smooth target transition - always end centered
            const currentTarget = BABYLON.Vector3.Lerp(startTarget, targetLookAt, easedProgress);
            this.camera.setTarget(currentTarget);
            
            // Continue animation
            if (progress < 1) {
                requestAnimationFrame(animateCamera);
            } else {
                console.log(`Camera cutscene complete`);
            }
        };
        
        // Start the animation
        requestAnimationFrame(animateCamera);
    }

    updateCoordinates(event) {
        // Get canvas-relative coordinates
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Get 3D coordinates from mouse position
        const pickInfo = this.scene.pick(x, y);
        if (pickInfo.hit) {
            const pos = pickInfo.pickedPoint;
            document.getElementById('coordinates').textContent = 
                `X: ${pos.x.toFixed(2)}, Y: ${pos.y.toFixed(2)}, Z: ${pos.z.toFixed(2)}`;
        }
    }
    
    updateSketchPreviewWithPoint(point) {
        // Use the point directly since it's already on the sketch plane
        const sketchPoint = point.clone();
        



        
        // Update preview based on current tool
        switch (this.currentSketch.currentTool) {
            case 'line':
                if (this.linePreview) {
                    this.createLinePreview(this.currentSketch.startPoint, sketchPoint);
                }
                break;
            case 'rectangle':

                this.createRectanglePreview(this.currentSketch.startPoint, sketchPoint);
                break;
            case 'circle':
                const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, sketchPoint);
                this.createCirclePreview(this.currentSketch.startPoint, radius);
                break;
            case 'ellipse':
                const ellipseOffset = sketchPoint.subtract(this.currentSketch.startPoint);
                this.createEllipsePreview(
                    this.currentSketch.startPoint,
                    Math.abs(BABYLON.Vector3.Dot(ellipseOffset, this.sketchRight)),
                    Math.abs(BABYLON.Vector3.Dot(ellipseOffset, this.sketchUp))
                );
                break;
            case 'triangle':
                if (this.currentSketch.trianglePoints && this.currentSketch.trianglePoints.length > 0) {
                    this.createTrianglePreview([...this.currentSketch.trianglePoints, sketchPoint]);
                }
                break;
        }
    }
    
    updateSketchPreview(event) {
        // Legacy function - redirect to new implementation
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
        if (pickInfo.hit) {
            this.updateSketchPreviewWithPoint(pickInfo.pickedPoint);
        }
    }
    
    cancelCurrentDrawing() {
        // Clean up any preview shapes
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        // Reset drawing state
        this.currentSketch.isDrawing = false;
        this.currentSketch.startPoint = null;
        this.currentSketch.trianglePoints = [];
        

    }
    
    // ==================== SELECTION AND EXTRUSION SYSTEM ====================
    
    setupSelectionSystem() {
        // Initialize selection state
        this.selectedFace = null;
        this.hoveredFace = null;
        this.selectionOutlineMaterial = null;
        this.hoverOutlineMaterial = null;
        this.isExtruding = false;
        
        // Create outline materials
        this.createOutlineMaterials();
        
        // Setup selection event handlers
        this.setupSelectionEventHandlers();
        

    }
    
    createOutlineMaterials() {
        // Create hover material (pale green face)
        this.hoverOutlineMaterial = new BABYLON.StandardMaterial('hoverOutline', this.scene);
        this.hoverOutlineMaterial.diffuseColor = new BABYLON.Color3(0.8, 1.0, 0.8); // Pale green
        this.hoverOutlineMaterial.emissiveColor = new BABYLON.Color3(0.8, 1.0, 0.8);
        this.hoverOutlineMaterial.wireframe = false; // Solid face
        this.hoverOutlineMaterial.alpha = 0.7;
        this.hoverOutlineMaterial.backFaceCulling = false;
        
        // Create selection outline material (orange)
        this.selectionOutlineMaterial = new BABYLON.StandardMaterial('selectionOutline', this.scene);
        this.selectionOutlineMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0); // Orange
        this.selectionOutlineMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.15, 0);
        this.selectionOutlineMaterial.wireframe = true;
        this.selectionOutlineMaterial.alpha = 1.0;
    }
    
    setupSelectionEventHandlers() {
        // Mouse move for hover detection
        this.scene.onPointerObservable.add((pointerInfo) => {
            // Handle surface selection for sketch tool (highest priority)
            if (this.waitingForSurface && pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) {
                this.handleSurfaceSelection(pointerInfo);
                return;
            }
            
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) {
                if (this.isSketchMode || this.isExtruding) {
                    return;
                }
                this.handleFaceSelection(pointerInfo);
            } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 2) {
                // Right-click for context menu
                if (this.isSketchMode || this.isExtruding) {
                    return;
                }
                this.handleRightClickContextMenu(pointerInfo);
            } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
                if (!this.isSketchMode && !this.isExtruding) {
                    this.handleFaceHover(pointerInfo);
                }
            }
        });
    }
    
    handleSurfaceSelection(pointerInfo) {
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => {
                // Accept any pickable mesh that could be a surface (completely generic approach)
                const isSketchable = this.isMeshSketchable(mesh);
                return isSketchable;
            }
        );
        
        
        if (pickInfo.hit && pickInfo.pickedMesh) {
            this.enterSketchModeOnSurface(pickInfo.pickedMesh, pickInfo.pickedPoint, pickInfo.getNormal());
        } else {
        }
    }
    
    handleFaceHover(pointerInfo) {
        // Check if cut tool is active - skip hover effects
        if (this.cutToolSystem && this.cutToolSystem.cutPreviewActive) {
            return;
        }
        
        // Allow hover handling even when something is selected
        // This lets users see other selectable shapes
        
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => this.isSelectableFace(mesh)
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh) {
            const face = pickInfo.pickedMesh;
            
            // If hovering over a new face
            if (this.hoveredFace !== face) {
                // Clear previous hover
                this.clearHover();
                
                // Set new hover
                this.hoveredFace = face;
                this.setFaceHover(face, true);
            }
        } else {
            // Clear hover if not over any face
            this.clearHover();
        }
    }
    
    handleFaceSelection(pointerInfo) {
        // Check if cut tool is active - delegate to cut system
        if (this.cutToolSystem && this.cutToolSystem.cutPreviewActive) {
            // Let the cut tool system handle this interaction
            return;
        }
        
        // First check what we're hitting without filter
        const anyPick = this.scene.pick(this.scene.pointerX, this.scene.pointerY);
        
        // Check for parts with partData first (higher priority)
        const partPickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => mesh && mesh.partData
        );
        
        if (partPickInfo.hit && partPickInfo.pickedMesh && partPickInfo.pickedMesh.partData) {
            const partMesh = partPickInfo.pickedMesh;
            const part = partMesh.partData;
            
            // Toggle part selection
            if (this.selectedPart === part) {
                // Don't deselect if drill press tool is active
                if (this.activeTool !== 'drill') {
                    this.deselectPart();
                }
            } else {
                this.selectPart(part);
            }
            return; // Exit early to prevent face selection
        }
        
        // If no part was clicked, check for selectable faces
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => this.isSelectableFace(mesh)
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh) {
            const face = pickInfo.pickedMesh;
            
            // Toggle selection only if clicking the same face
            if (this.selectedFace === face) {
                this.deselectFace();
            } else {
                // Select new face (this will auto-deselect the previous one)
                this.selectFace(face);
            }
        } else {
            // Don't deselect when clicking empty space - allows rotation/manipulation
            // Only deselect on explicit same-face click or different face selection
        }
    }
    
    handleRightClickContextMenu(pointerInfo) {
        // Prevent browser context menu
        pointerInfo.event.preventDefault();
        pointerInfo.event.stopPropagation();
        
        // Pick what's under the mouse
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => {
                // Check if it's a workbench part or project part
                return mesh.isWorkBenchPart || mesh.isProjectPart;
            }
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh && pickInfo.pickedMesh.partData) {
            const mesh = pickInfo.pickedMesh;
            const part = mesh.partData;
            
            // Select the part if not already selected
            if (this.selectedPart !== part) {
                this.selectPart(part);
            }
            
            // Get mouse position for context menu
            const canvas = this.scene.getEngine().getRenderingCanvas();
            const rect = canvas.getBoundingClientRect();
            const x = pointerInfo.event.clientX;
            const y = pointerInfo.event.clientY;
            
            // Show context menu using the workspace ContextMenuSystem
            if (window.ContextMenuSystem) {
                window.ContextMenuSystem.showContextMenu(x, y, part);
            }
            
            console.log('Right-clicked on part:', part.materialName);
        }
    }
    
    isSelectableFace(mesh) {
        if (!mesh || !mesh.name) return false;
        
        
        // Check if it's one of our closed shapes (check both mesh and parent)
        for (const shape of this.closedShapes) {
            if (shape.mesh === mesh || shape.mesh === mesh.parent) {
                return true;
            }
        }
        
        // Also check current sketch elements if we just finished drawing
        if (this.currentSketch && this.currentSketch.elements) {
            for (const element of this.currentSketch.elements) {
                if (element.closed && (element.mesh === mesh || element.mesh === mesh.parent)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    performExtrusion(isPositive) {
        console.log('startExtrusion called with isPositive:', isPositive);
        if (!this.selectedFace) {
            console.log('No selected face for extrusion');
            return;
        }
        
        console.log('Looking for shape data for face:', this.selectedFace.name);
        
        // Find the shape data for the selected face
        let shapeData = null;
        
        // Check closedShapes first
        console.log('Checking closedShapes:', this.closedShapes.length, 'shapes');
        for (const shape of this.closedShapes) {
            console.log('Checking shape:', shape.type, 'mesh:', shape.mesh?.name);
            if (shape.mesh === this.selectedFace || shape.mesh === this.selectedFace.parent) {
                shapeData = shape;
                console.log('Found matching shape in closedShapes:', shape.type);
                break;
            }
        }
        
        // Check current sketch elements if not found
        if (!shapeData && this.currentSketch && this.currentSketch.elements) {
            console.log('Checking current sketch elements:', this.currentSketch.elements.length, 'elements');
            for (const element of this.currentSketch.elements) {
                console.log('Checking element:', element.type, 'mesh:', element.mesh?.name);
                if (element.closed && (element.mesh === this.selectedFace || element.mesh === this.selectedFace.parent)) {
                    shapeData = element;
                    console.log('Found matching element in sketch:', element.type);
                    break;
                }
            }
        }
        
        if (shapeData) {
            // Default extrusion height
            const height = 5; // 5cm extrusion
            
            // Perform the extrusion based on shape type
            console.log('About to extrude shape type:', shapeData.type, 'height:', height, 'isPositive:', isPositive);
            switch (shapeData.type) {
                case 'rectangle':
                    console.log('Calling extrudeRectangle');
                    this.extrudeRectangle(shapeData, height, isPositive);
                    break;
                case 'circle':
                    console.log('Calling extrudeCircle');
                    this.extrudeCircle(shapeData, height, isPositive);
                    break;
                case 'ellipse':
                    console.log('Calling extrudeEllipse');
                    this.extrudeEllipse(shapeData, height, isPositive);
                    break;
                case 'triangle':
                    console.log('Calling extrudeTriangle');
                    this.extrudeTriangle(shapeData, height, isPositive);
                    break;
            }
            console.log('Extrusion method completed');
            
            // Deselect the face after extrusion
            this.deselectFace();
        }
    }
    
    selectFace(face) {
        console.log('selectFace called for:', face.name);
        
        // Clear previous selection only if different face
        if (this.selectedFace && this.selectedFace !== face) {
            this.deselectFace();
        }
        
        // Set new selection
        this.selectedFace = face;
        this.setFaceSelection(face, true);
        
        // Clear hover since we've selected
        this.clearHover();
        
        // Update UI - this should show the extrusion buttons
        this.updateSelectionUI();
        this.updateToolGroups();
        
        // Check if extrude tool is active and auto-start extrusion
        if (this.activeTool === 'extrude') {
            console.log('Extrude tool is active, starting extrusion for selected face:', this.selectedFace?.name);
            this.startBidirectionalExtrusion();
        }
        
        console.log('Face selection complete, selectedFace:', this.selectedFace?.name);
    }
    
    deselectFace() {
        if (this.selectedFace) {
            console.log('deselectFace called for:', this.selectedFace.name);
            console.trace('Deselection stack trace');
            
            // Clean up any active extrusion
            if (this.isInteractiveExtruding) {
                console.log('Cleaning up active extrusion during deselection');
                this.cleanupInteractiveExtrusion();
            }
            
            this.setFaceSelection(this.selectedFace, false);
            this.selectedFace = null;
            this.disableExtrusionMode();
            this.updateSelectionUI();
            this.updateToolGroups();

        }
    }
    
    selectPart(part) {
        console.log('selectPart called for:', part?.name || part);
        
        // Clear previous part selection
        if (this.selectedPart && this.selectedPart !== part) {
            this.deselectPart();
        }
        
        // Also clear face selection when selecting a part
        if (this.selectedFace) {
            this.deselectFace();
        }
        
        // Set new part selection
        this.selectedPart = part;
        this.setPartSelection(part, true);
        
        // Update UI to show part selection state
        this.updatePartSelectionUI();
        
        console.log('Part selection complete, selectedPart:', this.selectedPart?.name);
    }
    
    deselectPart() {
        if (this.selectedPart) {
            console.log('deselectPart called for:', this.selectedPart.name);
            
            this.setPartSelection(this.selectedPart, false);
            this.selectedPart = null;
            this.updatePartSelectionUI();
        }
    }
    
    setPartSelection(part, isSelected) {
        if (!part) return;
        
        // Find the mesh in the scene that represents this part
        let partMesh = null;
        
        // If part is already a mesh, use it directly
        if (part.dispose && part.material) {
            partMesh = part;
        } else {
            // Otherwise, find the mesh by partData
            this.scene.meshes.forEach(mesh => {
                if (mesh.partData && mesh.partData === part) {
                    partMesh = mesh;
                }
            });
        }
        
        if (partMesh) {
            // DEBUG: Track position before/after selection
            const positionBefore = partMesh.position.clone();
            console.log(`POSITION BEFORE selection (${isSelected}):`, positionBefore);
            
            if (isSelected) {
                // Store original material if not already stored
                if (!partMesh._originalMaterial) {
                    partMesh._originalMaterial = partMesh.material;
                }
                // Apply selection material (reuse the existing selection outline material)
                partMesh.material = this.selectionOutlineMaterial;
            } else {
                // Restore original material
                if (partMesh._originalMaterial) {
                    partMesh.material = partMesh._originalMaterial;
                    partMesh._originalMaterial = null;
                }
            }
            
            // DEBUG: Track position after selection
            const positionAfter = partMesh.position.clone();
            console.log(`POSITION AFTER selection (${isSelected}):`, positionAfter);
            
            // DEBUG: Check if position changed
            const positionDelta = positionAfter.subtract(positionBefore);
            if (positionDelta.length() > 0.001) {
                console.error(`❌ POSITION CHANGED during selection! Delta:`, positionDelta);
            }
        }
    }
    
    updatePartSelectionUI() {
        const selectionInfo = document.getElementById('selection-info');
        if (this.selectedPart) {
            const partName = this.selectedPart.name || this.selectedPart.title || 'Unknown Part';
            selectionInfo.textContent = `Selected Part: ${partName}`;
        } else if (!this.selectedFace) {
            selectionInfo.textContent = 'No selection - Click a part or face to select';
        }
        
        // Update project explorer to show selection state
        this.updateProjectExplorerSelection();
    }
    
    updateProjectExplorerSelection() {
        const projectPartsList = document.getElementById('project-parts-list');
        if (projectPartsList) {
            const listItems = projectPartsList.querySelectorAll('li');
            listItems.forEach(item => {
                item.classList.remove('active');
                // Check if this item represents the selected part
                if (this.selectedPart && item.textContent.includes(this.selectedPart.name || this.selectedPart.title)) {
                    item.classList.add('active');
                }
            });
        }
    }
    
    setFaceHover(face, isHovered) {
        console.log('setFaceHover called:', face.name, 'isHovered:', isHovered, 'selectedFace:', this.selectedFace?.name);
        console.log('Face material before hover:', face.material?.name);
        
        if (isHovered) {
            // Store base material if not already stored
            if (!face.baseMaterial) {
                face.baseMaterial = face.material;
                console.log('Hover stored base material:', face.baseMaterial?.name);
            }
            // Don't apply hover if face is selected
            if (this.selectedFace !== face) {
                face.material = this.hoverOutlineMaterial;
                console.log('Applied hover material');
            } else {
                console.log('Skipped hover - face is selected');
            }
        } else {
            // Only restore if this face is not selected
            if (this.selectedFace !== face && face.baseMaterial) {
                console.log('Hover restoring base material:', face.baseMaterial.name);
                face.material = face.baseMaterial;
            } else {
                console.log('Skipped hover restore - face is selected or no base material');
            }
        }
        console.log('Face material after hover:', face.material?.name);
    }
    
    setFaceSelection(face, isSelected) {
        console.log('setFaceSelection called:', face.name, 'isSelected:', isSelected);
        console.log('Current material before:', face.material?.name);
        
        if (isSelected) {
            // Store base material if not already stored
            if (!face.baseMaterial) {
                face.baseMaterial = face.material;
                console.log('Stored base material:', face.baseMaterial?.name);
            }
            // Apply selection material
            const highlightMaterial = face.baseMaterial.clone(face.name + '_selected');
            highlightMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.4, 1.0); // Blue tint
            face.material = highlightMaterial;
            console.log('Applied selection material:', highlightMaterial.name);
        } else {
            // Restore base material
            if (face.baseMaterial) {
                console.log('Restoring base material:', face.baseMaterial.name);
                face.material = face.baseMaterial;
                face.baseMaterial = null;
            }
        }
        console.log('Material after selection:', face.material?.name);
    }
    
    clearHover() {
        if (this.hoveredFace) {
            this.setFaceHover(this.hoveredFace, false);
            this.hoveredFace = null;
        }
    }
    
    updateSelectionUI() {
        const selectionInfo = document.getElementById('selection-info');
        if (this.selectedFace) {
            selectionInfo.textContent = `Selected: ${this.getShapeType(this.selectedFace)} - Click and drag to extrude`;
        } else {
            selectionInfo.textContent = 'No selection - Click a face to select';
        }
    }
    
    getShapeType(mesh) {
        // Find the shape type from our stored shapes
        for (const shape of this.closedShapes) {
            if (shape.mesh === mesh) {
                return shape.type.charAt(0).toUpperCase() + shape.type.slice(1);
            }
        }
        
        if (this.currentSketch && this.currentSketch.elements) {
            for (const element of this.currentSketch.elements) {
                if (element.mesh === mesh) {
                    return element.type.charAt(0).toUpperCase() + element.type.slice(1);
                }
            }
        }
        
        return 'Shape';
    }
    
    // ==================== EXTRUSION SYSTEM ====================
    
    enableExtrusionMode() {
        if (!this.selectedFace) return;
        
        this.isExtruding = false;
        this.extrusionStartPoint = null;
        this.extrusionDistance = 0;
        
        // Create and show extrusion gizmo - DISABLED to fix auto-deselect
        // this.createExtrusionGizmo();
        
        // Setup extrusion mouse handlers
        this.setupExtrusionHandlers();
        

    }
    
    disableExtrusionMode() {
        this.isExtruding = false;
        this.extrusionStartPoint = null;
        this.extrusionDistance = 0;
        
        // Hide and dispose extrusion gizmo
        this.disposeExtrusionGizmo();
        
        // Remove extrusion handlers
        this.removeExtrusionHandlers();
        

    }
    
    // ==================== EXTRUSION GIZMO SYSTEM ====================
    
    createExtrusionGizmo() {
        if (!this.selectedFace) return;
        
        // Dispose existing gizmo if any
        this.disposeExtrusionGizmo();
        
        // Initialize gizmo components
        this.extrusionGizmo = {
            root: null,
            positiveArrow: null,
            negativeArrow: null,
            centerSphere: null,
            isActive: false,
            activeComponent: null,
            originalPosition: null
        };
        
        // Get face center and normal
        const faceCenter = this.getFaceCenter(this.selectedFace);
        const faceNormal = this.getFaceNormal(this.selectedFace);
        
        // Create gizmo root
        this.extrusionGizmo.root = new BABYLON.TransformNode("extrusionGizmoRoot", this.scene);
        this.extrusionGizmo.root.position = faceCenter;
        this.extrusionGizmo.originalPosition = faceCenter.clone();
        
        // Create positive direction arrow (green, for adding material)
        this.extrusionGizmo.positiveArrow = this.createExtrusionArrow(faceNormal, 1, new BABYLON.Color3(0, 1, 0));
        this.extrusionGizmo.positiveArrow.parent = this.extrusionGizmo.root;
        
        // Create negative direction arrow (red, for removing material/holes)
        this.extrusionGizmo.negativeArrow = this.createExtrusionArrow(faceNormal, -1, new BABYLON.Color3(1, 0, 0));
        this.extrusionGizmo.negativeArrow.parent = this.extrusionGizmo.root;
        
        // Create center sphere for face identification
        this.extrusionGizmo.centerSphere = BABYLON.MeshBuilder.CreateSphere("extrusionCenter", {diameter: 0.3}, this.scene);
        this.extrusionGizmo.centerSphere.material = this.createGizmoMaterial(new BABYLON.Color3(1, 1, 0)); // Yellow
        this.extrusionGizmo.centerSphere.parent = this.extrusionGizmo.root;
        this.extrusionGizmo.centerSphere.isPickable = false;
        
        // Setup gizmo interaction
        this.setupExtrusionGizmoInteraction();
        
        // Scale gizmo based on camera distance
        this.updateExtrusionGizmoScale();
    }
    
    createExtrusionArrow(faceNormal, direction, color) {
        // Create arrow shaft
        const shaft = BABYLON.MeshBuilder.CreateCylinder("extrusionShaft", {
            diameter: 0.1,
            height: 2.0
        }, this.scene);
        
        // Create arrow head
        const head = BABYLON.MeshBuilder.CreateCylinder("extrusionHead", {
            diameterTop: 0,
            diameterBottom: 0.25,
            height: 0.5
        }, this.scene);
        
        // Position head at end of shaft
        head.position = new BABYLON.Vector3(0, 1.25, 0);
        
        // Create arrow parent
        const arrow = new BABYLON.TransformNode("extrusionArrow", this.scene);
        shaft.parent = arrow;
        head.parent = arrow;
        
        // Orient arrow along face normal
        const upVector = new BABYLON.Vector3(0, 1, 0);
        const rotationAxis = BABYLON.Vector3.Cross(upVector, faceNormal.scale(direction));
        const rotationAngle = Math.acos(BABYLON.Vector3.Dot(upVector, faceNormal.scale(direction)));
        
        if (rotationAxis.length() > 0.001) {
            arrow.rotationQuaternion = BABYLON.Quaternion.RotationAxis(rotationAxis.normalize(), rotationAngle);
        } else if (direction < 0) {
            arrow.rotationQuaternion = BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(1, 0, 0), Math.PI);
        }
        
        // Apply materials
        const material = this.createGizmoMaterial(color);
        shaft.material = material;
        head.material = material;
        
        // Store references for interaction
        arrow.gizmoType = direction > 0 ? 'positive' : 'negative';
        arrow.gizmoShaft = shaft;
        arrow.gizmoHead = head;
        
        return arrow;
    }
    
    createGizmoMaterial(color) {
        // Apply material with texture
        material.diffuseColor = color;
        material.emissiveColor = color.scale(0.3);
        material.specularColor = new BABYLON.Color3(0, 0, 0);
        material.alpha = 0.8;
        return material;
    }
    
    setupExtrusionGizmoInteraction() {
        // Add pointer event handlers for gizmo interaction
        this.scene.onPointerObservable.add((pointerInfo) => {
            if (!this.extrusionGizmo || !this.extrusionGizmo.root) return;
            
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    this.handleExtrusionGizmoDown(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.handleExtrusionGizmoMove(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    this.handleExtrusionGizmoUp(pointerInfo);
                    break;
            }
        });
    }
    
    handleExtrusionGizmoDown(pointerInfo) {
        if (pointerInfo.event.button !== 0) return; // Only left click
        
        const pickInfo = this.scene.pick(this.scene.pointerX, this.scene.pointerY, (mesh) => {
            return mesh === this.extrusionGizmo.positiveArrow?.gizmoShaft ||
                   mesh === this.extrusionGizmo.positiveArrow?.gizmoHead ||
                   mesh === this.extrusionGizmo.negativeArrow?.gizmoShaft ||
                   mesh === this.extrusionGizmo.negativeArrow?.gizmoHead;
        });
        
        if (pickInfo.hit) {
            this.extrusionGizmo.isActive = true;
            this.extrusionGizmo.activeComponent = this.getGizmoComponent(pickInfo.pickedMesh);
            this.extrusionGizmo.startMousePosition = {
                x: this.scene.pointerX,
                y: this.scene.pointerY
            };
            this.extrusionGizmo.startDistance = 0;
            
            // Disable camera controls during extrusion
            this.camera.inputs.attached.pointers.detachControl();
            
            // Highlight active component
            this.highlightGizmoComponent(this.extrusionGizmo.activeComponent, true);
        }
    }
    
    handleExtrusionGizmoMove(pointerInfo) {
        if (!this.extrusionGizmo.isActive || !this.extrusionGizmo.activeComponent) return;
        
        // Calculate mouse delta
        const deltaX = this.scene.pointerX - this.extrusionGizmo.startMousePosition.x;
        const deltaY = this.scene.pointerY - this.extrusionGizmo.startMousePosition.y;
        
        // Convert mouse movement to extrusion distance
        const sensitivity = 0.01;
        const distance = deltaY * sensitivity;
        
        // Apply direction multiplier
        const direction = this.extrusionGizmo.activeComponent === this.extrusionGizmo.positiveArrow ? 1 : -1;
        const extrusionDistance = distance * direction;
        
        // Update visual feedback
        this.updateExtrusionPreview(extrusionDistance);
        
        // Store current distance
        this.extrusionGizmo.currentDistance = extrusionDistance;
    }
    
    handleExtrusionGizmoUp(pointerInfo) {
        if (!this.extrusionGizmo.isActive) return;
        
        // Re-enable camera controls
        this.camera.inputs.attached.pointers.attachControl();
        
        // Apply the extrusion
        if (this.extrusionGizmo.currentDistance && Math.abs(this.extrusionGizmo.currentDistance) > 0.01) {
            this.applyExtrusion(this.extrusionGizmo.currentDistance);
        }
        
        // Reset gizmo state
        this.extrusionGizmo.isActive = false;
        this.extrusionGizmo.activeComponent = null;
        this.extrusionGizmo.currentDistance = 0;
        
        // Remove highlight
        this.highlightGizmoComponent(this.extrusionGizmo.positiveArrow, false);
        this.highlightGizmoComponent(this.extrusionGizmo.negativeArrow, false);
    }
    
    getGizmoComponent(mesh) {
        if (mesh === this.extrusionGizmo.positiveArrow?.gizmoShaft || 
            mesh === this.extrusionGizmo.positiveArrow?.gizmoHead) {
            return this.extrusionGizmo.positiveArrow;
        }
        if (mesh === this.extrusionGizmo.negativeArrow?.gizmoShaft || 
            mesh === this.extrusionGizmo.negativeArrow?.gizmoHead) {
            return this.extrusionGizmo.negativeArrow;
        }
        return null;
    }
    
    highlightGizmoComponent(component, isHighlighted) {
        if (!component) return;
        
        const highlightColor = isHighlighted ? new BABYLON.Color3(1, 1, 0) : null;
        
        if (component.gizmoShaft && component.gizmoShaft.material) {
            if (isHighlighted) {
                component.gizmoShaft.material.emissiveColor = highlightColor;
            } else {
                // Restore original emissive color
                const originalColor = component.gizmoType === 'positive' ? 
                    new BABYLON.Color3(0, 1, 0) : new BABYLON.Color3(1, 0, 0);
                component.gizmoShaft.material.emissiveColor = originalColor.scale(0.3);
            }
        }
        
        if (component.gizmoHead && component.gizmoHead.material) {
            if (isHighlighted) {
                component.gizmoHead.material.emissiveColor = highlightColor;
            } else {
                // Restore original emissive color
                const originalColor = component.gizmoType === 'positive' ? 
                    new BABYLON.Color3(0, 1, 0) : new BABYLON.Color3(1, 0, 0);
                component.gizmoHead.material.emissiveColor = originalColor.scale(0.3);
            }
        }
    }
    
    updateExtrusionPreview(distance) {
        // This would update a preview of the extrusion
        // For now, we'll just move the gizmo to show the distance
        if (this.extrusionGizmo.root) {
            const faceNormal = this.getFaceNormal(this.selectedFace);
            const offset = faceNormal.scale(distance);
            this.extrusionGizmo.root.position = this.extrusionGizmo.originalPosition.add(offset);
        }
    }
    
    applyExtrusion(distance) {
        if (!this.selectedFace) return;
        
        // Get shape data for the selected face
        const shapeData = this.getShapeData(this.selectedFace);
        if (!shapeData) return;
        
        // Apply extrusion based on shape type
        const extrusionHeight = Math.abs(distance);
        const isPositive = distance > 0;
        
        
        // Call appropriate extrusion method
        this.performShapeExtrusion(shapeData, extrusionHeight, isPositive);
    }
    
    performShapeExtrusion(shapeData, height, isPositive) {
        // This will call the existing extrusion methods
        switch (shapeData.type) {
            case 'rectangle':
                this.extrudeRectangle(shapeData, height, isPositive);
                break;
            case 'circle':
                this.extrudeCircle(shapeData, height, isPositive);
                break;
            case 'ellipse':
                this.extrudeEllipse(shapeData, height, isPositive);
                break;
            case 'triangle':
                this.extrudeTriangle(shapeData, height, isPositive);
                break;
            default:
        }
    }
    
    getFaceCenter(face) {
        console.log('getFaceCenter called for face:', face.name);
        
        // Calculate geometric center from vertices - works for ANY mesh
        const positions = face.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        if (!positions || positions.length === 0) {
            console.log('No vertex data, using mesh position');
            return face.position.clone();
        }
        
        // Calculate centroid from all vertices
        let centerX = 0, centerY = 0, centerZ = 0;
        const vertexCount = positions.length / 3;
        
        for (let i = 0; i < positions.length; i += 3) {
            centerX += positions[i];
            centerY += positions[i + 1];
            centerZ += positions[i + 2];
        }
        
        centerX /= vertexCount;
        centerY /= vertexCount;
        centerZ /= vertexCount;
        
        // Transform to world coordinates
        const localCenter = new BABYLON.Vector3(centerX, centerY, centerZ);
        const worldCenter = BABYLON.Vector3.TransformCoordinates(localCenter, face.getWorldMatrix());
        
        console.log('Calculated geometric center:', worldCenter);
        return worldCenter;
    }
    
    updateExtrusionGizmoScale() {
        if (!this.extrusionGizmo || !this.extrusionGizmo.root) return;
        
        // Scale gizmo based on camera distance to keep consistent size
        const distance = BABYLON.Vector3.Distance(this.camera.position, this.extrusionGizmo.root.position);
        const scale = Math.max(0.1, Math.min(2.0, distance * 0.1));
        
        this.extrusionGizmo.root.scaling = new BABYLON.Vector3(scale, scale, scale);
    }
    
    disposeExtrusionGizmo() {
        if (this.extrusionGizmo) {
            if (this.extrusionGizmo.root) {
                this.extrusionGizmo.root.dispose();
            }
            this.extrusionGizmo = null;
        }
    }
    
    setupExtrusionHandlers() {
        // Store original camera controls state
        this.originalCameraControlsEnabled = this.camera.inputs.attached.pointers;
        
        // Create extrusion event handlers
        this.extrusionMouseDownHandler = (event) => {
            if (event.button === 0 && this.selectedFace) { // Left click
                this.startExtrusion(event);
            }
        };
        
        this.extrusionMouseMoveHandler = (event) => {
            if (this.isExtruding) {
                this.updateExtrusion(event);
            }
        };
        
        this.extrusionMouseUpHandler = (event) => {
            if (event.button === 0 && this.isExtruding) { // Left click
                this.finishExtrusion(event);
            }
        };
        
        // Add event listeners
        this.canvas.addEventListener('mousedown', this.extrusionMouseDownHandler);
        this.canvas.addEventListener('mousemove', this.extrusionMouseMoveHandler);
        this.canvas.addEventListener('mouseup', this.extrusionMouseUpHandler);
    }
    
    removeExtrusionHandlers() {
        if (this.extrusionMouseDownHandler) {
            this.canvas.removeEventListener('mousedown', this.extrusionMouseDownHandler);
        }
        if (this.extrusionMouseMoveHandler) {
            this.canvas.removeEventListener('mousemove', this.extrusionMouseMoveHandler);
        }
        if (this.extrusionMouseUpHandler) {
            this.canvas.removeEventListener('mouseup', this.extrusionMouseUpHandler);
        }
    }
    
    startExtrusion(event) {
        if (!this.selectedFace) return;
        
        // Get mouse position
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Check if we clicked on the selected face
        const pickInfo = this.scene.pick(x, y, (mesh) => mesh === this.selectedFace);
        
        if (pickInfo.hit) {
            this.isExtruding = true;
            this.extrusionStartPoint = { x: event.clientX, y: event.clientY };
            this.extrusionDistance = 0;
            
            // Calculate extrusion normal (perpendicular to face)
            this.extrusionNormal = this.calculateExtrusionNormal();
            
            // Create extrusion preview
            this.createExtrusionPreview();
            
            // Disable camera controls during extrusion
            this.camera.detachControl(this.canvas);
            

        }
    }
    
    updateExtrusion(event) {
        if (!this.isExtruding || !this.extrusionStartPoint) return;
        
        // Calculate mouse movement
        const deltaY = this.extrusionStartPoint.y - event.clientY; // Inverted Y for intuitive up/down
        const sensitivity = 0.1; // Adjust sensitivity
        
        this.extrusionDistance = deltaY * sensitivity;
        
        // Update extrusion preview
        this.updateExtrusionPreview();
        
        // Update UI
        document.getElementById('selection-info').textContent = 
            `Extruding: ${this.extrusionDistance.toFixed(2)} units`;
    }
    
    finishExtrusion(event) {
        if (!this.isExtruding) return;
        
        // Create final extruded shape
        this.createExtrudedShape();
        
        // Clean up
        this.cleanupExtrusionPreview();
        this.isExtruding = false;
        this.extrusionStartPoint = null;
        
        // Re-enable camera controls
        // this.camera.attachControl(this.canvas, true); // Commented out to prevent conflicts with custom camera controls
        
        // Deselect face
        this.deselectFace();
        

    }
    
    calculateExtrusionNormal() {
        // For 2D shapes, extrude along the sketch plane normal
        if (this.sketchForward) {
            return this.sketchForward.clone();
        }
        
        // Default to Y-up if no sketch plane defined
        return new BABYLON.Vector3(0, 1, 0);
    }
    
    createExtrusionPreview() {
        // This will be implemented based on the shape type

    }
    
    updateExtrusionPreview() {
        // Update the preview mesh with current extrusion distance

    }
    
    createExtrudedShape() {
        if (!this.selectedFace || this.extrusionDistance === 0) return;
        
        // Create the actual extruded 3D shape
        const shape = this.getShapeData(this.selectedFace);
        if (!shape) return;
        
        let extrudedMesh = null;
        
        switch (shape.type) {
            case 'rectangle':
                extrudedMesh = this.extrudeRectangle(shape);
                break;
            case 'circle':
                extrudedMesh = this.extrudeCircle(shape);
                break;
            case 'ellipse':
                extrudedMesh = this.extrudeEllipse(shape);
                break;
            case 'triangle':
                extrudedMesh = this.extrudeTriangle(shape);
                break;
        }
        
        if (extrudedMesh) {
            // Set material
        // Apply material with texture
            material.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.9);
            material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            extrudedMesh.material = material;
            
            // Make selectable
            extrudedMesh.isPickable = true;
            
            // Hide original 2D shape
            this.selectedFace.setEnabled(false);
            

        }
    }
    
    getShapeData(mesh) {
        // Find the shape data from our stored shapes
        for (const shape of this.closedShapes) {
            if (shape.mesh === mesh) {
                return shape;
            }
        }
        
        if (this.currentSketch && this.currentSketch.elements) {
            for (const element of this.currentSketch.elements) {
                if (element.mesh === mesh) {
                    return element;
                }
            }
        }
        
        return null;
    }
    
    extrudeRectangle(shape, height = null, isPositive = true) {
        // Create box from rectangle
        const corners = shape.points || this.getRectangleCorners(shape.start, shape.end);
        if (!corners || corners.length < 4) return null;
        
        // Use the rectangle corners to define the 8 corners of the extruded box
        const extrusionHeight = height !== null ? height : 5;
        const direction = isPositive ? 1 : -1;
        
        // Calculate the extrusion normal (perpendicular to rectangle plane)
        const side1 = corners[1].subtract(corners[0]);
        const side2 = corners[3].subtract(corners[0]);
        const normal = BABYLON.Vector3.Cross(side1, side2).normalize();
        const extrusionVector = normal.scale(extrusionHeight * direction);
        
        // Create the 8 corners of the box using the 4 rectangle corners as base
        const bottomCorners = corners;
        const topCorners = corners.map(corner => corner.add(extrusionVector));
        
        // Create custom mesh from the 8 corners
        const positions = [];
        const indices = [];
        
        // Add bottom corners (0,1,2,3)
        bottomCorners.forEach(corner => {
            positions.push(corner.x, corner.y, corner.z);
        });
        
        // Add top corners (4,5,6,7)
        topCorners.forEach(corner => {
            positions.push(corner.x, corner.y, corner.z);
        });
        
        // Define the 12 triangles (2 per face, 6 faces)
        const faces = [
            // Bottom face (0,1,2,3)
            [0,2,1], [0,3,2],
            // Top face (4,5,6,7)
            [4,5,6], [4,6,7],
            // Side faces
            [0,1,5], [0,5,4], // Front
            [1,2,6], [1,6,5], // Right
            [2,3,7], [2,7,6], // Back
            [3,0,4], [3,4,7]  // Left
        ];
        
        faces.forEach(face => {
            indices.push(...face);
        });
        
        const boxName = isPositive ? 'extrudedRectangle' : 'extrudedHole';
        const box = new BABYLON.Mesh(boxName, this.scene);
        
        const vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        vertexData.normals = [];
        BABYLON.VertexData.ComputeNormals(positions, indices, vertexData.normals);
        
        vertexData.applyToMesh(box);
        
        // Apply different materials for positive vs negative
        if (isPositive) {
            // Standard material for solid extrusion
            box.material = this.createSolidMaterial();
        } else {
            // Hole material (red/transparent to indicate cutting)
            box.material = this.createHoleMaterial();
        }
        
        
        return box;
    }
    
    createSolidMaterial() {
        // Apply material with texture
        material.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.9); // Light blue
        material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.15);
        return material;
    }
    
    createHoleMaterial() {
        // Apply material with texture
        material.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3); // Red
        material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        material.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0.1);
        material.alpha = 0.7; // Semi-transparent to indicate it's a hole
        return material;
    }
    
    extrudeCircle(shape, height = null, isPositive = true) {
        console.log('extrudeCircle called with shape:', shape);
        
        // Create cylinder from circle
        const radius = shape.radius || 1;
        const depth = height !== null ? height : Math.abs(this.extrusionDistance);
        
        console.log('Circle extrusion - radius:', radius, 'depth:', depth);
        
        const cylinderName = isPositive ? 'extrudedCircle' : 'extrudedCircleHole';
        const cylinder = BABYLON.MeshBuilder.CreateCylinder(cylinderName, {
            diameter: radius * 2,
            height: depth,
            tessellation: 32  // More segments for smooth circle
        }, this.scene);
        
        // Get the sketch surface normal from the circle's mesh
        const sketchNormal = this.getFaceNormal(shape.mesh);
        console.log('Sketch normal:', sketchNormal);
        
        // Orient cylinder to extrude along sketch normal
        // Default cylinder axis is Y-up, we need to align it with sketch normal
        if (sketchNormal && !sketchNormal.equals(BABYLON.Vector3.Up())) {
            const rotationAxis = BABYLON.Vector3.Cross(BABYLON.Vector3.Up(), sketchNormal);
            const rotationAngle = Math.acos(BABYLON.Vector3.Dot(BABYLON.Vector3.Up(), sketchNormal));
            
            if (rotationAxis.length() > 0.001) { // Avoid zero-length cross product
                cylinder.rotationQuaternion = BABYLON.Quaternion.RotationAxis(rotationAxis.normalize(), rotationAngle);
            }
        }
        
        // Position cylinder
        const center = shape.center || BABYLON.Vector3.Zero();
        const direction = isPositive ? 1 : -1;
        cylinder.position = center.add(sketchNormal.scale(depth / 2 * direction));
        
        console.log('Cylinder positioned at:', cylinder.position);
        
        // Apply appropriate material
        cylinder.material = isPositive ? this.createSolidMaterial() : this.createHoleMaterial();
        
        return cylinder;
    }
    
    extrudeEllipse(shape, height = null, isPositive = true) {
        // Create ellipsoid from ellipse (simplified as cylinder for now)
        const radiusX = shape.radiusX || 1;
        const radiusY = shape.radiusY || 1;
        const depth = height !== null ? height : Math.abs(this.extrusionDistance);
        
        const cylinderName = isPositive ? 'extrudedEllipse' : 'extrudedEllipseHole';
        const cylinder = BABYLON.MeshBuilder.CreateCylinder(cylinderName, {
            diameterTop: radiusX * 2,
            diameterBottom: radiusX * 2,
            height: depth
        }, this.scene);
        
        // Scale to create ellipse
        cylinder.scaling.x = radiusX / radiusY;
        
        const center = shape.center || BABYLON.Vector3.Zero();
        const extrusionNormal = this.extrusionNormal || this.getFaceNormal(shape.mesh);
        const direction = isPositive ? 1 : -1;
        cylinder.position = center.add(extrusionNormal.scale(depth / 2 * direction));
        
        // Apply appropriate material
        cylinder.material = isPositive ? this.createSolidMaterial() : this.createHoleMaterial();
        
        return cylinder;
    }
    
    
    extrudeTriangle(shape, height = null, isPositive = true) {
        // Create extruded triangle
        const points = shape.points || [];
        if (points.length < 3) return null;
        
        // Convert to 2D points for extrusion
        const shape2D = points.map(p => new BABYLON.Vector2(p.x, p.z));
        const depth = height !== null ? height : Math.abs(this.extrusionDistance);
        
        const meshName = isPositive ? 'extrudedTriangle' : 'extrudedTriangleHole';
        const extruded = BABYLON.MeshBuilder.ExtrudePolygon(meshName, {
            shape: shape2D,
            depth: depth
        }, this.scene);
        
        // Position based on direction
        const extrusionNormal = this.extrusionNormal || this.getFaceNormal(shape.mesh);
        const direction = isPositive ? 1 : -1;
        if (direction < 0) {
            extruded.position = extruded.position.add(extrusionNormal.scale(-depth));
        }
        
        // Apply appropriate material
        extruded.material = isPositive ? this.createSolidMaterial() : this.createHoleMaterial();
        
        return extruded;
    }
    
    cleanupExtrusionPreview() {
        // Clean up any preview meshes
        if (this.extrusionPreview) {
            this.extrusionPreview.dispose();
            this.extrusionPreview = null;
        }
    }
    
    // ==================== INTERACTIVE EXTRUSION GIZMO SYSTEM ====================
    
    startBidirectionalExtrusion() {
        if (!this.selectedFace) {
            console.error('startBidirectionalExtrusion called but no selectedFace!');
            return;
        }
        
        console.log('Starting bidirectional extrusion for face:', this.selectedFace.name);
        
        // Store extrusion state
        this.isInteractiveExtruding = true;
        this.extrusionDistance = 0;
        this.extrusionMode = null; // Will be determined by drag direction
        
        // Enable smart camera controls during extrusion (allow rotation when not over gizmo/surface)
        this.setupSmartCameraControl();
        
        // Get face center and normal for gizmo positioning
        console.log('Getting face center and normal...');
        const faceCenter = this.getFaceCenter(this.selectedFace);
        const faceNormal = this.getFaceNormal(this.selectedFace);
        
        console.log('Face center:', faceCenter);
        console.log('Face normal:', faceNormal);
        
        if (!faceCenter || !faceNormal) {
            console.error('Failed to get face center or normal! center:', faceCenter, 'normal:', faceNormal);
            return;
        }
        
        // Create bidirectional extrusion gizmo
        console.log('About to create bidirectional gizmo...');
        this.createBidirectionalGizmo(faceCenter, faceNormal);
        
        // Update UI
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            selectionInfo.textContent = 'Drag gizmo: Pull out to add material, Push in to cut. Rotate camera away from gizmo/surface to navigate.';
        }
        
        console.log('Bidirectional extrusion started');
    }
    
    setupSmartCameraControl() {
        // Keep camera controls attached but intercept mouse events
        // Allow camera rotation only when mouse is NOT over gizmo or selected surface
        
        this.smartCameraPointerObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (!this.isInteractiveExtruding) return;
            
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
                // Check what's under the mouse
                const pickInfo = this.scene.pick(pointerInfo.event.clientX, pointerInfo.event.clientY);
                
                if (pickInfo.hit) {
                    const pickedMesh = pickInfo.pickedMesh;
                    
                    // Disable camera if over gizmo or selected face
                    const isOverGizmo = this.extrusionGizmoComponents && 
                        (pickedMesh === this.extrusionGizmoComponents.gizmoPlane || 
                         pickedMesh === this.extrusionGizmoComponents.interactionPlane);
                    
                    const isOverSelectedFace = pickedMesh === this.selectedFace;
                    
                    if (isOverGizmo || isOverSelectedFace) {
                        // Disable camera controls temporarily
                        if (this.camera.inputs.attached.pointers) {
                            this.camera.inputs.attached.pointers.detachControl();
                            this.cameraControlsDetached = true;
                        }
                    } else {
                        // Re-enable camera controls
                        if (this.cameraControlsDetached && this.camera.inputs.attached.pointers) {
                            this.camera.inputs.attached.pointers.attachControl();
                            this.cameraControlsDetached = false;
                        }
                    }
                }
            }
        });
        
        console.log('Smart camera control enabled - camera rotates when not over gizmo/surface');
    }
    
    cleanupSmartCameraControl() {
        if (this.smartCameraPointerObserver) {
            this.scene.onPointerObservable.remove(this.smartCameraPointerObserver);
            this.smartCameraPointerObserver = null;
        }
        
        // Ensure camera controls are re-enabled
        if (this.cameraControlsDetached && this.camera.inputs.attached.pointers) {
            this.camera.inputs.attached.pointers.attachControl();
            this.cameraControlsDetached = false;
        }
        
        console.log('Smart camera control cleaned up');
    }
    
    updateGizmoBillboard(gizmoPlane) {
        // Create proper billboard that rotates around surface normal axis to face camera
        if (!gizmoPlane || !this.gizmoSurfaceNormal) return;
        
        const updateBillboard = () => {
            if (!this.isInteractiveExtruding || !gizmoPlane) return;
            
            const gizmoPosition = gizmoPlane.getAbsolutePosition();
            const cameraPosition = this.camera.position;
            
            // Vector from gizmo to camera
            const toCamera = cameraPosition.subtract(gizmoPosition).normalize();
            
            // Project camera direction onto plane perpendicular to surface normal
            const surfaceNormal = this.gizmoSurfaceNormal;
            const projectedToCamera = toCamera.subtract(surfaceNormal.scale(BABYLON.Vector3.Dot(toCamera, surfaceNormal))).normalize();
            
            // Calculate rotation to face camera while staying aligned with surface normal
            // The gizmo should "look at" the camera but constrained to rotate around the normal axis
            
            // Create coordinate system for the gizmo
            const forward = projectedToCamera; // Direction to face camera (projected)
            const up = surfaceNormal; // Surface normal is "up" for the billboard
            const right = BABYLON.Vector3.Cross(up, forward).normalize();
            
            // Create rotation matrix from these vectors
            const rotationMatrix = BABYLON.Matrix.FromValues(
                right.x, right.y, right.z, 0,
                up.x, up.y, up.z, 0,
                forward.x, forward.y, forward.z, 0,
                0, 0, 0, 1
            );
            
            // Apply rotation to gizmo
            gizmoPlane.rotation = rotationMatrix.toEulerAngles();
        };
        
        // Update billboard immediately
        updateBillboard();
        
        // Set up continuous billboard updates during camera movement
        this.gizmoBillboardObserver = this.scene.onBeforeRenderObservable.add(updateBillboard);
        
        console.log('Dynamic billboard behavior enabled - gizmo rotates on surface normal axis');
    }
    
    cleanupGizmoBillboard() {
        if (this.gizmoBillboardObserver) {
            this.scene.onBeforeRenderObservable.remove(this.gizmoBillboardObserver);
            this.gizmoBillboardObserver = null;
        }
        if (this.gizmoOrientationObserver) {
            this.scene.onBeforeRenderObservable.remove(this.gizmoOrientationObserver);
            this.gizmoOrientationObserver = null;
        }
        if (this.gizmoTracker) {
            this.scene.onBeforeRenderObservable.remove(this.gizmoTracker);
            this.gizmoTracker = null;
        }
        console.log('Gizmo orientation tracking cleaned up');
    }
    
    createBidirectionalGizmo(position, normal) {
        // Clean up existing gizmo
        this.cleanupExtrusionGizmo();
        
        console.log('Creating 2D sprite gizmo at position:', position, 'with normal:', normal);
        
        // Create gizmo root
        this.extrusionGizmo = new BABYLON.TransformNode('extrusionGizmo', this.scene);
        this.extrusionGizmo.position = position.clone();
        
        // Create gizmo plane with proper camera-facing orientation
        const gizmoPlane = BABYLON.MeshBuilder.CreatePlane('gizmoSprite', {
            width: 8,
            height: 16
        }, this.scene);
        
        gizmoPlane.parent = this.extrusionGizmo;
        gizmoPlane.position = normal.scale(5);
        
        // FINAL FIX: Arrow points along normal, sprite rotates around normal to face camera
        // 1. Arrow direction stays locked to surface normal (in/out)
        // 2. Sprite rotates around that axis to face camera
        
        // Initial position: arrow points along normal (correct direction)
        gizmoPlane.lookAt(gizmoPlane.getAbsolutePosition().add(normal), BABYLON.Vector3.Up());
        
        // Track camera and rotate around normal axis
        const trackCamera = () => {
            if (!this.isInteractiveExtruding || !gizmoPlane) return;
            
            const gizmoPos = gizmoPlane.getAbsolutePosition();
            const toCam = this.camera.position.subtract(gizmoPos).normalize();
            
            // Keep arrow pointing along normal, rotate sprite to face camera around that axis
            const right = BABYLON.Vector3.Cross(normal, toCam).normalize();
            const adjustedUp = BABYLON.Vector3.Cross(toCam, right).normalize();
            
            gizmoPlane.lookAt(gizmoPos.add(normal), adjustedUp);
        };
        
        this.gizmoTracker = this.scene.onBeforeRenderObservable.add(trackCamera);
        
        console.log('Arrow locked to normal, sprite tracks camera');
        
        // Create canvas for professional arrow sprite
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Clear to transparent and draw professional arrow
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.drawProfessionalGizmo(ctx, 'neutral');
        
        // Create texture from canvas
        const pngDataURL = canvas.toDataURL('image/png');
        const gizmoTexture = new BABYLON.Texture(pngDataURL, this.scene);
        
        // Create material with proper transparency
        const gizmoMaterial = new BABYLON.StandardMaterial('gizmoMaterial', this.scene);
        gizmoMaterial.diffuseTexture = gizmoTexture;
        gizmoMaterial.useAlphaFromDiffuseTexture = true;
        gizmoMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHATESTANDBLEND;
        gizmoMaterial.backFaceCulling = false;
        
        gizmoPlane.material = gizmoMaterial;
        
        console.log('Professional arrow gizmo created with manual camera orientation');
        console.log('Camera direction:', cameraDirection);
        console.log('Gizmo position:', gizmoPlane.position);
        
        console.log('PNG arrow sprite created with transparency');
        
        // Create invisible interaction plane (larger for easier clicking)
        const interactionPlane = BABYLON.MeshBuilder.CreatePlane('interactionPlane', {
            width: 10,   // Match bigger gizmo
            height: 18   // Match bigger gizmo
        }, this.scene);
        
        interactionPlane.parent = this.extrusionGizmo;
        interactionPlane.position = normal.scale(5); // Same position as gizmo
        interactionPlane.isVisible = false;
        interactionPlane.isPickable = true;
        interactionPlane.billboardMode = BABYLON.Mesh.BILLBOARD_MODE_ALL;
        
        // Store gizmo components
        this.extrusionGizmoComponents = {
            root: this.extrusionGizmo,
            gizmoPlane: gizmoPlane,
            interactionPlane: interactionPlane,
            normal: normal.clone(),
            startPosition: position.clone(),
            canvas: canvas,
            gizmoTexture: gizmoTexture,
            gizmoMaterial: gizmoMaterial
        };
        
        // Set up gizmo interaction
        this.setupSpriteGizmoInteraction();
        
        console.log('2D sprite gizmo created');
    }
    
    drawProfessionalGizmo(ctx, mode) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const centerX = width / 2;
        
        // Clear background to transparent
        ctx.clearRect(0, 0, width, height);
        
        // Shapr3D style: White fill with black outline
        const fillColor = 'white';
        const strokeColor = 'black';
        const strokeWidth = 2;
        
        // Draw main vertical shaft
        ctx.fillStyle = fillColor;
        ctx.fillRect(centerX - 6, 60, 12, height - 120);
        
        // Draw top arrowhead (pointing up - positive extrusion)
        ctx.beginPath();
        ctx.moveTo(centerX, 20); // Arrow tip
        ctx.lineTo(centerX - 15, 60); // Left wing
        ctx.lineTo(centerX - 8, 60); // Inner left
        ctx.lineTo(centerX - 8, 80); // Down to shaft
        ctx.lineTo(centerX + 8, 80); // Across shaft
        ctx.lineTo(centerX + 8, 60); // Up to inner right
        ctx.lineTo(centerX + 15, 60); // Right wing
        ctx.closePath();
        ctx.fill();
        
        // Draw bottom arrowhead (pointing down - negative extrusion)
        ctx.beginPath();
        ctx.moveTo(centerX, height - 20); // Arrow tip
        ctx.lineTo(centerX - 15, height - 60); // Left wing
        ctx.lineTo(centerX - 8, height - 60); // Inner left
        ctx.lineTo(centerX - 8, height - 80); // Up to shaft
        ctx.lineTo(centerX + 8, height - 80); // Across shaft
        ctx.lineTo(centerX + 8, height - 60); // Down to inner right
        ctx.lineTo(centerX + 15, height - 60); // Right wing
        ctx.closePath();
        ctx.fill();
        
        // Draw black outlines
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = strokeWidth;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        
        // Outline the shaft
        ctx.strokeRect(centerX - 6, 60, 12, height - 120);
        
        // Outline top arrowhead
        ctx.beginPath();
        ctx.moveTo(centerX, 20);
        ctx.lineTo(centerX - 15, 60);
        ctx.lineTo(centerX - 8, 60);
        ctx.lineTo(centerX - 8, 80);
        ctx.lineTo(centerX + 8, 80);
        ctx.lineTo(centerX + 8, 60);
        ctx.lineTo(centerX + 15, 60);
        ctx.closePath();
        ctx.stroke();
        
        // Outline bottom arrowhead
        ctx.beginPath();
        ctx.moveTo(centerX, height - 20);
        ctx.lineTo(centerX - 15, height - 60);
        ctx.lineTo(centerX - 8, height - 60);
        ctx.lineTo(centerX - 8, height - 80);
        ctx.lineTo(centerX + 8, height - 80);
        ctx.lineTo(centerX + 8, height - 60);
        ctx.lineTo(centerX + 15, height - 60);
        ctx.closePath();
        ctx.stroke();
    }
    
    setupSpriteGizmoInteraction() {
        if (!this.extrusionGizmoComponents) return;
        
        const interactionPlane = this.extrusionGizmoComponents.interactionPlane;
        let isDragging = false;
        let lastMousePosition = null;
        
        // Mouse down on sprite
        this.gizmoPointerDownObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                const pickInfo = pointerInfo.pickInfo;
                if (pickInfo.hit && pickInfo.pickedMesh === interactionPlane) {
                    isDragging = true;
                    lastMousePosition = {
                        x: this.scene.pointerX,
                        y: this.scene.pointerY
                    };
                    
                    console.log('Sprite gizmo drag started');
                }
            }
        });
        
        // Mouse move during drag
        this.gizmoPointerMoveObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE && isDragging) {
                const currentMousePosition = {
                    x: this.scene.pointerX,
                    y: this.scene.pointerY
                };
                
                if (lastMousePosition) {
                    // Calculate drag distance (Y movement controls extrusion)
                    const deltaY = lastMousePosition.y - currentMousePosition.y;
                    const sensitivity = 0.1;
                    const dragDistance = deltaY * sensitivity;
                    
                    // Update extrusion distance
                    this.extrusionDistance += dragDistance;
                    
                    // Constrain extrusion distance
                    const maxExtrusion = 50;
                    const minExtrusion = -50;
                    this.extrusionDistance = Math.max(minExtrusion, Math.min(maxExtrusion, this.extrusionDistance));
                    
                    // Determine mode based on distance
                    this.extrusionMode = this.extrusionDistance >= 0;
                    
                    // Update sprite color based on direction
                    this.updateSpriteColor();
                    
                    // Update extrusion preview
                    this.updateInteractiveExtrusionPreview();
                    
                    // Update UI
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        const isPositive = this.extrusionDistance > 0;
                        const mode = isPositive ? 'Adding' : 'Cutting';
                        const distance = Math.abs(this.extrusionDistance).toFixed(2);
                        selectionInfo.textContent = `${mode}: ${distance} cm - Release to confirm`;
                    }
                    
                    lastMousePosition = currentMousePosition;
                }
            }
        });
        
        // Mouse up to finish extrusion
        this.gizmoPointerUpObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP && isDragging) {
                isDragging = false;
                lastMousePosition = null;
                
                // Finish extrusion if distance is significant
                if (Math.abs(this.extrusionDistance) > 0.1) {
                    this.finishInteractiveExtrusion();
                } else {
                    // Cancel extrusion if distance too small
                    this.cancelInteractiveExtrusion();
                }
                
                console.log('Sprite gizmo drag ended');
            }
        });
    }
    
    updateSpriteColor() {
        if (!this.extrusionGizmoComponents || !this.extrusionGizmoComponents.canvas) return;
        
        const canvas = this.extrusionGizmoComponents.canvas;
        const ctx = canvas.getContext('2d');
        const isPositive = this.extrusionDistance >= 0;
        
        // Redraw gizmo with new color
        const mode = isPositive ? 'positive' : 'negative';
        this.drawProfessionalGizmo(ctx, mode);
        
        // Update the texture with new canvas data
        const newTexture = new BABYLON.Texture('data:' + canvas.toDataURL(), this.scene);
        this.extrusionGizmoComponents.gizmoMaterial.diffuseTexture = newTexture;
        
        // Dispose old texture to prevent memory leaks
        if (this.extrusionGizmoComponents.gizmoTexture) {
            this.extrusionGizmoComponents.gizmoTexture.dispose();
        }
        this.extrusionGizmoComponents.gizmoTexture = newTexture;
    }
    
    setupBidirectionalGizmoInteraction() {
        if (!this.extrusionGizmoComponents) return;
        
        const dragSphere = this.extrusionGizmoComponents.dragSphere;
        let isDragging = false;
        let lastMousePosition = null;
        
        // Mouse down on gizmo
        this.gizmoPointerDownObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                const pickInfo = pointerInfo.pickInfo;
                if (pickInfo.hit && pickInfo.pickedMesh === dragSphere) {
                    isDragging = true;
                    lastMousePosition = {
                        x: this.scene.pointerX,
                        y: this.scene.pointerY
                    };
                    
                    console.log('Bidirectional gizmo drag started');
                }
            }
        });
        
        // Mouse move during drag
        this.gizmoPointerMoveObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE && isDragging) {
                const currentMousePosition = {
                    x: this.scene.pointerX,
                    y: this.scene.pointerY
                };
                
                if (lastMousePosition) {
                    // Calculate drag distance
                    const deltaY = lastMousePosition.y - currentMousePosition.y;
                    const sensitivity = 0.05;
                    const dragDistance = deltaY * sensitivity;
                    
                    // Update extrusion distance (can be positive or negative)
                    this.extrusionDistance += dragDistance;
                    
                    // Constrain extrusion distance
                    const maxExtrusion = 50; // 50 cm max
                    const minExtrusion = -50; // 50 cm max cut
                    this.extrusionDistance = Math.max(minExtrusion, Math.min(maxExtrusion, this.extrusionDistance));
                    
                    // Determine mode based on distance
                    this.extrusionMode = this.extrusionDistance >= 0;
                    
                    // Update gizmo position
                    this.updateGizmoPosition();
                    
                    // Update extrusion preview
                    this.updateInteractiveExtrusionPreview();
                    
                    // Update UI with dynamic mode based on distance
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        const isPositive = this.extrusionDistance > 0;
                        const mode = isPositive ? 'Adding' : 'Cutting';
                        const distance = Math.abs(this.extrusionDistance).toFixed(2);
                        selectionInfo.textContent = `${mode}: ${distance} cm - Release to confirm`;
                    }
                    
                    // Update gizmo color based on direction
                    this.updateGizmoColorByDirection();
                    
                    // Update preview material based on direction
                    this.updatePreviewMaterial();
                    
                    lastMousePosition = currentMousePosition;
                }
            }
        });
        
        // Mouse up to finish extrusion
        this.gizmoPointerUpObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP && isDragging) {
                isDragging = false;
                lastMousePosition = null;
                
                // Finish extrusion if distance is significant
                if (Math.abs(this.extrusionDistance) > 0.1) {
                    this.finishInteractiveExtrusion();
                } else {
                    // Cancel extrusion if distance too small
                    this.cancelInteractiveExtrusion();
                }
                
                console.log('Bidirectional gizmo drag ended');
            }
        });
    }
    
    updateGizmoColorByDirection() {
        if (!this.extrusionGizmoComponents) return;
        
        const { hub, shaft, arrowheadPos, arrowheadNeg } = this.extrusionGizmoComponents;
        const isPositive = this.extrusionDistance >= 0;
        
        // Create material based on direction
        const gizmoMaterial = new BABYLON.StandardMaterial('gizmoMaterial', this.scene);
        
        if (isPositive) {
            // Green for additive
            gizmoMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);
            gizmoMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.1);
        } else {
            // Red for subtractive
            gizmoMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            gizmoMaterial.emissiveColor = new BABYLON.Color3(0.4, 0.1, 0.1);
        }
        
        // Apply material to all gizmo parts
        hub.material = gizmoMaterial;
        shaft.material = gizmoMaterial;
        arrowheadPos.material = gizmoMaterial;
        arrowheadNeg.material = gizmoMaterial;
    }
    
    updatePreviewMaterial() {
        if (!this.interactiveExtrusionPreview) return;
        
        const isPositive = this.extrusionDistance >= 0;
        const previewMaterial = new BABYLON.StandardMaterial('extrusionPreviewMaterial', this.scene);
        
        if (isPositive) {
            // Green for additive
            previewMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);
        } else {
            // Red for subtractive
            previewMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
        }
        
        previewMaterial.alpha = 0.6;
        previewMaterial.wireframe = true;
        
        this.interactiveExtrusionPreview.material = previewMaterial;
    }
    
    setupGizmoInteraction() {
        if (!this.extrusionGizmoComponents) return;
        
        const dragSphere = this.extrusionGizmoComponents.dragSphere;
        let isDragging = false;
        let lastMousePosition = null;
        
        // Mouse down on gizmo
        this.gizmoPointerDownObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                const pickInfo = pointerInfo.pickInfo;
                if (pickInfo.hit && pickInfo.pickedMesh === dragSphere) {
                    isDragging = true;
                    lastMousePosition = {
                        x: this.scene.pointerX,
                        y: this.scene.pointerY
                    };
                    
                    console.log('Gizmo drag started');
                }
            }
        });
        
        // Mouse move during drag
        this.gizmoPointerMoveObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE && isDragging) {
                const currentMousePosition = {
                    x: this.scene.pointerX,
                    y: this.scene.pointerY
                };
                
                if (lastMousePosition) {
                    // Calculate drag distance
                    const deltaY = lastMousePosition.y - currentMousePosition.y;
                    const sensitivity = 0.05;
                    const dragDistance = deltaY * sensitivity;
                    
                    // Update extrusion distance
                    this.extrusionDistance += dragDistance;
                    
                    // Constrain extrusion distance
                    const maxExtrusion = 50; // 50 cm max
                    const minExtrusion = -50; // 50 cm max cut
                    this.extrusionDistance = Math.max(minExtrusion, Math.min(maxExtrusion, this.extrusionDistance));
                    
                    // Update gizmo position
                    this.updateGizmoPosition();
                    
                    // Update extrusion preview
                    this.updateInteractiveExtrusionPreview();
                    
                    // Update UI with dynamic mode based on distance
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        const isPositive = this.extrusionDistance > 0;
                        const mode = isPositive ? 'Adding' : 'Cutting';
                        const distance = Math.abs(this.extrusionDistance).toFixed(2);
                        selectionInfo.textContent = `${mode}: ${distance} cm - Release to confirm`;
                    }
                    
                    // Update gizmo color based on direction
                    this.updateGizmoColorByDirection();
                    
                    lastMousePosition = currentMousePosition;
                }
            }
        });
        
        // Mouse up to finish extrusion
        this.gizmoPointerUpObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP && isDragging) {
                isDragging = false;
                lastMousePosition = null;
                
                // Finish extrusion if distance is significant
                if (Math.abs(this.extrusionDistance) > 0.1) {
                    this.finishInteractiveExtrusion();
                } else {
                    // Cancel extrusion if distance too small
                    this.cancelInteractiveExtrusion();
                }
                
                console.log('Gizmo drag ended');
            }
        });
    }
    
    updateGizmoPosition() {
        if (!this.extrusionGizmoComponents) return;
        
        const { root, normal, startPosition } = this.extrusionGizmoComponents;
        const offset = normal.scale(this.extrusionDistance);
        root.position = startPosition.add(offset);
    }
    
    createInteractiveExtrusionPreview() {
        // Clean up existing preview
        this.cleanupInteractiveExtrusionPreview();
        
        if (!this.selectedFace) return;
        
        // Get shape data
        const shapeData = this.getShapeData(this.selectedFace);
        if (!shapeData) return;
        
        // Create preview mesh based on shape type
        this.interactiveExtrusionPreview = this.createExtrusionPreviewMesh(shapeData);
        
        if (this.interactiveExtrusionPreview) {
            // Set preview material - initially neutral
            this.updatePreviewMaterial();
            
            console.log('Interactive extrusion preview created');
        }
    }
    
    createExtrusionPreviewMesh(shapeData) {
        // Create a basic preview mesh based on shape type
        // This will be scaled and positioned during interaction
        
        switch (shapeData.type) {
            case 'rectangle':
                return BABYLON.MeshBuilder.CreateBox('extrusionPreview', {
                    width: shapeData.width || 2,
                    height: 0.1, // Start thin
                    depth: shapeData.height || 2
                }, this.scene);
                
            case 'circle':
                return BABYLON.MeshBuilder.CreateCylinder('extrusionPreview', {
                    diameter: (shapeData.radius || 1) * 2,
                    height: 0.1, // Start thin
                    tessellation: 32
                }, this.scene);
                
            case 'ellipse':
                const cylinder = BABYLON.MeshBuilder.CreateCylinder('extrusionPreview', {
                    diameter: (shapeData.radiusX || 1) * 2,
                    height: 0.1, // Start thin
                    tessellation: 32
                }, this.scene);
                cylinder.scaling.x = (shapeData.radiusX || 1) / (shapeData.radiusY || 1);
                return cylinder;
                
            default:
                // Generic box for other shapes
                return BABYLON.MeshBuilder.CreateBox('extrusionPreview', {
                    width: 2,
                    height: 0.1,
                    depth: 2
                }, this.scene);
        }
    }
    
    updateInteractiveExtrusionPreview() {
        if (!this.interactiveExtrusionPreview || !this.extrusionGizmoComponents) return;
        
        const { normal, startPosition } = this.extrusionGizmoComponents;
        
        // Update preview position
        const offset = normal.scale(this.extrusionDistance / 2);
        this.interactiveExtrusionPreview.position = startPosition.add(offset);
        
        // Update preview scale to show extrusion depth
        const depth = Math.abs(this.extrusionDistance);
        
        // Determine which axis represents the extrusion direction based on normal
        if (Math.abs(normal.y) > 0.8) {
            // Extruding along Y axis
            this.interactiveExtrusionPreview.scaling.y = Math.max(0.1, depth);
        } else if (Math.abs(normal.x) > 0.8) {
            // Extruding along X axis
            this.interactiveExtrusionPreview.scaling.x = Math.max(0.1, depth);
        } else {
            // Extruding along Z axis
            this.interactiveExtrusionPreview.scaling.z = Math.max(0.1, depth);
        }
    }
    
    finishInteractiveExtrusion() {
        if (!this.selectedFace || Math.abs(this.extrusionDistance) < 0.1) {
            this.cancelInteractiveExtrusion();
            return;
        }
        
        console.log(`Finishing interactive extrusion: ${this.extrusionDistance} cm`);
        
        // Perform the actual extrusion using the existing system
        const shapeData = this.getShapeData(this.selectedFace);
        if (shapeData) {
            const extrusionHeight = Math.abs(this.extrusionDistance);
            
            switch (shapeData.type) {
                case 'rectangle':
                    this.extrudeRectangle(shapeData, extrusionHeight, this.extrusionMode);
                    break;
                case 'circle':
                    this.extrudeCircle(shapeData, extrusionHeight, this.extrusionMode);
                    break;
                case 'ellipse':
                    this.extrudeEllipse(shapeData, extrusionHeight, this.extrusionMode);
                    break;
                case 'triangle':
                    this.extrudeTriangle(shapeData, extrusionHeight, this.extrusionMode);
                    break;
            }
        }
        
        // Clean up interactive extrusion
        this.cleanupInteractiveExtrusion();
        
        // Deselect face
        this.deselectFace();
        
        console.log('Interactive extrusion completed');
    }
    
    cancelInteractiveExtrusion() {
        console.log('Cancelling interactive extrusion');
        this.cleanupInteractiveExtrusion();
        
        // Update UI
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            selectionInfo.textContent = 'Face selected - Choose extrude operation';
        }
    }
    
    cleanupInteractiveExtrusion() {
        console.log('cleanupInteractiveExtrusion called - re-enabling camera controls');
        
        // Clean up smart camera control system
        this.cleanupSmartCameraControl();
        
        // Clean up billboard behavior
        this.cleanupGizmoBillboard();
        
        // Re-enable camera controls (critical for camera lock issue)
        // this.camera.attachControl(this.canvas, true); // Commented out to prevent conflicts with custom camera controls
        
        // Clean up gizmo
        this.cleanupExtrusionGizmo();
        
        // Clean up preview
        this.cleanupInteractiveExtrusionPreview();
        
        // Reset state
        this.isInteractiveExtruding = false;
        this.extrusionDistance = 0;
        this.extrusionMode = null;
        
        console.log('Interactive extrusion cleaned up - camera controls restored');
    }
    
    cleanupExtrusionGizmo() {
        // Remove event observers
        if (this.gizmoPointerDownObserver) {
            this.scene.onPointerObservable.remove(this.gizmoPointerDownObserver);
            this.gizmoPointerDownObserver = null;
        }
        if (this.gizmoPointerMoveObserver) {
            this.scene.onPointerObservable.remove(this.gizmoPointerMoveObserver);
            this.gizmoPointerMoveObserver = null;
        }
        if (this.gizmoPointerUpObserver) {
            this.scene.onPointerObservable.remove(this.gizmoPointerUpObserver);
            this.gizmoPointerUpObserver = null;
        }
        
        // Dispose gizmo meshes
        if (this.extrusionGizmo) {
            this.extrusionGizmo.dispose();
            this.extrusionGizmo = null;
        }
        
        this.extrusionGizmoComponents = null;
    }
    
    cleanupInteractiveExtrusionPreview() {
        if (this.interactiveExtrusionPreview) {
            this.interactiveExtrusionPreview.dispose();
            this.interactiveExtrusionPreview = null;
        }
    }
    
    // Helper method to get face normal
    getFaceNormal(face) {
        console.log('getFaceNormal called for face:', face.name);
        
        // Calculate normal from face geometry - works for ANY mesh
        const positions = face.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        const indices = face.getIndices();
        
        if (!positions || !indices || indices.length < 3) {
            console.log('Insufficient geometry data, using Y-up normal');
            return new BABYLON.Vector3(0, 1, 0);
        }
        
        // Get first triangle to calculate normal
        const i0 = indices[0] * 3;
        const i1 = indices[1] * 3;
        const i2 = indices[2] * 3;
        
        const v0 = new BABYLON.Vector3(positions[i0], positions[i0 + 1], positions[i0 + 2]);
        const v1 = new BABYLON.Vector3(positions[i1], positions[i1 + 1], positions[i1 + 2]);
        const v2 = new BABYLON.Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
        
        // Calculate face normal using cross product
        const edge1 = v1.subtract(v0);
        const edge2 = v2.subtract(v0);
        const normal = BABYLON.Vector3.Cross(edge1, edge2).normalize();
        
        // Transform to world coordinates
        const worldNormal = BABYLON.Vector3.TransformNormal(normal, face.getWorldMatrix());
        
        console.log('Calculated face normal:', worldNormal);
        return worldNormal;
    }

    // === MATERIALS SYSTEM ===
    async initializeMaterialsSystem() {
        try {
            console.log('Initializing materials system...');
            this.materialsLibrary = new MaterialsLibrary();
            
            // Initialize BoardFactory
            this.boardFactory = new BoardFactory(this.scene, this.materialsLibrary);
            console.log("BoardFactory initialized");
            
            // TEST: Verify Board system is available
            if (typeof Board !== "undefined" && typeof BoardFactory !== "undefined") {
                console.log("✅ Board system loaded successfully");
                console.log("   Board class:", typeof Board);
                console.log("   BoardFactory class:", typeof BoardFactory);
                console.log("   boardFactory instance:", this.boardFactory ? "initialized" : "not initialized");
            } else {
                console.error("❌ Board system failed to load!");
            }
            
            const success = await this.materialsLibrary.loadDatabase();
            if (success) {
                console.log('Materials database loaded successfully');
                this.setupMaterialModalListeners();
            } else {
                console.error('Failed to load materials database');
            }
        } catch (error) {
            console.error('Error initializing materials system:', error);
        }
    }

    setupMaterialModalListeners() {
        // Add Material button click handler (round button at bottom center)
        const addMaterialBtn = document.getElementById('add-material-btn-grid');
        if (addMaterialBtn) {
            addMaterialBtn.addEventListener('click', () => {
                this.openMaterialModal();
            });
        }

        // Close modal handlers
        const closeModalBtn = document.getElementById('close-material-modal');
        const modalOverlay = document.getElementById('material-modal');
        
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', () => {
                this.closeMaterialModal();
            });
        }
        
        if (modalOverlay) {
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    this.closeMaterialModal();
                }
            });
        }

        // Search functionality
        const searchInput = document.getElementById('material-search');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                this.filterMaterials(e.target.value);
            });
        }

        // Material grid click handler (using event delegation)
        const materialGrid = document.getElementById('material-grid');
        if (materialGrid) {
            materialGrid.addEventListener('click', (e) => {
                const materialCard = e.target.closest('.material-card');
                if (materialCard) {
                    const materialId = materialCard.dataset.materialId;
                    this.selectMaterial(materialId);
                }
            });
        }

        // Configuration change handlers
        const configLength = document.getElementById('config-length');
        const configWidth = document.getElementById('config-width');
        const configThickness = document.getElementById('config-thickness');
        const configGrade = document.getElementById('config-grade');

        [configLength, configWidth, configThickness, configGrade].forEach(select => {
            if (select) {
                select.addEventListener('change', () => {
                    this.updateMaterialCost();
                });
            }
        });

        // Add to project button
        const addToProjectBtn = document.getElementById('add-material-to-project');
        if (addToProjectBtn) {
            addToProjectBtn.addEventListener('click', () => {
                this.addMaterialToProject();
            });
        }

        // Cancel configuration button
        const cancelConfigBtn = document.getElementById('cancel-material-config');
        if (cancelConfigBtn) {
            cancelConfigBtn.addEventListener('click', () => {
                this.showMaterialGrid();
            });
        }

        // Include in project button
        const includeInProjectBtn = document.getElementById('include-in-project-btn');
        if (includeInProjectBtn) {
            includeInProjectBtn.addEventListener('click', () => {
                this.includeCurrentPartInProject();
            });
        }
        
        // Back to Work Bench button event handler
        const backToWorkBenchBtn = document.getElementById('back-to-workbench-btn');
        if (backToWorkBenchBtn) {
            backToWorkBenchBtn.addEventListener('click', () => {
                this.sendPartBackToWorkBench();
            });
        }
    }

    openMaterialModal() {
        const modal = document.getElementById('material-modal');
        if (modal && this.materialsLibrary) {
            modal.style.display = 'flex';
            this.populateMaterialCategories();
            this.populateMaterialGrid();
            this.showMaterialGrid();
        }
    }

    closeMaterialModal() {
        const modal = document.getElementById('material-modal');
        if (modal) {
            modal.style.display = 'none';
            this.selectedMaterial = null;
            this.showMaterialGrid();
        }
    }

    showMaterialGrid() {
        const gridDiv = document.getElementById('material-grid');
        const configDiv = document.getElementById('material-config');
        
        if (gridDiv) gridDiv.style.display = 'grid';
        if (configDiv) configDiv.style.display = 'none';
        
        // Clear any selected cards
        document.querySelectorAll('.material-card').forEach(card => {
            card.classList.remove('selected');
        });
    }

    showMaterialConfig() {
        const gridDiv = document.getElementById('material-grid');
        const configDiv = document.getElementById('material-config');
        
        if (gridDiv) gridDiv.style.display = 'none';
        if (configDiv) configDiv.style.display = 'block';
    }

    populateMaterialCategories() {
        const categories = this.materialsLibrary.getCategories();
        const tabsContainer = document.getElementById('material-category-tabs');
        
        if (tabsContainer) {
            tabsContainer.innerHTML = categories.map((category, index) => {
                const activeClass = index === 0 ? 'active' : '';
                return `<button class="category-tab ${activeClass}" data-category="${category.id}">${category.name}</button>`;
            }).join('');

            // Add category click handlers
            tabsContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('category-tab')) {
                    // Update active tab
                    document.querySelectorAll('.category-tab').forEach(tab => tab.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Filter materials
                    const categoryId = e.target.dataset.category;
                    this.populateMaterialGrid(categoryId);
                }
            });
        }
    }

    getMaterialIcon(category) {
        const icons = {
            'hardwood': '🌳',
            'sheet_goods': '📋',
            'softwood': '🌲',
            'exotic': '🌴'
        };
        return icons[category] || '📦';
    }

    filterMaterials(searchTerm) {
        if (!this.materialsLibrary) return;

        const results = this.materialsLibrary.searchMaterials(searchTerm);
        const gridContainer = document.getElementById('material-grid');
        
        if (gridContainer) {
            gridContainer.innerHTML = results.map(material => {
                const summary = this.materialsLibrary.getMaterialSummary(material.material_id);
                const thumbnail = summary.thumbnail || this.getMaterialIcon(material.category);
                
                // Create thumbnail HTML - use image if available, fallback to icon
                const thumbnailHtml = summary.thumbnail ? 
                    `<img src="${summary.thumbnail}" alt="${summary.name}" loading="lazy" onerror="this.style.display='none'">` :
                    thumbnail;
                
                return `
                    <div class="material-card" data-material-id="${material.material_id}">
                        <div class="material-thumbnail">${thumbnailHtml}</div>
                        <div class="material-name">${summary.name}</div>
                        <div class="material-price">$${summary.pricePerBoardFoot}/bf</div>
                    </div>
                `;
            }).join('');
        }
    }

    selectMaterial(materialId) {
        this.selectedMaterial = materialId;
        
        // Mark card as selected
        document.querySelectorAll('.material-card').forEach(card => {
            card.classList.remove('selected');
        });
        document.querySelector(`[data-material-id="${materialId}"]`).classList.add('selected');
        
        // Show configuration panel
        this.showMaterialConfig();
        this.populateConfigOptions(materialId);
        this.updateMaterialCost();
    }

    populateConfigOptions(materialId) {
        const material = this.materialsLibrary.getMaterial(materialId);
        if (!material) return;

        const nameElement = document.getElementById('selected-material-name');
        if (nameElement) {
            nameElement.textContent = `${material.name} Configuration`;
        }

        // Populate dimension options
        // Use actual database schema
        const defaultConfig = material.default_configuration || {};
        const standardLengths = [48, 72, 96, 120, 144];
        const standardWidths = [3, 4, 6, 8, 10, 12];
        const standardThicknesses = [0.75, 1, 1.5, 2, 2.5, 3];

        this.populateSelectOptions('config-length', standardLengths, defaultConfig.length || 96);
        this.populateSelectOptions('config-width', standardWidths, defaultConfig.width || 6);
        this.populateSelectOptions('config-thickness', standardThicknesses, defaultConfig.thickness || 0.75);

        // Populate grade options
        const grades = this.materialsLibrary.getLumberGrades();
        const gradeSelect = document.getElementById('config-grade');
        if (gradeSelect) {
            gradeSelect.innerHTML = Object.entries(grades).map(([gradeId, grade]) => {
                const selected = gradeId === defaultConfig.grade ? 'selected' : '';
                return `<option value="${gradeId}" ${selected}>${grade.name}</option>`;
            }).join('');
        }
    }

    populateSelectOptions(selectId, options, defaultValue) {
        const select = document.getElementById(selectId);
        if (select) {
            select.innerHTML = options.map(option => {
                const selected = option === defaultValue ? 'selected' : '';
                return `<option value="${option}" ${selected}>${option}"</option>`;
            }).join('');
        }
    }

    updateMaterialCost() {
        if (!this.selectedMaterial || !this.materialsLibrary) return;

        const length = parseFloat(document.getElementById('config-length').value);
        const width = parseFloat(document.getElementById('config-width').value);
        const thickness = parseFloat(document.getElementById('config-thickness').value);
        const grade = document.getElementById('config-grade').value;

        const costInfo = this.materialsLibrary.calculateCost(this.selectedMaterial, length, width, thickness, grade);
        
        const costDisplay = document.getElementById('cost-display');
        if (costDisplay && !costInfo.error) {
            costDisplay.innerHTML = `
                <h4>Cost Estimate</h4>
                <div class="cost-details">
                    Material: ${costInfo.material}<br>
                    Dimensions: ${length}" × ${width}" × ${thickness}"<br>
                    Board Feet: ${costInfo.boardFeet} bf<br>
                    Grade: ${grade}
                </div>
                <div class="cost-total">Total: $${costInfo.totalCost}</div>
            `;
        }
    }

    addMaterialToProject() {
        if (!this.selectedMaterial || !this.materialsLibrary || !this.boardFactory) {
            console.error('Cannot add material: missing dependencies');
            return;
        }

        const length = parseFloat(document.getElementById('config-length').value);
        const width = parseFloat(document.getElementById('config-width').value);
        const thickness = parseFloat(document.getElementById('config-thickness').value);
        const grade = document.getElementById('config-grade').value;

        try {
            // Use BoardFactory to create the board
            console.log("About to create board with:", {
                materialId: this.selectedMaterial,
                length: length,
                width: width,
                thickness: thickness,
                grade: grade
            });
            const board = this.boardFactory.createFromMaterial(
                this.selectedMaterial,
                length,
                width,
                thickness,
                grade
            );
            
            // Set to work bench
            board.project.bench = 'work';
            
            // Add to work bench parts (for backward compatibility during transition)
            // Convert Board to old part format temporarily
            const part = {
                id: board.id,
                materialId: board.material.id,
                materialName: board.material.species,
                dimensions: board.getConventionalDimensions(),
                grade: board.material.grade,
                cost: board.economics.total_cost,
                boardFeet: board.economics.board_feet,
                status: 'raw_material',
                bench: 'work',
                createdAt: new Date().toISOString(),
                _board: board  // Keep reference to actual Board object
            };
            
            this.workBenchParts.push(part);
            
            // Switch to work bench and make this the current work part
            this.switchBench('work');
            this.currentWorkPart = part;
            
            // Update UI
            this.updateWorkBenchDisplay();
            
            // The mesh is already created by BoardFactory
            // Position it appropriately
            const spawnPosition = this.findOptimalSpawnPosition(
                board.dimensions.x * 2.54,
                board.dimensions.y * 2.54,
                board.dimensions.z * 2.54
            );
            board.transform.position = {
                x: spawnPosition.x / 2.54,
                y: spawnPosition.y / 2.54,
                z: spawnPosition.z / 2.54
            };
            this.boardFactory.updateMeshTransform(board);
            
            // Close modal
            this.closeMaterialModal();
            
            console.log('✅ Material added to work bench using Board system:', board);
            
        } catch (error) {
            console.error("Failed to add material:", error);
            console.error("Error details:", error.message, error.stack);
            // alert removed - check console for errors
        }
    }

    updatePartsListDisplay() {
        // Update both work bench and project parts displays
        this.updateWorkBenchDisplay();
        this.updateProjectPartsDisplay();
    }

    createMaterialBlock(part) {
        // Convert inches to centimeters (our unit standard)
        const lengthCm = part.dimensions.length * 2.54;
        const widthCm = part.dimensions.width * 2.54;
        const thicknessCm = part.dimensions.thickness * 2.54;

        // Create box geometry
        const box = BABYLON.MeshBuilder.CreateBox(part.id, {
            width: widthCm,
            height: thicknessCm,
            depth: lengthCm
        }, this.scene);

        // Position on the grid/bench
        const xPosition = (this.projectParts.length - 1) * (lengthCm + 5); // Space parts apart
        box.position = new BABYLON.Vector3(xPosition, thicknessCm / 2, 0);

        // Apply material with texture
        box.material = this.getMaterialColor(part.materialId);

        // Store reference
        box.partData = part;
        box.isProjectPart = true;

        console.log(`Created 3D block for ${part.materialName}:`, box);
    }

    getMaterialColor(materialId) {
        const uniqueId = Date.now() + "_" + Math.random().toString(36).substr(2, 9);
        console.log("🎨 Creating unique material for:", materialId, "ID:", uniqueId);
        const material = new BABYLON.StandardMaterial(materialId + "_material_" + uniqueId, this.scene);
        
        
        
        // Try to get texture from materials database
        if (this.materialsLibrary) {
            const materialData = this.materialsLibrary.getMaterial(materialId);
            if (materialData && materialData.visual_assets && materialData.visual_assets.texture_diffuse) {
                console.log("🖼️ Loading texture:", materialData.visual_assets.texture_diffuse);
                
                try {
                    const texture = new BABYLON.Texture(materialData.visual_assets.texture_diffuse, this.scene);
                    material.diffuseTexture = texture;
                    material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Low shine for wood
                    console.log("✅ Texture loaded successfully");
                    return material;
                } catch (error) {
                    console.warn("⚠️ Failed to load texture, falling back to color:", error);
                }
            }
        }
        
        // Fallback to solid colors if texture fails
        const colorMap = {
            'walnut_001': new BABYLON.Color3(0.36, 0.25, 0.22), // Dark brown
            'maple_001': new BABYLON.Color3(0.96, 0.96, 0.86),   // Light cream
            'oak_red_001': new BABYLON.Color3(0.76, 0.60, 0.42), // Medium brown
            'poplar_001': new BABYLON.Color3(0.87, 0.83, 0.69),  // Light tan
            'birch_ply_001': new BABYLON.Color3(0.96, 0.90, 0.83), // Light birch
            'baltic_birch_001': new BABYLON.Color3(0.97, 0.94, 0.89), // Very light
            'sande_ply_001': new BABYLON.Color3(0.90, 0.84, 0.72)  // Medium tan
        };
        
        material.diffuseColor = colorMap[materialId] || new BABYLON.Color3(0.8, 0.8, 0.8);
        console.log("🎨 Using solid color fallback");
        return material;
    }

    // === BENCH SYSTEM METHODS ===
    switchBench(benchType) {
        console.log(`Switching to ${benchType} bench`);
        this.currentBench = benchType;
        
        // Update button states
        document.querySelectorAll('.bench-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`${benchType}-bench-btn`).classList.add('active');
        
        // Show/hide appropriate tool groups
        if (benchType === 'work') {
            document.getElementById('work-bench-tools').style.display = 'block';
            document.getElementById('assembly-bench-tools').style.display = 'none';
            this.showWorkBenchScene();
        } else {
            document.getElementById('work-bench-tools').style.display = 'none';
            document.getElementById('assembly-bench-tools').style.display = 'block';
            this.showAssemblyBenchScene();
            // Make sure assembly parts are created and visible
            this.createAssemblyProjectView();
        }
        
        // Clear any active tool selection
        document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
        this.activeTool = null;
        
        // Clear any drag handles and manipulation buttons when switching benches
        this.clearDragHandles();
        this.clearManipulationButtons();
        
        // Animate camera to optimal viewing position for the bench
        this.animateCameraForBench(benchType);
        
        // Clear loading flag after bench switch (project loading complete)
        setTimeout(() => {
            this.isLoadingProject = false;
            console.log('Project loading complete - camera animations re-enabled');
        }, 100);
    }

    updateWorkBenchDisplay() {
        const workBenchList = document.getElementById('work-bench-list');
        const emptyMessage = document.getElementById('work-bench-empty');
        
        if (workBenchList) {
            if (this.workBenchParts.length === 0) {
                if (emptyMessage) emptyMessage.style.display = 'block';
                workBenchList.innerHTML = '<li class="empty-message">No materials on work bench</li>';
            } else {
                if (emptyMessage) emptyMessage.style.display = 'none';
                workBenchList.innerHTML = this.workBenchParts.map(part => {
                    const currentClass = part === this.currentWorkPart ? 'current-work-part' : '';
                    const thumbnailHtml = part.thumbnail ? 
                        `<img src="${part.thumbnail}" class="part-thumbnail" alt="Part thumbnail">` :
                        `<div class="part-thumbnail-placeholder">📦</div>`;
                    return `
                        <li class="part-item ${currentClass}" data-part-id="${part.id}" onclick="drawingWorld.focusPartInScene('${part.id}')">
                            <div class="part-thumbnail-container">${thumbnailHtml}</div>
                            <div class="part-info">
                                <span class="part-name">${part.materialName}</span>
                                <span class="part-dimensions">${part.dimensions.length.toFixed(2)}" × ${part.dimensions.width.toFixed(2)}" × ${part.dimensions.thickness.toFixed(2)}"</span>
                                <span class="part-status">${part.status || 'Ready'}</span>
                            </div>
                        </li>
                    `;
                }).join('');
            }
        }
    }
    
    /**
     * Focus a part in the 3D scene when selected from project explorer
     */
    focusPartInScene(partId) {
        console.log(`DrawingWorld: Focusing part in scene: ${partId}`);
        
        // Debug: show all meshes with partData
        console.log('DrawingWorld: Available meshes with partData:');
        this.scene.meshes.forEach(mesh => {
            if (mesh.partData) {
                console.log(`  - Mesh: ${mesh.name}, partData.id: ${mesh.partData.id}, mesh.id: ${mesh.id}`);
            }
        });
        
        // Find the mesh with matching partData.id
        const targetMesh = this.scene.meshes.find(mesh => 
            mesh.partData && mesh.partData.id === partId
        );
        
        if (!targetMesh) {
            console.warn(`DrawingWorld: Could not find mesh for part ID: ${partId}`);
            // Try alternative search by mesh.id
            const altMesh = this.scene.meshes.find(mesh => mesh.id === partId);
            if (altMesh) {
                console.log(`DrawingWorld: Found mesh by direct ID match: ${altMesh.name}`);
                return this.focusPartInScene(altMesh.id);
            }
            return;
        }
        
        // Clear current selection
        if (this.selectedPart) {
            this.deselectPart();
        }
        if (this.selectedFace) {
            this.deselectFace();
        }
        
        // Select the target mesh
        this.selectedPart = targetMesh;
        
        // Update visual selection
        if (targetMesh.outlineRenderer) {
            targetMesh.renderOutline = true;
            targetMesh.outlineColor = new BABYLON.Color3(0, 1, 0); // Green outline
            targetMesh.outlineWidth = 0.02;
        }
        
        // Animate camera to focus on the part
        this.animateCameraToFocusPart(targetMesh);
        
        // Update UI to show selection (skip if function doesn't exist)
        if (this.updateSelection) {
            this.updateSelection();
        }
        
        console.log(`DrawingWorld: Focused on part: ${targetMesh.partData.materialName}`);
    }
    
    /**
     * Animate camera to focus on a specific part
     */
    animateCameraToFocusPart(mesh) {
        const meshBounds = mesh.getBoundingInfo();
        const meshSize = meshBounds.maximum.subtract(meshBounds.minimum);
        const meshCenter = mesh.position;
        
        // Calculate optimal camera position - slightly above and to the side
        const distance = Math.max(meshSize.x, meshSize.y, meshSize.z) * 2.5;
        const targetPosition = new BABYLON.Vector3(
            meshCenter.x + distance * 0.7,
            meshCenter.y + distance * 0.5, 
            meshCenter.z + distance * 0.7
        );
        
        // Animate camera smoothly
        BABYLON.Animation.CreateAndStartAnimation(
            "focusCameraPosition",
            this.camera,
            "position",
            60, // 60 fps
            60, // 1 second
            this.camera.position.clone(),
            targetPosition,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.CubicEase()
        );
        
        BABYLON.Animation.CreateAndStartAnimation(
            "focusCameraTarget",
            this.camera,
            "target", 
            60,
            60,
            this.camera.target.clone(),
            meshCenter,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.CubicEase()
        );
    }
    
    /**
     * Generate a 3D thumbnail for a part using screenshot
     */
    generatePartThumbnail(mesh, partData) {
        console.log(`DrawingWorld: Generating thumbnail for ${partData.materialName}`);
        
        // Create a separate camera for thumbnail generation to avoid moving the main camera
        const thumbnailCamera = new BABYLON.ArcRotateCamera(
            "thumbnailCamera",
            0, 0, 0,
            BABYLON.Vector3.Zero(),
            this.scene
        );
        
        // Position thumbnail camera for isometric style
        const meshBounds = mesh.getBoundingInfo();
        const meshSize = meshBounds.maximum.subtract(meshBounds.minimum);
        const meshCenter = mesh.position;
        
        const distance = Math.max(meshSize.x, meshSize.y, meshSize.z) * 1.8;
        thumbnailCamera.position = new BABYLON.Vector3(
            meshCenter.x + distance * 0.8,
            meshCenter.y + distance * 0.6,
            meshCenter.z + distance * 0.8
        );
        thumbnailCamera.target = meshCenter;
        
        // Hide all other meshes temporarily
        const otherMeshes = this.scene.meshes.filter(m => 
            m !== mesh && m.isVisible && !m.name.includes('grid')
        );
        otherMeshes.forEach(m => m.isVisible = false);
        
        // Generate thumbnail using the separate camera (no main camera movement!)
        setTimeout(() => {
            BABYLON.ScreenshotTools.CreateScreenshot(
                this.engine,
                thumbnailCamera,
                { width: 128, height: 128 },
                (data) => {
                    partData.thumbnail = data;
                    console.log(`DrawingWorld: Generated thumbnail for ${partData.materialName}`);
                    
                    // Update the project explorer to show the new thumbnail
                    this.updateWorkBenchDisplay();
                    
                    // Restore scene state and cleanup
                    otherMeshes.forEach(m => m.isVisible = true);
                    thumbnailCamera.dispose(); // Clean up the temporary camera
                }
            );
        }, 200); // Brief delay to ensure proper render
    }

    updateProjectPartsDisplay() {
        const projectPartsList = document.getElementById('project-parts-list');
        const emptyMessage = document.getElementById('project-parts-empty');
        
        if (projectPartsList) {
            if (this.projectParts.length === 0) {
                if (emptyMessage) emptyMessage.style.display = 'block';
                projectPartsList.innerHTML = '<li class="empty-message">No parts in project</li>';
            } else {
                if (emptyMessage) emptyMessage.style.display = 'none';
                projectPartsList.innerHTML = this.projectParts.map(part => {
                    return `
                        <li class="part-item" data-part-id="${part.id}">
                            <span class="part-name">${part.materialName}</span>
                            <span class="part-dimensions">${part.dimensions.length}" × ${part.dimensions.width}" × ${part.dimensions.thickness}"</span>
                            <span class="part-status">${part.status}</span>
                        </li>
                    `;
                }).join('');
            }
        }
    }

    /**
     * Serialize mesh geometry to preserve modifications like cuts, routing, etc.
     * Captures vertex data, indices, normals, and other mesh properties
     */
    serializeMeshGeometry(mesh) {
        if (!mesh) return null;
        
        try {
            // Get vertex data
            const vertices = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
            const indices = mesh.getIndices();
            
            // Get transform data
            const position = mesh.position.clone();
            const rotation = mesh.rotation.clone();
            const scaling = mesh.scaling.clone();
            
            // Get material properties
            const materialData = mesh.material ? {
                diffuseColor: mesh.material.diffuseColor ? {
                    r: mesh.material.diffuseColor.r,
                    g: mesh.material.diffuseColor.g,
                    b: mesh.material.diffuseColor.b
                } : null,
                name: mesh.material.name
            } : null;
            
            const geometryData = {
                vertices: vertices ? Array.from(vertices) : null,
                normals: normals ? Array.from(normals) : null,
                indices: indices ? Array.from(indices) : null,
                position: { x: position.x, y: position.y, z: position.z },
                rotation: { x: rotation.x, y: rotation.y, z: rotation.z },
                scaling: { x: scaling.x, y: scaling.y, z: scaling.z },
                material: materialData,
                hasCustomGeometry: vertices !== null // Flag to indicate if this has modified geometry
            };
            
            console.log('Serialized mesh geometry:', geometryData);
            return geometryData;
            
        } catch (error) {
            console.error('Error serializing mesh geometry:', error);
            return null;
        }
    }
    
    /**
     * Restore mesh geometry from serialized data
     * Recreates the mesh with preserved modifications
     */
    restoreMeshGeometry(meshData, newMeshId) {
        if (!meshData || !meshData.hasCustomGeometry) {
            return null; // No custom geometry to restore
        }
        
        try {
            // Create new mesh
            const mesh = new BABYLON.Mesh(newMeshId, this.scene);
            
            // Restore geometry
            if (meshData.vertices) {
                mesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, meshData.vertices);
            }
            if (meshData.normals) {
                mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, meshData.normals);
            }
            if (meshData.indices) {
                mesh.setIndices(meshData.indices);
            }
            
            
            // CRITICAL FIX: Generate UV coordinates for ANY mesh geometry
            if (!mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {
                console.log("🔧 Generating UV coordinates for restored mesh");
                const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                if (positions) {
                    const uvs = [];
                    const vertexCount = positions.length / 3;
                    
                    // Generate stretched UV mapping - grain runs along LENGTH
                    const bounds = mesh.getBoundingInfo();
                    const min = bounds.minimum;
                    const max = bounds.maximum;
                    const sizeX = Math.abs(max.x - min.x);
                    const sizeZ = Math.abs(max.z - min.z);
                    
                    // Grain should run along the LONGER dimension
                    const grainAlongX = sizeX > sizeZ;
                    
                    for (let i = 0; i < vertexCount; i++) {
                        const x = positions[i * 3];
                        const z = positions[i * 3 + 2];
                        
                        let u, v;
                        if (grainAlongX) {
                            // X is length (grain direction), Z is width
                            u = (x - min.x) / sizeX;  // Grain along X (0-1)
                            v = (z - min.z) / sizeZ;  // Width along Z (0-1)
                        } else {
                            // Z is length (grain direction), X is width
                            u = (z - min.z) / sizeZ;  // Grain along Z (0-1)
                            v = (x - min.x) / sizeX;  // Width along X (0-1)
                        }
                        uvs.push(u, v);
                    }
                    
                    mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);
                    console.log("✅ UV coordinates generated for", vertexCount, "vertices");
                } else {
                    console.warn("⚠️ No position data found for UV generation");
                }
            }
            // Restore transforms
            mesh.position = new BABYLON.Vector3(meshData.position.x, meshData.position.y, meshData.position.z);
            mesh.rotation = new BABYLON.Vector3(meshData.rotation.x, meshData.rotation.y, meshData.rotation.z);
            mesh.scaling = new BABYLON.Vector3(meshData.scaling.x, meshData.scaling.y, meshData.scaling.z);
            
            // Restore material
            if (meshData.material) {
                const material = new BABYLON.StandardMaterial(meshData.material.name || "restored_material", this.scene);
        // Apply material with texture
                if (meshData.material.diffuseColor) {
                    material.diffuseColor = new BABYLON.Color3(
                        meshData.material.diffuseColor.r,
                        meshData.material.diffuseColor.g,
                        meshData.material.diffuseColor.b
                    );
                }
                // CRITICAL FIX: Load texture from materials library for restored boards
                const materialName = meshData.material.name;
                if (materialName && this.materialsLibrary) {
                    const materialId = materialName.split("_material_")[0];
                    const materialData = this.materialsLibrary.getMaterial(materialId);
                    if (materialData && materialData.visual_assets && materialData.visual_assets.texture_diffuse) {
                        try {
                            const texture = new BABYLON.Texture(materialData.visual_assets.texture_diffuse, this.scene);
                            material.diffuseTexture = texture;
                            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        } catch (error) {
                            console.warn("Failed to load texture for restored mesh:", error);
                        }
                    }
                }
                
                mesh.material = material;
            }
            
            console.log('Restored mesh geometry from serialized data:', mesh);
            return mesh;
            
        } catch (error) {
            console.error('Error restoring mesh geometry:', error);
            return null;
        }
    }

    createWorkBenchMaterial(part, isRestoring = false) {
        // DON'T clear existing materials - allow multiple boards on work bench
        
        let box;
        
        // CRITICAL: Check if part has preserved geometry from previous modifications
        if (part.meshGeometry && part.meshGeometry.hasCustomGeometry) {
            box = this.restoreMeshGeometry(part.meshGeometry, part.id);
            
            // CRITICAL FIX: Replace restored material with properly textured material
            if (box && box.material) {
                console.log("🔧 Replacing restored material with textured material for:", part.materialName);
                box.material = this.getMaterialColor(part.materialId);
            }
        }
        
        // If no preserved geometry or restoration failed, create default box
        if (!box) {
            
            // Convert inches to centimeters (our unit standard)
            const lengthCm = part.dimensions.length * 2.54;
            const widthCm = part.dimensions.width * 2.54;
            const thicknessCm = part.dimensions.thickness * 2.54;

            // Create box geometry
            box = BABYLON.MeshBuilder.CreateBox(part.id, {
                width: widthCm,
                height: thicknessCm,
                depth: lengthCm
            }, this.scene);
            
            // Create material-specific appearance for new boxes
        // Apply material with texture
            box.material = this.getMaterialColor(part.materialId);

        }

        // Smart positioning: preserve saved position when restoring, use spawn position for new parts
        if (isRestoring && part.meshGeometry && part.meshGeometry.position) {
            // CRITICAL: Restore saved position for loaded parts
            box.position = new BABYLON.Vector3(
                part.meshGeometry.position.x,
                part.meshGeometry.position.y,
                part.meshGeometry.position.z
            );
            console.log('Restored saved position for', part.materialName, ':', box.position);
        } else {
            // Use spawn position for new parts or when not restoring
            const lengthCm = part.dimensions.length * 2.54;
            const widthCm = part.dimensions.width * 2.54;
            const thicknessCm = part.dimensions.thickness * 2.54;
            
            const spawnPosition = this.findOptimalSpawnPosition(lengthCm, widthCm, thicknessCm);
            box.position = spawnPosition;
            console.log('Using spawn position for', isRestoring ? 'restored part without saved position' : 'new part', part.materialName, ':', box.position);
        }

        // Only create material if it doesn't already exist (restored geometry has its own material)
        if (!box.material) {
        // Apply material with texture
            box.material = this.getMaterialColor(part.materialId);

        }

        // Store reference
        box.partData = part;
        box.isWorkBenchPart = true;

        // PREVENT FIRST-SELECTION HOP: Force bounding info computation during creation
        // This ensures expensive computations happen now, not during first selection
        box.computeWorldMatrix(true);
        box.getBoundingInfo();

        console.log(`Created work bench material for ${part.materialName}:`, box);
        
        // DISABLED: Generate thumbnail - causes grid to shrink to thumbnail size during cuts
        // if (!this.isLoadingProject) {
        //     this.generatePartThumbnail(box, part);
        // }
        
        // DRAMATIC REVEAL: Animate camera to showcase the new material (skip during loading)
        if (!this.isLoadingProject) {
            this.animateCameraToShowcaseMaterial(box, part);
        }
        

        // 🔍 BOARD INTEGRITY AUDIT - Validate this board is ready for any operation
        const auditContext = isRestoring ? "RESTORE" : "CREATE";
        this.auditBoardIntegrity(box, part, auditContext);

        // Return the created mesh
        return box;
    }
    /**
     * 🔍 BOARD INTEGRITY AUDIT SYSTEM
     * Validates that every created board has complete characteristics
     * and is ready for any operation like a library-added board
     */
    auditBoardIntegrity(board, partData, context) {
        context = context || "unknown";
        console.log("🔍 " + context.toUpperCase() + " BOARD AUDIT: " + partData.materialName);
        
        const issues = [];
        
        // 1. MATERIAL PROPERTIES AUDIT
        if (!partData.materialId) issues.push("❌ Missing materialId");
        if (!partData.materialName) issues.push("❌ Missing materialName");
        if (!partData.grade) issues.push("❌ Missing grade");
        
        // 2. DIMENSIONAL INTEGRITY AUDIT  
        if (!partData.dimensions || typeof partData.dimensions !== "object") {
            issues.push("❌ Missing or invalid dimensions object");
        } else {
            if (!partData.dimensions.length || partData.dimensions.length <= 0) issues.push("❌ Invalid length");
            if (!partData.dimensions.width || partData.dimensions.width <= 0) issues.push("❌ Invalid width");  
            if (!partData.dimensions.thickness || partData.dimensions.thickness <= 0) issues.push("❌ Invalid thickness");
        }
        
        // 3. 3D MESH INTEGRITY AUDIT
        if (!board) {
            issues.push("❌ Missing 3D mesh object");
        } else {
            if (!board.material) issues.push("❌ Missing material assignment");
            if (!board.position) issues.push("❌ Missing position");
            if (!board.scaling) issues.push("❌ Missing scaling");
            if (!board.id) issues.push("❌ Missing mesh ID");
        }
        
        // 4. MATERIALS LIBRARY INTEGRATION AUDIT
        if (this.materialsLibrary) {
            const materialData = this.materialsLibrary.getMaterial(partData.materialId);
            if (!materialData) {
                issues.push("❌ Material not found in materials library");
            } else {
                // Check if texture should be available
                if (materialData.visual_assets && materialData.visual_assets.texture_diffuse) {
                    if (board && board.material && !board.material.diffuseTexture) {
                        issues.push("⚠️ Texture available but not applied");
                    }
                }
            }
        }
        
        // 5. UNIQUE IDENTITY AUDIT
        if (!partData.id) issues.push("❌ Missing unique part ID");
        
        // 6. TOOL READINESS AUDIT (Check if board can be manipulated)
        if (board && board.material) {
            const materialName = board.material.name;
            if (!materialName || materialName === "material") {
                issues.push("❌ Generic material name - may cause tool conflicts");
            }
        }
        
        // AUDIT RESULTS
        if (issues.length === 0) {
            console.log("✅ " + context.toUpperCase() + " AUDIT PASSED: " + partData.materialName + " is fully operational");
            console.log("   📏 Dimensions: " + partData.dimensions.length + "x" + partData.dimensions.width + "x" + partData.dimensions.thickness);
            console.log("   🎨 Material: " + partData.materialId + " (" + partData.grade + ")");
            console.log("   🆔 ID: " + partData.id);
            return true;
        } else {
            console.error("❌ " + context.toUpperCase() + " AUDIT FAILED: " + partData.materialName);
            issues.forEach(function(issue) { console.error("   " + issue); });
            console.error("   🚨 This board may not be ready for all operations!");
            return false;
        }
    }


    /**
     * DRAMATIC CAMERA SWOOP: Cinematic approach to new material
     * Swoops in perpendicular to long dimension at 28-degree angle
     * Smooth, professional animation that showcases the workpiece dramatically
     */
    animateCameraToShowcaseMaterial(mesh, part) {
        console.log(`🎬 DRAMATIC CAMERA SWOOP - Approaching ${part.materialName} perpendicular to long dimension`);
        console.log(`🎥 Swooping to 28-degree cinematic angle for ${part.materialName} - dramatic and professional`);
        
        // Calculate optimal camera position for dramatic reveal
        const meshBounds = mesh.getBoundingInfo();
        const meshSize = meshBounds.maximum.subtract(meshBounds.minimum);
        const meshCenter = mesh.position;
        
        // Calculate distance based on lumber size for perfect framing - FILL THE SCREEN
        const maxDimension = Math.max(meshSize.x, meshSize.y, meshSize.z);
        
        // DEBUG: Log the mesh dimensions to understand the scale
        console.log(`🔍 Mesh dimensions: ${meshSize.x.toFixed(1)} x ${meshSize.y.toFixed(1)} x ${meshSize.z.toFixed(1)} cm`);
        console.log(`🔍 Max dimension: ${maxDimension.toFixed(1)} cm`);
        
        // DRAMATIC SWOOP: Calculate distances for cinematic approach
        const startDistance = Math.max(maxDimension * 1.8, 90); // 50% further away for dramatic start
        const finalDistance = Math.max(maxDimension * 0.9, 45); // Closer to edges of display
        
        console.log(`🎬 Start distance: ${startDistance.toFixed(1)} cm, Final distance: ${finalDistance.toFixed(1)} cm`);
        
        // Determine the long dimension to approach perpendicular to it
        const isLengthLonger = meshSize.x > meshSize.z;
        const longDimension = isLengthLonger ? meshSize.x : meshSize.z;
        
        console.log(`🔍 Long dimension: ${longDimension.toFixed(1)} cm (${isLengthLonger ? 'X' : 'Z'} axis)`);
        
        // Position camera perpendicular to long dimension at 28-degree angle
        const angleRad = (28 * Math.PI) / 180; // 28 degrees - perfect cinematic angle
        
        // Calculate start position (far away)
        const startHeightFromAngle = startDistance * Math.sin(angleRad);
        const startHorizontalDistance = startDistance * Math.cos(angleRad);
        
        // Calculate final position (closer to edges)
        const finalHeightFromAngle = finalDistance * Math.sin(angleRad);
        const finalHorizontalDistance = finalDistance * Math.cos(angleRad);
        
        let startCameraOffset, finalCameraOffset;
        if (isLengthLonger) {
            // Long dimension is X, approach from Z side
            startCameraOffset = new BABYLON.Vector3(0, startHeightFromAngle, startHorizontalDistance);
            finalCameraOffset = new BABYLON.Vector3(0, finalHeightFromAngle, finalHorizontalDistance);
        } else {
            // Long dimension is Z, approach from X side  
            startCameraOffset = new BABYLON.Vector3(startHorizontalDistance, startHeightFromAngle, 0);
            finalCameraOffset = new BABYLON.Vector3(finalHorizontalDistance, finalHeightFromAngle, 0);
        }
        
        const startCameraPosition = meshCenter.add(startCameraOffset);
        const finalCameraPosition = meshCenter.add(finalCameraOffset);
        
        // Store current camera state
        const currentPosition = this.camera.position.clone();
        const currentTarget = this.camera.getTarget().clone();
        
        // DEBUG: Log camera positions
        console.log(`🔍 Mesh center: (${meshCenter.x.toFixed(1)}, ${meshCenter.y.toFixed(1)}, ${meshCenter.z.toFixed(1)})`);
        console.log(`🔍 Camera journey: Start (${startCameraPosition.x.toFixed(1)}, ${startCameraPosition.y.toFixed(1)}, ${startCameraPosition.z.toFixed(1)}) → Final (${finalCameraPosition.x.toFixed(1)}, ${finalCameraPosition.y.toFixed(1)}, ${finalCameraPosition.z.toFixed(1)})`);
        
        // Calculate distances
        const startDistanceToMesh = BABYLON.Vector3.Distance(startCameraPosition, meshCenter);
        const finalDistanceToMesh = BABYLON.Vector3.Distance(finalCameraPosition, meshCenter);
        console.log(`🔍 Distance journey: ${startDistanceToMesh.toFixed(1)} cm → ${finalDistanceToMesh.toFixed(1)} cm`);
        
        // DRAMATIC SWOOP with custom slow-fast-slow curve (10-60-30)
        const animationDuration = 120; // 2 seconds at 60fps for more dramatic effect
        
        // Custom easing function: slow-fast-slow (10-60-30 distribution)
        const dramaticEase = (t) => {
            if (t < 0.1) {
                // First 10% - very slow start
                return 0.05 * t / 0.1; // Only move 5% in first 10% of time
            } else if (t < 0.7) {
                // Next 60% - fast middle section  
                const normalizedT = (t - 0.1) / 0.6; // 0 to 1 over 60% of time
                return 0.05 + 0.9 * normalizedT; // Move 90% in middle 60% of time
            } else {
                // Last 30% - slow end
                const normalizedT = (t - 0.7) / 0.3; // 0 to 1 over last 30% of time
                return 0.95 + 0.05 * normalizedT; // Move last 5% in final 30% of time
            }
        };
        
        // Step 0: Stop any existing camera animations to prevent conflicts
        this.scene.stopAnimation(this.camera);
        
        // Step 1: Move to dramatic start position immediately
        this.camera.position = startCameraPosition;
        this.camera.setTarget(meshCenter);
        
        // Step 2: Animate smooth swoop to final position with custom easing
        const positionAnimation = BABYLON.Animation.CreateAndStartAnimation(
            "dramaticSwoop",
            this.camera,
            "position",
            60,
            animationDuration,
            startCameraPosition,
            finalCameraPosition,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.BezierCurveEase(0.1, 0, 0.9, 1), // Custom dramatic curve
            () => {
                console.log(`🎬 Dramatic swoop complete for ${part.materialName} - cinematic perfection!`);
            }
        );
    }
    
    /**
     * Find optimal spawn position in front of camera on XY grid
     * Avoids placing materials on top of existing objects
     */
    findOptimalSpawnPosition(lengthCm, widthCm, thicknessCm) {
        // Get camera forward direction projected onto XY plane
        const cameraForward = this.camera.getForwardRay().direction;
        const forwardXZ = new BABYLON.Vector3(cameraForward.x, 0, cameraForward.z).normalize();
        
        // Start at a reasonable distance in front of camera (2-3 meters)
        const baseDistance = 200; // 2 meters in cm
        const cameraPosition = this.camera.position;
        
        // Project camera position onto XY grid (Y=0)
        const cameraGroundPos = new BABYLON.Vector3(cameraPosition.x, 0, cameraPosition.z);
        
        // Calculate base spawn position
        let targetPosition = cameraGroundPos.add(forwardXZ.scale(baseDistance));
        
        // Snap to grid if grid is enabled
        if (this.grid && this.gridSpacing) {
            const gridSize = this.gridSpacing;
            targetPosition.x = Math.round(targetPosition.x / gridSize) * gridSize;
            targetPosition.z = Math.round(targetPosition.z / gridSize) * gridSize;
        }
        
        // Set Y position to place material on ground
        targetPosition.y = thicknessCm / 2;
        
        // Check for collisions with existing work bench parts
        const existingParts = this.scene.meshes.filter(m => m.isWorkBenchPart);
        const searchRadius = Math.max(lengthCm, widthCm) + 20; // Part size + 20cm clearance
        const maxDistance = 500; // Don't search beyond 5 meters
        
        // Find the nearest available position
        for (let distance = baseDistance; distance <= maxDistance; distance += 50) {
            // Try positions in a spiral pattern around the base position
            const searchPositions = this.generateSearchPositions(cameraGroundPos, forwardXZ, distance, 8);
            
            for (let searchPos of searchPositions) {
                // Snap to grid
                if (this.grid && this.gridSpacing) {
                    const gridSize = this.gridSpacing;
                    searchPos.x = Math.round(searchPos.x / gridSize) * gridSize;
                    searchPos.z = Math.round(searchPos.z / gridSize) * gridSize;
                }
                searchPos.y = thicknessCm / 2;
                
                // Check if this position is clear of existing parts
                const isPositionClear = existingParts.every(part => {
                    const distance = BABYLON.Vector3.Distance(searchPos, part.position);
                    return distance > searchRadius;
                });
                
                if (isPositionClear) {
                    console.log(`DrawingWorld: Found optimal spawn position at (${searchPos.x.toFixed(1)}, ${searchPos.y.toFixed(1)}, ${searchPos.z.toFixed(1)})`);
                    return searchPos;
                }
            }
        }
        
        // Fallback: use old method if no clear position found
        console.log('DrawingWorld: No clear position found, using fallback positioning');
        const existingWorkBenchParts = this.scene.meshes.filter(m => m.isWorkBenchPart);
        const xOffset = existingWorkBenchParts.length * (lengthCm + 10);
        return new BABYLON.Vector3(xOffset, thicknessCm / 2, 0);
    }
    
    /**
     * Generate search positions in a pattern around the base position
     */
    generateSearchPositions(basePos, forwardDir, distance, numPositions) {
        const positions = [];
        
        // Primary position: straight forward
        positions.push(basePos.add(forwardDir.scale(distance)));
        
        // Generate positions in a circle around the forward direction
        for (let i = 1; i < numPositions; i++) {
            const angle = (i / (numPositions - 1)) * Math.PI * 2;
            const offsetDir = new BABYLON.Vector3(
                Math.cos(angle),
                0,
                Math.sin(angle)
            );
            const position = basePos.add(forwardDir.scale(distance * 0.7)).add(offsetDir.scale(distance * 0.5));
            positions.push(position);
        }
        
        return positions;
    }

    /**
     * Find optimal position for assembly parts - prioritizes origin with collision avoidance
     */
    findOptimalAssemblyPosition(lengthCm, widthCm, thicknessCm, partIndex) {
        // For the most recently added part (last in array), try to place at origin
        // For existing parts, use their current positions or fallback spacing
        
        // Start with origin position
        let targetPosition = new BABYLON.Vector3(0, thicknessCm / 2, 0);
        
        // Get existing assembly parts to check for collisions
        const existingParts = this.scene.meshes.filter(m => m.isProjectPart);
        const searchRadius = Math.max(lengthCm, widthCm) + 20; // Part size + 20cm clearance
        
        // Generate search positions in expanding pattern from origin
        const searchPositions = this.generateAssemblySearchPositions(lengthCm, widthCm, thicknessCm);
        
        // Find the first available position
        for (let searchPos of searchPositions) {
            // Check if this position is clear of existing parts
            const isPositionClear = existingParts.every(part => {
                const distance = BABYLON.Vector3.Distance(searchPos, part.position);
                return distance > searchRadius;
            });
            
            if (isPositionClear) {
                console.log(`Assembly: Found optimal position at (${searchPos.x.toFixed(1)}, ${searchPos.y.toFixed(1)}, ${searchPos.z.toFixed(1)})`);
                return searchPos;
            }
        }
        
        // Fallback: use original linear arrangement if no clear position found
        console.log('Assembly: Using fallback linear positioning');
        const xPosition = partIndex * (lengthCm + 10);
        return new BABYLON.Vector3(xPosition, thicknessCm / 2, 0);
    }
    
    /**
     * Generate search positions for assembly parts in concentric pattern around origin
     */
    generateAssemblySearchPositions(lengthCm, widthCm, thicknessCm) {
        const positions = [];
        const baseY = thicknessCm / 2;
        
        // Start with origin
        positions.push(new BABYLON.Vector3(0, baseY, 0));
        
        // Generate positions in expanding concentric circles
        const rings = 5; // Number of concentric rings to search
        const pointsPerRing = 8; // Points around each ring
        
        for (let ring = 1; ring <= rings; ring++) {
            const radius = ring * Math.max(lengthCm, widthCm) * 0.7; // Ring spacing
            
            for (let i = 0; i < pointsPerRing; i++) {
                const angle = (i / pointsPerRing) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                positions.push(new BABYLON.Vector3(x, baseY, z));
            }
        }
        
        // Add some linear positions as backup
        for (let i = 1; i <= 10; i++) {
            const spacing = Math.max(lengthCm, widthCm) + 20;
            positions.push(new BABYLON.Vector3(i * spacing, baseY, 0)); // Along X axis
            positions.push(new BABYLON.Vector3(0, baseY, i * spacing)); // Along Z axis
        }
        
        return positions;
    }

    /**
     * Animate camera to optimal viewing position when switching benches
     * Focuses on most recent item or shows all parts optimally
     */
    animateCameraForBench(benchType) {
        // Skip camera animation during project loading
        if (this.isLoadingProject) {
            console.log(`Skipping camera animation for ${benchType} bench (project loading)`);
            return;
        }
        
        console.log(`Animating camera for ${benchType} bench`);
        
        let targetParts = [];
        let mostRecentPart = null;
        
        if (benchType === 'work') {
            // Work bench: focus on work bench parts
            targetParts = this.scene.meshes.filter(m => m.isWorkBenchPart && m.isEnabled());
            mostRecentPart = this.workBenchParts[this.workBenchParts.length - 1];
        } else {
            // Assembly bench: focus on project parts
            targetParts = this.scene.meshes.filter(m => m.isProjectPart && m.isEnabled());
            mostRecentPart = this.projectParts[this.projectParts.length - 1];
        }
        
        if (targetParts.length === 0) {
            // No parts on this bench - animate to origin
            this.animateCameraToOrigin();
            return;
        }
        
        if (targetParts.length === 1) {
            // Single part - focus on it
            this.animateCameraToFocusPart(targetParts[0]);
            return;
        }
        
        // Multiple parts - choose between focusing on most recent or showing all
        if (mostRecentPart) {
            // Find mesh for most recent part
            const recentMesh = targetParts.find(m => m.partData && m.partData.id === mostRecentPart.id);
            if (recentMesh) {
                console.log(`Focusing camera on most recent part: ${mostRecentPart.materialName}`);
                this.animateCameraToFocusPart(recentMesh);
                return;
            }
        }
        
        // Fallback: show all parts optimally
        this.animateCameraToShowAllParts(targetParts);
    }
    
    /**
     * Animate camera to origin position
     */
    animateCameraToOrigin() {
        console.log('Animating camera to origin');
        
        const targetPosition = new BABYLON.Vector3(200, 150, 200); // Good overview position
        const targetTarget = new BABYLON.Vector3(0, 0, 0); // Look at origin
        
        // Animate camera position
        BABYLON.Animation.CreateAndStartAnimation(
            "cameraToOrigin",
            this.camera,
            "position",
            60, // 60 fps
            90, // 1.5 seconds
            this.camera.position.clone(),
            targetPosition,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.CubicEase()
        );
        
        // Animate camera target
        BABYLON.Animation.CreateAndStartAnimation(
            "cameraTargetToOrigin",
            this.camera,
            "target",
            60,
            90,
            this.camera.getTarget().clone(),
            targetTarget,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.CubicEase(),
            () => {
                // After animation, ensure radius is properly set
                this.camera.setTarget(targetTarget);
                const distance = BABYLON.Vector3.Distance(this.camera.position, targetTarget);
                this.camera.radius = Math.max(200, distance); // Ensure minimum radius of 200
                console.log('animateCameraToOrigin: Animation complete, radius set to:', this.camera.radius);
                
                // Force grid update after camera change
                if (this.grid && this.grid.updateDynamicGrid) {
                    this.grid.updateDynamicGrid();
                    console.log('animateCameraToOrigin: Forced grid update');
                }
            }
        );
    }
    
    /**
     * Animate camera to show all parts optimally
     */
    animateCameraToShowAllParts(parts) {
        if (parts.length === 0) {
            this.animateCameraToOrigin();
            return;
        }
        
        console.log(`Animating camera to show ${parts.length} parts optimally`);
        
        // Calculate bounding box of all parts
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        
        parts.forEach(part => {
            const bounds = part.getBoundingInfo();
            const min = bounds.minimum;
            const max = bounds.maximum;
            
            minX = Math.min(minX, min.x);
            maxX = Math.max(maxX, max.x);
            minY = Math.min(minY, min.y);
            maxY = Math.max(maxY, max.y);
            minZ = Math.min(minZ, min.z);
            maxZ = Math.max(maxZ, max.z);
        });
        
        // Calculate center and size of all parts
        const center = new BABYLON.Vector3(
            (minX + maxX) / 2,
            (minY + maxY) / 2,
            (minZ + maxZ) / 2
        );
        
        const size = new BABYLON.Vector3(
            maxX - minX,
            maxY - minY,
            maxZ - minZ
        );
        
        // Calculate optimal camera distance to show all parts
        const maxDimension = Math.max(size.x, size.y, size.z);
        const distance = maxDimension * 2.5; // Generous view
        
        // Position camera at 45-degree angle for good perspective
        const targetPosition = new BABYLON.Vector3(
            center.x + distance * 0.7,
            center.y + distance * 0.6,
            center.z + distance * 0.7
        );
        
        // Animate camera position
        BABYLON.Animation.CreateAndStartAnimation(
            "cameraToShowAll",
            this.camera,
            "position",
            60,
            90,
            this.camera.position.clone(),
            targetPosition,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.CubicEase()
        );
        
        // Animate camera target to center of parts
        BABYLON.Animation.CreateAndStartAnimation(
            "cameraTargetToShowAll",
            this.camera,
            "target",
            60,
            90,
            this.camera.getTarget().clone(),
            center,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            new BABYLON.CubicEase()
        );
    }

    showIncludeInProjectButton() {
        const includeBtn = document.getElementById('include-in-project-btn');
        if (includeBtn) {
            includeBtn.style.display = 'block';
        }
    }

    hideIncludeInProjectButton() {
        const includeBtn = document.getElementById('include-in-project-btn');
        if (includeBtn) {
            includeBtn.style.display = 'none';
        }
    }

    showBackToWorkBenchButton() {
        const backBtn = document.getElementById('back-to-workbench-btn');
        if (backBtn) {
            backBtn.style.display = 'block';
        }
    }

    hideBackToWorkBenchButton() {
        const backBtn = document.getElementById('back-to-workbench-btn');
        if (backBtn) {
            backBtn.style.display = 'none';
        }
    }

    includeCurrentPartInProject() {
        // Use selectedPart instead of currentWorkPart for user's actual selection
        if (!this.selectedPart) {
            console.log('No part selected - please select a part to send to assembly');
            // TODO: Show user message about selecting a part first
            return;
        }

        // Find the corresponding mesh in the scene
        const selectedMesh = this.scene.meshes.find(mesh => 
            mesh.partData && mesh.partData.id === this.selectedPart.id
        );
        
        if (!selectedMesh || !selectedMesh.isWorkBenchPart) {
            console.log('Selected part is not a work bench part');
            return;
        }

        // CRITICAL: Preserve actual mesh geometry before transfer
        const part = this.selectedPart;
        
        // CLEANUP: Clear router previews before serialization to prevent them from being preserved
        if (this.routerBitSystem) {
            this.routerBitSystem.clearAll();
            console.log('Cleared router previews before geometry serialization');
        }
        
        // Capture current mesh geometry data
        if (selectedMesh) {
            const meshData = this.serializeMeshGeometry(selectedMesh);
            part.meshGeometry = meshData;
            console.log('Captured mesh geometry for transfer:', meshData);
        }
        
        // Keep original status if it's already processed, otherwise mark as assembly-ready
        if (part.status === 'raw_material') {
            part.status = 'assembly_ready'; // Raw piece going to assembly
        } else {
            part.status = 'finished_part'; // Processed piece going to assembly
        }
        part.bench = 'assembly';
        part.id = part.id.replace('workpart_', 'part_'); // Change ID format

        // Move from work bench to project arrays
        this.workBenchParts = this.workBenchParts.filter(p => p.id !== part.id);
        this.projectParts.push(part);

        // Remove ONLY the selected part's mesh from the scene, not all parts
        if (selectedMesh) {
            selectedMesh.dispose();
            console.log(`Removed selected part from work bench: ${part.materialName}`);
        }

        // Clear selection since the part is now moved
        this.selectedPart = null;

        // Update UI displays
        this.updateWorkBenchDisplay();
        this.updateProjectPartsDisplay();
        this.hideIncludeInProjectButton();

        // Note: Part has been moved to assembly but user stays on current bench

        console.log('Selected part moved to assembly:', part);
    }

    /**
     * Send selected part back from assembly to work bench for further processing
     */
    sendPartBackToWorkBench() {
        // Use selectedPart for user's actual selection
        if (!this.selectedPart) {
            console.log('No part selected - please select a part to send back to work bench');
            return;
        }

        // Find the corresponding mesh in the scene
        const selectedMesh = this.scene.meshes.find(mesh => 
            mesh.partData && mesh.partData.id === this.selectedPart.id
        );
        
        if (!selectedMesh || !selectedMesh.isProjectPart) {
            console.log('Selected part is not an assembly part');
            return;
        }

        // CRITICAL: Preserve actual mesh geometry before transfer
        const part = this.selectedPart;
        
        // CLEANUP: Clear router previews before serialization to prevent them from being preserved
        if (this.routerBitSystem) {
            this.routerBitSystem.clearAll();
            console.log('Cleared router previews before geometry serialization');
        }
        
        // Capture current mesh geometry data
        if (selectedMesh) {
            const meshData = this.serializeMeshGeometry(selectedMesh);
            part.meshGeometry = meshData;
            console.log('Captured mesh geometry for transfer:', meshData);
        }
        
        // Preserve the processing history - don't change status back to raw if it was processed
        part.bench = 'work';
        part.id = part.id.replace('part_', 'workpart_'); // Change ID format back

        // Move from project to work bench arrays
        this.projectParts = this.projectParts.filter(p => p.id !== part.id);
        this.workBenchParts.push(part);

        // Remove ONLY the selected part's mesh from assembly scene, not all parts
        if (selectedMesh) {
            selectedMesh.dispose();
            console.log(`Removed selected part from assembly: ${part.materialName}`);
        }

        // Clear selection since the part is now moved
        this.selectedPart = null;

        // Update UI displays
        this.updateWorkBenchDisplay();
        this.updateProjectPartsDisplay();
        this.hideBackToWorkBenchButton();

        // Note: Part has been moved to work bench but user stays on current bench

        console.log('Selected part moved back to work bench:', part);
    }

    clearWorkBenchScene() {
        // Remove all work bench parts from scene
        const workBenchMeshes = this.scene.meshes.filter(mesh => mesh.isWorkBenchPart);
        workBenchMeshes.forEach(mesh => {
            mesh.dispose();
        });
    }

    showWorkBenchScene() {
        // Hide all assembly parts
        this.scene.meshes.forEach(mesh => {
            if (mesh.isProjectPart) {
                mesh.setEnabled(false);
            }
            if (mesh.isWorkBenchPart) {
                mesh.setEnabled(true);
            }
        });
    }

    showAssemblyBenchScene() {
        // Hide work bench parts, show project parts
        this.scene.meshes.forEach(mesh => {
            if (mesh.isWorkBenchPart) {
                mesh.setEnabled(false);
            }
            if (mesh.isProjectPart) {
                mesh.setEnabled(true);
            }
        });
    }

    createAssemblyProjectView() {
        // Clear any existing project parts from scene
        const projectMeshes = this.scene.meshes.filter(mesh => mesh.isProjectPart);
        projectMeshes.forEach(mesh => {
            mesh.dispose();
        });

        // Create 3D representations of all project parts
        this.projectParts.forEach((part, index) => {
            let box;
            
            // CRITICAL: Check if part has preserved geometry from previous modifications
            if (part.meshGeometry && part.meshGeometry.hasCustomGeometry) {
                console.log('Restoring preserved geometry for assembly part:', part.materialName);
                box = this.restoreMeshGeometry(part.meshGeometry, part.id);
            }
            
            // If no preserved geometry or restoration failed, create default box
            if (!box) {
                console.log('Creating default box geometry for assembly part:', part.materialName);
                
                const lengthCm = part.dimensions.length * 2.54;
                const widthCm = part.dimensions.width * 2.54;
                const thicknessCm = part.dimensions.thickness * 2.54;

                box = BABYLON.MeshBuilder.CreateBox(part.id, {
                    width: widthCm,
                    height: thicknessCm,
                    depth: lengthCm
                }, this.scene);

                // Create material-specific appearance for new boxes
        // Apply material with texture
                box.material = this.getMaterialColor(part.materialId);
    
            }

            // Smart positioning: preserve saved position for restored parts, use assembly position for new parts
            if (part.meshGeometry && part.meshGeometry.position) {
                // CRITICAL: Restore saved position for loaded assembly parts
                box.position = new BABYLON.Vector3(
                    part.meshGeometry.position.x,
                    part.meshGeometry.position.y,
                    part.meshGeometry.position.z
                );
                console.log('Restored saved position for assembly part', part.materialName, ':', box.position);
            } else {
                // Use assembly position for new parts
                const lengthCm = part.dimensions.length * 2.54;
                const widthCm = part.dimensions.width * 2.54;
                const thicknessCm = part.dimensions.thickness * 2.54;
                
                const position = this.findOptimalAssemblyPosition(lengthCm, widthCm, thicknessCm, index);
                box.position = position;
                console.log('Using assembly position for new part', part.materialName, ':', box.position);
            }

            // Only create material if it doesn't already exist (restored geometry has its own material)
            if (!box.material) {
        // Apply material with texture
                box.material = this.getMaterialColor(part.materialId);
    
            }

            // Store reference
            box.partData = part;
            box.isProjectPart = true;

            // PREVENT FIRST-SELECTION HOP: Force bounding info computation during creation
            // This ensures expensive computations happen now, not during first selection
            box.computeWorldMatrix(true);
            box.getBoundingInfo();
        });

        console.log('Assembly project view created with', this.projectParts.length, 'parts');
    }

    /**
     * Clear all parts from both work bench and assembly bench
     * Used when loading a project
     */
    clearAllParts() {
        // Set loading flag to prevent camera animations during project loading
        this.isLoadingProject = true;
        
        // COMPREHENSIVE cleanup - remove ALL non-essential meshes when loading projects
        const essentialMeshes = ['ground', 'skybox', 'camera', 'grid']; // Keep only these
        
        const allMeshesToClear = this.scene.meshes.filter(mesh => 
            !essentialMeshes.includes(mesh.name) && // Keep essential meshes
            mesh.name !== '__root__' && // Keep Babylon root
            !mesh.name.includes('gridLine') && // Keep grid lines
            !mesh.name.includes('grid') // Keep any grid-related meshes
        );
        
        console.log(`Clearing ${allMeshesToClear.length} meshes from scene (keeping essential meshes)`);
        allMeshesToClear.forEach(mesh => {
            console.log(`Disposing mesh: ${mesh.name}`);
            mesh.dispose();
        });
        
        // Clear the arrays
        this.workBenchParts = [];
        this.projectParts = [];
        
        console.log('All parts cleared from scene and arrays');
    }

    /**
     * Rebuild work bench parts from loaded data
     */
    rebuildWorkBenchParts() {
        console.log('=== REBUILD WORKBENCH DEBUG ===');
        console.log('WorkBench parts to rebuild:', this.workBenchParts);
        console.log('WorkBench parts count:', this.workBenchParts ? this.workBenchParts.length : 0);
        
        // Clear existing work bench parts
        const workBenchMeshes = this.scene.meshes.filter(mesh => mesh.isWorkBenchPart);
        console.log('Clearing', workBenchMeshes.length, 'existing work bench meshes');
        workBenchMeshes.forEach(mesh => mesh.dispose());
        
        // Recreate all work bench parts
        this.workBenchParts.forEach((part, index) => {
            console.log(`Creating work bench part ${index + 1}:`, part.id, part.materialName);
            this.createWorkBenchMaterial(part, true); // Pass isRestoring = true
        });
        
        console.log('Rebuilt', this.workBenchParts.length, 'work bench parts');
    }

    /**
     * Rebuild assembly parts from loaded data
     */
    rebuildAssemblyParts() {
        // Clear existing assembly parts
        const projectMeshes = this.scene.meshes.filter(mesh => mesh.isProjectPart);
        projectMeshes.forEach(mesh => mesh.dispose());
        
        // Recreate all assembly parts
        this.createAssemblyProjectView();
        
        console.log('Rebuilt', this.projectParts.length, 'assembly parts');
    }

    // === 3D PART MANIPULATION SYSTEM ===
    selectPart(part) {
        console.log('Selecting part:', part);
        
        // Deselect current part if different
        if (this.selectedPart && this.selectedPart !== part) {
            this.deselectPart();
        }
        
        // Toggle selection if clicking same part (unless drill press is active)
        if (this.selectedPart === part) {
            // Don't deselect if drill press tool is active
            if (this.activeTool !== 'drill') {
                this.deselectPart();
                return;
            }
            // For drill press, allow clicks on selected part for surface selection
        }
        
        // Select new part
        this.selectedPart = part;
        
        // Find the mesh for this part
        const mesh = this.scene.meshes.find(m => m.partData === part);
        console.log('SELECT DEBUG: Looking for mesh with partData === part');
        console.log('SELECT DEBUG: part:', part);
        console.log('SELECT DEBUG: found mesh:', mesh);
        console.log('SELECT DEBUG: mesh.name:', mesh?.name);
        console.log('SELECT DEBUG: mesh.id:', mesh?.id);
        console.log('SELECT DEBUG: mesh.dimensions:', mesh?.dimensions);
        console.log('SELECT DEBUG: mesh.partData:', mesh?.partData);
        console.log('SELECT DEBUG: mesh.partData?.dimensions:', mesh?.partData?.dimensions);
        
        if (mesh) {
            this.setPartSelection(mesh, true);
            
            // Only create manipulation UI if Move tool is explicitly active
            if (this.activeTool === 'move') {
                this.createManipulationButtons(mesh);
                this.createDragHandles(mesh);
            }
        }
        
        // Update UI
        this.updatePartSelectionUI();
        
        // Deselect any face selection
        if (this.selectedFace) {
            this.deselectFace();
        }
    }

    deselectPart() {
        if (!this.selectedPart) return;
        
        console.log('Deselecting part:', this.selectedPart);
        
        // Find the mesh for this part
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (mesh) {
            this.setPartSelection(mesh, false);
        }
        
        // Clear manipulation UI
        this.clearManipulationButtons();
        this.clearDragHandles();
        
        // Clear selection
        this.selectedPart = null;
        
        // Update UI
        this.updatePartSelectionUI();
    }

    setPartSelection(mesh, isSelected) {
        // DEBUG: Track position before/after selection
        const positionBefore = mesh.position.clone();
        console.log(`MESH POSITION BEFORE selection (${isSelected}):`, positionBefore);
        
        if (isSelected) {
            // Store original material
            mesh.originalMaterial = mesh.material;
            
            // Apply selection material (yellow outline)
            if (!this.selectionMaterial) {
                this.selectionMaterial = new BABYLON.StandardMaterial('selectionMaterial', this.scene);
                this.selectionMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0); // Yellow
                this.selectionMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);
                this.selectionMaterial.wireframe = false;
                this.selectionMaterial.alpha = 0.8;
            }
            
            // Create outline effect
            mesh.enableEdgesRendering();
            mesh.edgesWidth = 4.0;
            mesh.edgesColor = new BABYLON.Color4(1, 1, 0, 1); // Yellow outline
            
        } else {
            // Restore original material
            if (mesh.originalMaterial) {
                mesh.material = mesh.originalMaterial;
                mesh.originalMaterial = null;
            }
            
            // Remove outline
            mesh.disableEdgesRendering();
        }
        
        // DEBUG: Track position after selection
        const positionAfter = mesh.position.clone();
        console.log(`MESH POSITION AFTER selection (${isSelected}):`, positionAfter);
        
        // DEBUG: Check if position changed
        const positionDelta = positionAfter.subtract(positionBefore);
        if (positionDelta.length() > 0.001) {
            console.error(`❌ MESH POSITION CHANGED during selection! Delta:`, positionDelta);
        }
    }

    updatePartSelectionUI() {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            if (this.selectedPart) {
                selectionInfo.innerHTML = `
                    <strong>Selected Part:</strong><br>
                    ${this.selectedPart.materialName}<br>
                    ${this.selectedPart.dimensions.length}" × ${this.selectedPart.dimensions.width}" × ${this.selectedPart.dimensions.thickness}"<br>
                    <em>Use manipulation buttons to move</em>
                `;
            } else {
                selectionInfo.textContent = 'Nothing selected';
            }
        }
        
        // Show/hide bench transfer buttons based on selection and current bench
        if (this.selectedPart) {
            const selectedMesh = this.scene.meshes.find(mesh => 
                mesh.partData && mesh.partData.id === this.selectedPart.id
            );
            
            if (this.currentBench === 'work' && selectedMesh && selectedMesh.isWorkBenchPart) {
                // On Work Bench with work bench part selected - show "To Assembly"
                this.showIncludeInProjectButton();
                this.hideBackToWorkBenchButton();
            } else if (this.currentBench === 'assembly' && selectedMesh && selectedMesh.isProjectPart) {
                // On Assembly Bench with assembly part selected - show "To Work Bench"
                this.hideIncludeInProjectButton();
                this.showBackToWorkBenchButton();
            } else {
                // No valid selection for current bench
                this.hideIncludeInProjectButton();
                this.hideBackToWorkBenchButton();
            }
        } else {
            // Nothing selected
            this.hideIncludeInProjectButton();
            this.hideBackToWorkBenchButton();
        }
        
        // Update project explorer selection
        this.updateProjectExplorerSelection();
    }

    updateProjectExplorerSelection() {
        // Clear all active states
        document.querySelectorAll('.part-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Highlight selected part
        if (this.selectedPart) {
            const partId = this.selectedPart.id;
            const partItem = document.querySelector(`[data-part-id="${partId}"]`);
            if (partItem) {
                partItem.classList.add('active');
            }
        }
    }

    createManipulationButtons(mesh) {
        // Clear existing buttons
        this.clearManipulationButtons();
        
        try {
            // Use properties panel instead of popup
            this.showManipulationInPropertiesPanel(mesh);
            console.log('Created manipulation buttons in properties panel');
        } catch (error) {
            console.error('Error creating manipulation buttons:', error);
            // Fallback: Show manipulation info in selection panel
            this.showManipulationInstructions();
        }
    }

    showManipulationInPropertiesPanel(mesh) {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            // Show part info if mesh has part data, otherwise show general manipulation
            const partInfo = mesh && mesh.partData ? `
                <strong>Selected Part:</strong><br>
                ${mesh.partData.materialName}<br>
                ${mesh.partData.dimensions.length}" × ${mesh.partData.dimensions.width}" × ${mesh.partData.dimensions.thickness}"<br>
                <br>
            ` : `<strong>Move Tool Active</strong><br>Select a part to manipulate<br><br>`;

            selectionInfo.innerHTML = `
                ${partInfo}
                <div style="background: rgba(52, 152, 219, 0.1); padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Object Manipulation:</strong><br>
                    
                    <div style="margin: 8px 0;">
                        <strong>Spin on Table:</strong><br>
                        <button onclick="window.drawingWorld.rotatePart(90, 'Y')" class="manip-btn" title="Rotate 90° clockwise">↻ 90°</button>
                        <button onclick="window.drawingWorld.rotatePart(-90, 'Y')" class="manip-btn" title="Rotate 90° counter-clockwise">↺ 90°</button>
                        <button onclick="window.drawingWorld.rotatePart(45, 'Y')" class="manip-btn" title="Rotate 45° clockwise">↻ 45°</button>
                        <button onclick="window.drawingWorld.rotatePart(-45, 'Y')" class="manip-btn" title="Rotate 45° counter-clockwise">↺ 45°</button>
                    </div>
                    
                    <div style="margin: 8px 0;">
                        <strong>Position & Orientation:</strong><br>
                        <button onclick="window.drawingWorld.flattenBoard()" class="manip-btn" title="Lay flat on table">Flat</button>
                        <button onclick="window.drawingWorld.dropPart()" class="manip-btn" title="Drop part flat onto surface">Drop</button>
                        <button onclick="window.drawingWorld.standOnEndEdge()" class="manip-btn" title="Stand on width edge">Width Edge Up</button>
                        <button onclick="window.drawingWorld.standOnSideEdge()" class="manip-btn" title="Stand on length edge">Length Edge Up</button>
                    </div>
                    
                    <div style="margin: 8px 0;">
                        <strong>Tip & Roll:</strong><br>
                        <button onclick="window.drawingWorld.rotatePart(90, 'X')" class="manip-btn" title="Tip away 90°">⤴ 90°</button>
                        <button onclick="window.drawingWorld.rotatePart(-90, 'X')" class="manip-btn" title="Tip toward 90°">⤵ 90°</button>
                        <button onclick="window.drawingWorld.rotatePart(90, 'Z')" class="manip-btn" title="Roll right 90°">⭮ 90°</button>
                        <button onclick="window.drawingWorld.rotatePart(-90, 'Z')" class="manip-btn" title="Roll left 90°">⭯ 90°</button>
                    </div>
                    
                    <div style="margin: 8px 0;">
                        <strong>Flip Operations:</strong><br>
                        <button onclick="window.drawingWorld.flipPart('X')" class="manip-btn" title="Flip front-to-back">Flip F↔B</button>
                        <button onclick="window.drawingWorld.flipPart('Y')" class="manip-btn" title="Flip left-to-right">Flip L↔R</button>
                        <button onclick="window.drawingWorld.flipPart('Z')" class="manip-btn" title="Flip top-to-bottom">Flip T↔B</button>
                    </div>
                </div>
            `;
        }
    }

    // Old popup-based manipulation buttons method
    createManipulationButtonsPopup(mesh) {
        // Clear existing buttons
        this.clearManipulationButtons();
        
        try {
            // Create GUI container
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ManipulationUI");
            this.manipulationGUI = advancedTexture;
            
            // Create main container with border
            const mainContainer = new BABYLON.GUI.Rectangle();
            mainContainer.widthInPixels = 400;
            mainContainer.heightInPixels = 280;
            mainContainer.cornerRadius = 12;
            mainContainer.color = "#3498db";
            mainContainer.thickness = 3;
            mainContainer.background = "rgba(44, 62, 80, 0.95)";
            
            // Create title
            const title = new BABYLON.GUI.TextBlock();
            title.text = "Object Manipulator";
            title.color = "white";
            title.fontSize = 16;
            title.fontWeight = "bold";
            title.heightInPixels = 30;
            title.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            title.topInPixels = 10;
            
            // Create button container
            const buttonPanel = new BABYLON.GUI.StackPanel();
            buttonPanel.widthInPixels = 380;
            buttonPanel.heightInPixels = 240;
            buttonPanel.paddingTopInPixels = 40;
            buttonPanel.paddingBottomInPixels = 10;
            
            // Position main container in top right area
            mainContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            mainContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            mainContainer.leftInPixels = -20;
            mainContainer.topInPixels = 80;
            
            // Rotation buttons row 1 - Y axis (around vertical - like spinning on table)
            const rotationRow1 = new BABYLON.GUI.StackPanel();
            rotationRow1.isVertical = false;
            rotationRow1.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Right 90°", () => this.rotatePart(90, 'Y'), "Rotate board clockwise when viewed from above");
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Left 90°", () => this.rotatePart(-90, 'Y'), "Rotate board counter-clockwise when viewed from above");
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Right 45°", () => this.rotatePart(45, 'Y'), "Rotate board 45° clockwise when viewed from above");
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Left 45°", () => this.rotatePart(-45, 'Y'), "Rotate board 45° counter-clockwise when viewed from above");
            
            // Rotation buttons row 2 - X axis (tip up/down - like standing board on edge)
            const rotationRow2 = new BABYLON.GUI.StackPanel();
            rotationRow2.isVertical = false;
            rotationRow2.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(rotationRow2, "Tip Away 90°", () => this.rotatePart(90, 'X'), "Tip the far end of board upward 90°");
            this.createManipulationButtonWithPreview(rotationRow2, "Tip Toward 90°", () => this.rotatePart(-90, 'X'), "Tip the near end of board upward 90°");
            this.createManipulationButtonWithPreview(rotationRow2, "Lay Flat", () => this.flattenBoard(), "Board lies flat - thickness (3/4\") on top/bottom");
            this.createManipulationButtonWithPreview(rotationRow2, "Drop", () => this.dropPart(), "Drop part flat onto surface directly below");
            this.createManipulationButtonWithPreview(rotationRow2, "Width Edge Up", () => this.standOnEndEdge(), "Board stands on width edge - thickness (3/4\") shows as width");
            
            // Rotation buttons row 3 - Z axis (side edge)
            const rotationRow3 = new BABYLON.GUI.StackPanel();
            rotationRow3.isVertical = false;
            rotationRow3.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(rotationRow3, "Length Edge Up", () => this.standOnSideEdge(), "Board stands on length edge - thickness (3/4\") shows as height");
            this.createManipulationButtonWithPreview(rotationRow3, "Roll Right 90°", () => this.rotatePart(90, 'Z'), "Roll board to the right 90°");
            this.createManipulationButtonWithPreview(rotationRow3, "Roll Left 90°", () => this.rotatePart(-90, 'Z'), "Roll board to the left 90°");
            
            // Flip buttons row 2
            const flipRow = new BABYLON.GUI.StackPanel();
            flipRow.isVertical = false;
            flipRow.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(flipRow, "Flip Front-to-Back", () => this.flipPart('X'), "Flip board end-over-end (front becomes back)");
            this.createManipulationButtonWithPreview(flipRow, "Flip Left-to-Right", () => this.flipPart('Y'), "Flip board side-to-side (left becomes right)");
            this.createManipulationButtonWithPreview(flipRow, "Flip Top-to-Bottom", () => this.flipPart('Z'), "Flip board upside-down (top becomes bottom)");
            
            // Add precision sliders row
            const sliderRow = new BABYLON.GUI.StackPanel();
            sliderRow.isVertical = false;
            sliderRow.heightInPixels = 40;
            
            this.createPrecisionSliders(sliderRow);
            
            // Add rows to panel
            buttonPanel.addControl(rotationRow1);
            buttonPanel.addControl(rotationRow2);
            buttonPanel.addControl(rotationRow3);
            buttonPanel.addControl(flipRow);
            buttonPanel.addControl(sliderRow);
            
            // Add title and panel to main container
            mainContainer.addControl(title);
            mainContainer.addControl(buttonPanel);
            
            // Add to GUI
            advancedTexture.addControl(mainContainer);
            
            console.log('Created manipulation buttons for part');
        } catch (error) {
            console.error('Error creating manipulation buttons:', error);
            // Fallback: Show manipulation info in selection panel
            this.showManipulationInstructions();
        }
    }

    showManipulationInstructions() {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo && this.selectedPart) {
            selectionInfo.innerHTML = `
                <strong>Selected Part:</strong><br>
                ${this.selectedPart.materialName}<br>
                ${this.selectedPart.dimensions.length}" × ${this.selectedPart.dimensions.width}" × ${this.selectedPart.dimensions.thickness}"<br>
                <br>
                <strong>Spin on Table:</strong><br>
                <button onclick="window.drawingWorld.rotatePart(90, 'Y')" class="manip-btn">↻ 90°</button>
                <button onclick="window.drawingWorld.rotatePart(-90, 'Y')" class="manip-btn">↺ 90°</button><br>
                <strong>Tip Up/Down:</strong><br>
                <button onclick="window.drawingWorld.flattenBoard()" class="manip-btn">Flat</button>
                <button onclick="window.drawingWorld.standOnEdge()" class="manip-btn">Edge</button><br>
                <button onclick="window.drawingWorld.rotatePart(90, 'X')" class="manip-btn">⤴ 90°</button>
                <button onclick="window.drawingWorld.rotatePart(-90, 'X')" class="manip-btn">⤵ 90°</button>
            `;
        }
    }

    createManipulationButton(parent, text, onClick) {
        const button = BABYLON.GUI.Button.CreateSimpleButton(null, text);
        button.widthInPixels = 65;
        button.heightInPixels = 30;
        button.color = "white";
        button.background = "#3498db";
        button.cornerRadius = 4;
        button.fontSize = 12;
        button.paddingLeftInPixels = 5;
        button.paddingRightInPixels = 5;
        
        button.onPointerUpObservable.add(onClick);
        
        // Hover effects
        button.onPointerEnterObservable.add(() => {
            button.background = "#2980b9";
        });
        
        button.onPointerOutObservable.add(() => {
            button.background = "#3498db";
        });
        
        parent.addControl(button);
        return button;
    }

    createManipulationButtonWithPreview(parent, text, onClick, description) {
        const button = BABYLON.GUI.Button.CreateSimpleButton(null, text);
        button.widthInPixels = 75;
        button.heightInPixels = 30;
        button.color = "white";
        button.background = "#3498db";
        button.cornerRadius = 4;
        button.fontSize = 10;
        button.paddingLeftInPixels = 2;
        button.paddingRightInPixels = 2;
        
        button.onPointerUpObservable.add(onClick);
        
        // Create tooltip that appears on hover
        let tooltipContainer = null;
        
        // Hover effects with tooltip
        button.onPointerEnterObservable.add(() => {
            button.background = "#2980b9";
            
            // Create tooltip
            if (!tooltipContainer) {
                tooltipContainer = new BABYLON.GUI.Rectangle();
                tooltipContainer.widthInPixels = 200;
                tooltipContainer.heightInPixels = 40;
                tooltipContainer.cornerRadius = 5;
                tooltipContainer.color = "#2c3e50";
                tooltipContainer.thickness = 2;
                tooltipContainer.background = "rgba(44, 62, 80, 0.95)";
                
                const tooltipText = new BABYLON.GUI.TextBlock();
                tooltipText.text = description;
                tooltipText.color = "white";
                tooltipText.fontSize = 11;
                tooltipText.textWrapping = true;
                tooltipText.resizeToFit = true;
                
                tooltipContainer.addControl(tooltipText);
                
                // Position tooltip above the button
                tooltipContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                tooltipContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                tooltipContainer.topInPixels = -50;
                
                this.manipulationGUI.addControl(tooltipContainer);
            }
        });
        
        button.onPointerOutObservable.add(() => {
            button.background = "#3498db";
            
            // Remove tooltip
            if (tooltipContainer) {
                this.manipulationGUI.removeControl(tooltipContainer);
                tooltipContainer.dispose();
                tooltipContainer = null;
            }
        });
        
        parent.addControl(button);
        return button;
    }

    clearManipulationButtons() {
        if (this.manipulationGUI) {
            this.manipulationGUI.dispose();
            this.manipulationGUI = null;
        }
        // Also clear properties panel if it contains manipulation buttons
        this.clearPropertiesPanel();
    }

    clearPropertiesPanel() {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            selectionInfo.textContent = 'Nothing selected';
        }
    }

    createDragHandles(mesh) {
        // Clear any existing handles
        this.clearDragHandles();
        
        // Create new modern gizmo
        if (!this.modernGizmo) {
            this.modernGizmo = new ModernGizmoSystem(this.scene, this.camera, this.canvas);
        }
        
        this.modernGizmo.createGizmo(mesh);
        this.modernGizmo.show();
        
        console.log('Created modern gizmo for mesh:', mesh.name);
    }

    clearDragHandles() {
        // Dispose modern gizmo
        if (this.modernGizmo) {
            this.modernGizmo.dispose();
        }
        
        // Clear old drag handles if any remain
        if (this.dragHandles) {
            this.dragHandles.forEach(handle => handle.dispose());
            this.dragHandles = [];
        }
        
        console.log('Cleared all drag handles and gizmos');
    }

    rotatePart(degrees, axis) {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log(`Rotating part ${degrees}° around ${axis} axis`);
        
        const radians = degrees * (Math.PI / 180);
        
        switch(axis) {
            case 'X':
                mesh.rotation.x += radians;
                break;
            case 'Y':
                mesh.rotation.y += radians;
                break;
            case 'Z':
                mesh.rotation.z += radians;
                break;
        }
        
        // AUTO-LIFT: Ensure part doesn't go below XY plane after rotation
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        // Update drag handles position (only if Move tool is active)
        if (this.dragHandles && this.activeTool === 'move') {
            this.clearDragHandles();
            this.createDragHandles(mesh);
        }
        
        // Update manipulation buttons position (only if Move tool is active)
        if (this.activeTool === 'move') {
            this.clearManipulationButtons();
            this.createManipulationButtons(mesh);
        }
    }

    /**
     * Update partData.dimensions to reflect current mesh orientation after rotation
     */
    updatePartDataDimensions(mesh) {
        if (!mesh || !mesh.partData) return;
        
        // Get current world-space bounding vectors
        mesh.computeWorldMatrix(true);
        const hierarchyBounds = mesh.getHierarchyBoundingVectors(true);
        const worldMin = hierarchyBounds.min;
        const worldMax = hierarchyBounds.max;
        
        // Calculate current world-space dimensions
        const worldSizeX = Math.abs(worldMax.x - worldMin.x);
        const worldSizeY = Math.abs(worldMax.y - worldMin.y);
        const worldSizeZ = Math.abs(worldMax.z - worldMin.z);
        
        // Convert from cm to inches
        const currentXInches = worldSizeX / 2.54;
        const currentYInches = worldSizeY / 2.54;
        const currentZInches = worldSizeZ / 2.54;
        
        // Find the longest and shortest horizontal dimensions (X and Z)
        const horizontalDims = [currentXInches, currentZInches].sort((a, b) => b - a);
        
        // Update partData.dimensions based on current world-space orientation
        mesh.partData.dimensions.length = horizontalDims[0];     // Longer horizontal dimension
        mesh.partData.dimensions.width = horizontalDims[1];      // Shorter horizontal dimension
        mesh.partData.dimensions.thickness = currentYInches;     // Vertical dimension
        
        // Also update the selectedPart reference if it exists
        if (this.selectedPart === mesh.partData) {
            this.selectedPart.dimensions = mesh.partData.dimensions;
        }
    }

    flipPart(axis) {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log(`Flipping part along ${axis} axis`);
        
        switch(axis) {
            case 'X':
                mesh.rotation.x += Math.PI;
                break;
            case 'Y':
                mesh.rotation.y += Math.PI;
                break;
            case 'Z':
                mesh.rotation.z += Math.PI;
                break;
        }
        
        // AUTO-LIFT: Ensure part doesn't go below XY plane after flip
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        // Update drag handles position (only if Move tool is active)
        if (this.dragHandles && this.activeTool === 'move') {
            this.clearDragHandles();
            this.createDragHandles(mesh);
        }
        
        // Update manipulation buttons position (only if Move tool is active)
        if (this.activeTool === 'move') {
            this.clearManipulationButtons();
            this.createManipulationButtons(mesh);
        }
    }

    flattenBoard() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Flattening board (3/4" on top/bottom)');
        
        // Reset rotation to lay flat
        mesh.rotation.x = 0;
        mesh.rotation.y = 0;
        mesh.rotation.z = 0;
        
        // AUTO-LIFT: Ensure part doesn't go below XY plane
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    dropPart() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Dropping part to flat surface below');
        
        // Reset rotation to lay flat (like flattenBoard)
        mesh.rotation.x = 0;
        mesh.rotation.y = 0;
        mesh.rotation.z = 0;
        
        // Drop to XY plane (Y = 0 surface)
        const boundingInfo = mesh.getBoundingInfo();
        const thicknessHalf = Math.abs(boundingInfo.maximum.y - boundingInfo.minimum.y) / 2;
        mesh.position.y = thicknessHalf; // Place bottom of part on XY plane
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    standOnEndEdge() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Standing board on end edge (3/4" as width)');
        
        // Rotate 90 degrees around X to stand on end edge
        mesh.rotation.x = Math.PI / 2;
        mesh.rotation.y = 0;
        mesh.rotation.z = 0;
        
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    standOnSideEdge() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Standing board on side edge (3/4" as height)');
        
        // Rotate 90 degrees around Z to stand on side edge
        mesh.rotation.x = 0;
        mesh.rotation.y = 0;
        mesh.rotation.z = Math.PI / 2;
        
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    updateManipulationUI(mesh) {
        // Update drag handles position (only if Move tool is active)
        if (this.dragHandles && this.activeTool === 'move') {
            this.clearDragHandles();
            this.createDragHandles(mesh);
        }
        
        // Update manipulation buttons position (only if Move tool is active)
        if (this.activeTool === 'move') {
            this.clearManipulationButtons();
            this.createManipulationButtons(mesh);
        }
    }

    // Grid snapping functionality
    snapToGrid(value, gridSize = 2.54) { // Default 1 inch grid (2.54 cm)
        return Math.round(value / gridSize) * gridSize;
    }

    snapPosition(position) {
        return new BABYLON.Vector3(
            this.snapToGrid(position.x),
            this.snapToGrid(position.y, 1.27), // Y axis uses 0.5 inch grid for stacking
            this.snapToGrid(position.z)
        );
    }

    enableDragHandleInteraction() {
        // Modern gizmo handles its own interactions
        
        // Add mouse event handlers for drag handles
        this.dragPointerObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    this.onDragStart(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.onDragMove(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    this.onDragEnd(pointerInfo);
                    break;
            }
        });
        
        console.log('Drag handle interaction enabled');
    }

    onDragStart(pointerInfo) {
        const pickedMesh = pointerInfo.pickInfo.pickedMesh;
        
        if (pickedMesh && pickedMesh.isDragHandle) {
            this.isDragging = true;
            this.dragHandle = pickedMesh;
            this.dragStartPosition = pickedMesh.targetPart.position.clone();
            
            // DISABLE camera controls during drag operations
            this.camera.detachControl(this.canvas);
            
            // Initialize mouse tracking for smooth movement
            this.lastMouseX = pointerInfo.event.offsetX;
            this.lastMouseY = pointerInfo.event.offsetY;
            
            // Change handle appearance to show it's active
            pickedMesh.material.emissiveColor = pickedMesh.material.diffuseColor.scale(0.8);
            
            const handleInfo = pickedMesh.handleType === 'plane' ? 
                `${pickedMesh.axes} plane (${pickedMesh.lockedAxis} locked)` : 
                `${pickedMesh.axis} axis`;
            console.log(`Started dragging ${handleInfo} handle - Camera controls DISABLED`);
        } else if (pickedMesh && pickedMesh.partData && this.selectedPart) {
            // PREPARE for potential dragging but don't start yet
            // Only start dragging if mouse actually moves
            this.isDragging = false; // Don't start dragging immediately
            this.dragHandle = null; // No specific axis constraint
            this.dragStartPosition = pickedMesh.position.clone();
            this.draggedPart = pickedMesh;
            this.potentialDragPart = pickedMesh; // Mark part as potential drag target
            
            // Initialize mouse tracking for drag detection
            this.lastMouseX = pointerInfo.event.offsetX;
            this.lastMouseY = pointerInfo.event.offsetY;
            this.dragStartMouseX = pointerInfo.event.offsetX;
            this.dragStartMouseY = pointerInfo.event.offsetY;
            
            console.log('Part clicked - prepared for potential dragging');
        }
    }

    onDragMove(pointerInfo) {
        // Check if we have a potential drag part that hasn't started dragging yet
        if (this.potentialDragPart && !this.isDragging && pointerInfo.event.buttons === 1) {
            // Only check for drag if LEFT mouse button is still pressed
            const deltaX = pointerInfo.event.offsetX - this.dragStartMouseX;
            const deltaY = pointerInfo.event.offsetY - this.dragStartMouseY;
            const mouseDelta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Only start dragging if mouse moved more than 5 pixels AND left button is pressed
            if (mouseDelta > 5) {
                this.isDragging = true;
                this.draggedPart = this.potentialDragPart;
                this.potentialDragPart = null;
                
                // DISABLE camera controls during drag operations
                this.camera.detachControl(this.canvas);
                
                console.log('Started dragging part directly - Camera controls DISABLED');
            }
        }
        
        if (!this.isDragging) return;
        
        if (this.dragHandle) {
            // Check handle type for different movement modes
            if (this.dragHandle.handleType === 'single') {
                // Single-axis constrained dragging
                this.handleAxisDrag(pointerInfo);
            } else if (this.dragHandle.handleType === 'plane') {
                // Dual-axis plane dragging
                this.handlePlaneDrag(pointerInfo);
            }
        } else if (this.draggedPart) {
            // Free movement dragging
            this.handleFreeDrag(pointerInfo);
        }
    }

    onDragEnd(pointerInfo) {
        // Clear potential drag state if mouse was released without dragging
        if (this.potentialDragPart && !this.isDragging) {
            this.potentialDragPart = null;
            console.log('Selection completed - no drag occurred');
            return;
        }
        
        if (!this.isDragging) return;
        
        // RE-ENABLE camera controls when drag ends
        // this.camera.attachControl(this.canvas, true); // Commented out to prevent conflicts with custom camera controls
        
        if (this.dragHandle) {
            // Restore handle appearance
            const color = this.dragHandle.material.diffuseColor;
            this.dragHandle.material.emissiveColor = color.scale(0.3);
            
            // Snap final position to grid
            const targetPart = this.dragHandle.targetPart;
            targetPart.position = this.snapPosition(targetPart.position);
            
            // Update drag handles and buttons to new position (only if Move tool is active)
            if (this.activeTool === 'move') {
                this.clearDragHandles();
                this.createDragHandles(targetPart);
                this.clearManipulationButtons();
                this.createManipulationButtons(targetPart);
            }
            
            const handleInfo = this.dragHandle.handleType === 'plane' ? 
                `${this.dragHandle.axes} plane` : 
                `${this.dragHandle.axis} axis`;
            console.log(`Finished dragging ${handleInfo} handle - Camera controls RE-ENABLED`);
        } else if (this.draggedPart) {
            // Snap free drag to grid
            this.draggedPart.position = this.snapPosition(this.draggedPart.position);
            
            // Update drag handles and buttons to new position (only if Move tool is active)
            if (this.activeTool === 'move') {
                this.clearDragHandles();
                this.createDragHandles(this.draggedPart);
                this.clearManipulationButtons();
                this.createManipulationButtons(this.draggedPart);
            }
            
            console.log('Finished free dragging part - Camera controls RE-ENABLED');
        }
        
        this.isDragging = false;
        this.dragHandle = null;
        this.draggedPart = null;
        this.dragStartPosition = null;
        this.potentialDragPart = null; // Clear potential drag state
    }

    handleAxisDrag(pointerInfo) {
        const dragHandle = this.dragHandle;
        const targetPart = dragHandle.targetPart;
        const axis = dragHandle.axis;
        
        // Get mouse delta for smooth movement
        const deltaX = pointerInfo.event.offsetX - this.lastMouseX;
        const deltaY = pointerInfo.event.offsetY - this.lastMouseY;
        
        // Store current mouse position for next frame
        this.lastMouseX = pointerInfo.event.offsetX;
        this.lastMouseY = pointerInfo.event.offsetY;
        
        // Calculate movement sensitivity
        const sensitivity = 0.2;
        
        // Move along the specified axis based on mouse movement
        switch(axis) {
            case 'X':
                targetPart.position.x += deltaX * sensitivity;
                break;
            case 'Y':
                targetPart.position.y -= deltaY * sensitivity; // Invert Y for proper direction
                break;
            case 'Z':
                targetPart.position.z += (deltaX + deltaY) * sensitivity * 0.5; // Combine for Z movement
                break;
        }
        
        // Apply grid snapping in real-time
        targetPart.position = this.snapPosition(targetPart.position);
        
        // Ensure part stays on bench surface
        this.keepOnBenchSurface(targetPart);
        
        // Update handle positions
        this.updateDragHandlePositions(targetPart);
    }

    handlePlaneDrag(pointerInfo) {
        const dragHandle = this.dragHandle;
        const targetPart = dragHandle.targetPart;
        const axes = dragHandle.axes;
        const lockedAxis = dragHandle.lockedAxis;
        
        // Get mouse delta for smooth movement
        const deltaX = pointerInfo.event.offsetX - this.lastMouseX;
        const deltaY = pointerInfo.event.offsetY - this.lastMouseY;
        
        // Store current mouse position for next frame
        this.lastMouseX = pointerInfo.event.offsetX;
        this.lastMouseY = pointerInfo.event.offsetY;
        
        // Calculate movement sensitivity
        const sensitivity = 0.2;
        
        // Save the locked axis position
        const lockedPosition = lockedAxis === 'X' ? targetPart.position.x : 
                              (lockedAxis === 'Y' ? targetPart.position.y : targetPart.position.z);
        
        // Move along the plane axes based on mouse movement
        switch(axes) {
            case 'XY': // Z locked
                targetPart.position.x += deltaX * sensitivity;
                targetPart.position.y -= deltaY * sensitivity;
                break;
            case 'XZ': // Y locked  
                targetPart.position.x += deltaX * sensitivity;
                targetPart.position.z += deltaY * sensitivity;
                break;
            case 'YZ': // X locked
                targetPart.position.y -= deltaX * sensitivity;
                targetPart.position.z += deltaY * sensitivity;
                break;
        }
        
        // Restore the locked axis position
        if (lockedAxis === 'X') {
            targetPart.position.x = lockedPosition;
        } else if (lockedAxis === 'Y') {
            targetPart.position.y = lockedPosition;
        } else if (lockedAxis === 'Z') {
            targetPart.position.z = lockedPosition;
        }
        
        // Apply grid snapping in real-time
        targetPart.position = this.snapPosition(targetPart.position);
        
        // Ensure part stays on bench surface
        this.keepOnBenchSurface(targetPart);
        
        // Update handle positions
        this.updateDragHandlePositions(targetPart);
    }

    handleFreeDrag(pointerInfo) {
        const part = this.draggedPart;
        
        // Create a picking ray from mouse position
        const ray = this.scene.createPickingRay(
            pointerInfo.event.offsetX,
            pointerInfo.event.offsetY,
            BABYLON.Matrix.Identity(),
            this.camera
        );
        
        // Project onto the grid plane (Y = 0 for now)
        const groundPlane = BABYLON.Plane.FromPositionAndNormal(
            new BABYLON.Vector3(0, 0, 0),
            new BABYLON.Vector3(0, 1, 0)
        );
        
        const distance = ray.intersectsPlane(groundPlane);
        if (distance !== null) {
            const worldPos = ray.origin.add(ray.direction.scale(distance));
            
            // Maintain current Y position, only move in X and Z
            worldPos.y = part.position.y;
            
            // Apply real-time grid snapping for smooth movement
            part.position = this.snapPosition(worldPos);
            
            // Update handle positions
            this.updateDragHandlePositions(part);
        }
    }

    updateDragHandlePositions(targetPart) {
        if (!this.dragHandles) return;
        
        // Recalculate highest point after movement
        targetPart.computeWorldMatrix(true);
        const boundingInfo = targetPart.getBoundingInfo();
        const worldMatrix = targetPart.getWorldMatrix();
        
        const corners = [
            boundingInfo.minimum,
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.maximum.z),
            boundingInfo.maximum
        ];
        
        let highestY = -Infinity;
        corners.forEach(corner => {
            const worldCorner = BABYLON.Vector3.TransformCoordinates(corner, worldMatrix);
            if (worldCorner.y > highestY) {
                highestY = worldCorner.y;
            }
        });
        
        const clearance = 5;
        const handleHeight = highestY + clearance;
        const partPosition = targetPart.getAbsolutePosition();
        
        this.dragHandles.forEach(handle => {
            if (handle.axis) {
                // Update single-axis handles
                if (handle.axis === 'X') {
                    if (handle.name && handle.name.includes('shaft')) {
                        handle.position = new BABYLON.Vector3(partPosition.x + 8, handleHeight, partPosition.z);
                    } else {
                        handle.position = new BABYLON.Vector3(partPosition.x + 12, handleHeight, partPosition.z);
                    }
                } else if (handle.axis === 'Y') {
                    if (handle.name && handle.name.includes('shaft')) {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight + 8, partPosition.z);
                    } else {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight + 12, partPosition.z);
                    }
                } else if (handle.axis === 'Z') {
                    if (handle.name && handle.name.includes('shaft')) {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight, partPosition.z + 8);
                    } else {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight, partPosition.z + 12);
                    }
                }
            } else if (handle.axes) {
                // Update plane handles
                if (handle.axes === 'XY') {
                    handle.position = new BABYLON.Vector3(partPosition.x + 6, handleHeight, partPosition.z + 6);
                } else if (handle.axes === 'XZ') {
                    handle.position = new BABYLON.Vector3(partPosition.x + 6, handleHeight + 2, partPosition.z - 6);
                } else if (handle.axes === 'YZ') {
                    handle.position = new BABYLON.Vector3(partPosition.x - 6, handleHeight + 2, partPosition.z + 6);
                }
            }
        });
    }

    getAxisVector(axis) {
        switch(axis) {
            case 'X': return new BABYLON.Vector3(1, 0, 0);
            case 'Y': return new BABYLON.Vector3(0, 1, 0);
            case 'Z': return new BABYLON.Vector3(0, 0, 1);
            default: return new BABYLON.Vector3(0, 1, 0);
        }
    }

    keepOnBenchSurface(mesh) {
        // Ensure the part never goes below the bench surface (Y = 0)
        // FORCE matrix update after rotation to get accurate bounding box
        mesh.computeWorldMatrix(true);
        
        // Calculate the mesh's bottom position after rotation
        const boundingInfo = mesh.getBoundingInfo();
        const worldMatrix = mesh.getWorldMatrix();
        
        // Get all bounding box corners and transform them to world space
        const corners = [
            boundingInfo.minimum,
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.maximum.z),
            boundingInfo.maximum
        ];
        
        // Find the lowest Y coordinate in world space
        let lowestY = Infinity;
        corners.forEach(corner => {
            const worldCorner = BABYLON.Vector3.TransformCoordinates(corner, worldMatrix);
            if (worldCorner.y < lowestY) {
                lowestY = worldCorner.y;
            }
        });
        
        // If any part is below the bench surface, lift the entire mesh
        if (lowestY < 0) {
            const adjustment = Math.abs(lowestY) + 0.1; // Add small buffer
            mesh.position.y += adjustment;
            console.log(`AUTO-LIFTED part by ${adjustment.toFixed(2)} units to keep on bench surface`);
        } else {
            console.log(`Part already on bench surface (lowest Y: ${lowestY.toFixed(2)})`);
        }
    }

    createPrecisionSliders(container) {
        // Create a label for the precision controls
        const label = new BABYLON.GUI.TextBlock();
        label.text = "Precision Move:";
        label.color = "white";
        label.fontSize = 12;
        label.heightInPixels = 20;
        label.paddingBottomInPixels = 5;
        container.addControl(label);
        
        // Create X axis slider
        const xSliderContainer = new BABYLON.GUI.StackPanel();
        xSliderContainer.isVertical = false;
        xSliderContainer.heightInPixels = 25;
        
        const xLabel = new BABYLON.GUI.TextBlock();
        xLabel.text = "X:";
        xLabel.color = "white";
        xLabel.fontSize = 10;
        xLabel.widthInPixels = 20;
        
        const xSlider = new BABYLON.GUI.Slider();
        xSlider.minimum = -50;
        xSlider.maximum = 50;
        xSlider.value = 0;
        xSlider.widthInPixels = 100;
        xSlider.heightInPixels = 20;
        xSlider.color = "#e74c3c";
        xSlider.background = "#34495e";
        
        xSlider.onValueChangedObservable.add((value) => {
            if (this.selectedPart) {
                const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (mesh) {
                    mesh.position.x = this.snapToGrid(value * 0.5); // Scale for fine control
                    this.updateDragHandlePositions(mesh);
                }
            }
        });
        
        xSliderContainer.addControl(xLabel);
        xSliderContainer.addControl(xSlider);
        container.addControl(xSliderContainer);
        
        // Create Z axis slider  
        const zSliderContainer = new BABYLON.GUI.StackPanel();
        zSliderContainer.isVertical = false;
        zSliderContainer.heightInPixels = 25;
        
        const zLabel = new BABYLON.GUI.TextBlock();
        zLabel.text = "Z:";
        zLabel.color = "white";
        zLabel.fontSize = 10;
        zLabel.widthInPixels = 20;
        
        const zSlider = new BABYLON.GUI.Slider();
        zSlider.minimum = -50;
        zSlider.maximum = 50;
        zSlider.value = 0;
        zSlider.widthInPixels = 100;
        zSlider.heightInPixels = 20;
        zSlider.color = "#3498db";
        zSlider.background = "#34495e";
        
        zSlider.onValueChangedObservable.add((value) => {
            if (this.selectedPart) {
                const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (mesh) {
                    mesh.position.z = this.snapToGrid(value * 0.5); // Scale for fine control
                    this.updateDragHandlePositions(mesh);
                }
            }
        });
        
        zSliderContainer.addControl(zLabel);
        zSliderContainer.addControl(zSlider);
        container.addControl(zSliderContainer);
        
        // Reset button
        const resetBtn = BABYLON.GUI.Button.CreateSimpleButton("resetPos", "Reset Position");
        resetBtn.widthInPixels = 120;
        resetBtn.heightInPixels = 25;
        resetBtn.color = "white";
        resetBtn.cornerRadius = 5;
        resetBtn.background = "#7f8c8d";
        resetBtn.fontSize = 10;
        
        resetBtn.onPointerUpObservable.add(() => {
            xSlider.value = 0;
            zSlider.value = 0;
            if (this.selectedPart) {
                const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (mesh) {
                    mesh.position.x = 0;
                    mesh.position.z = 0;
                    this.updateDragHandlePositions(mesh);
                }
            }
        });
        
        container.addControl(resetBtn);
    }
}

// Initialize Drawing World when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Create global reference for manipulation buttons
    window.drawingWorld = null;
    
    // Get project ID from URL params
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('id');
    
    if (projectId) {
        // Load project data
        const projects = JSON.parse(localStorage.getItem('cutlist-projects') || '[]');
        const project = projects.find(p => p.id === projectId);
        
        if (project) {
            document.getElementById('project-name').textContent = project.name;
            document.title = `CutList - ${project.name}`;
        }
    }
    
    // Initialize the 3D world
    const drawingWorld = new DrawingWorld();
    window.drawingWorld = drawingWorld;
    
    // Removed auto-spawning chamfered primitive
// DEBUG FUNCTIONS FOR LOADED VS FRESH BOARD INVESTIGATION
window.debugBoardComparison = function() {
    console.log('🔍 BOARD COMPARISON DEBUG STARTING...');
    console.log('📊 Total workbench parts:', drawingWorld.workBenchParts.length);
    
    drawingWorld.workBenchParts.forEach((part, index) => {
        console.log(`\n📋 BOARD ${index}:`, part);
        console.log(`   🆔 ID: ${part.id}`);
        console.log(`   📦 Material: ${part.materialId} (${part.materialName})`);
        console.log(`   📏 Dimensions: ${part.dimensions.length}x${part.dimensions.width}x${part.dimensions.thickness}`);
        console.log(`   🏷️ Grade: ${part.grade}`);
        console.log(`   📈 Status: ${part.status}`);
        if (part.cutHistory) console.log(`   ✂️ Cut History: `, part.cutHistory);
        if (part.meshGeometry) console.log(`   🧊 Geometry: `, part.meshGeometry);
    });
    
    const workbenchMeshes = drawingWorld.scene.meshes.filter(m => m.isWorkBenchPart);
    console.log(`\n🎭 MESH OBJECTS (${workbenchMeshes.length}):`);
    workbenchMeshes.forEach((mesh, index) => {
        console.log(`\n🎭 MESH ${index}:`, mesh);
        console.log(`   🆔 ID: ${mesh.id}`);
        console.log(`   🎨 Material: `, mesh.material);
        console.log(`   📍 Position: `, mesh.position);
        console.log(`   📐 Scaling: `, mesh.scaling);
        if (mesh.partData) console.log(`   🏷️ Part Data: `, mesh.partData);
    });
};

window.testLoadedBoardCutting = function() {
    console.log('✂️ TESTING LOADED BOARD CUTTING...');
    const workbenchMeshes = drawingWorld.scene.meshes.filter(m => m.isWorkBenchPart);
    if (workbenchMeshes.length === 0) {
        console.error('❌ No workbench parts found for cutting test');
        return;
    }
    
    console.log(`🎯 Found ${workbenchMeshes.length} workbench part(s) for cutting test`);
    workbenchMeshes.forEach((mesh, index) => {
        console.log(`\n🎯 TESTING MESH ${index} (ID: ${mesh.id})`);
        console.log('   📋 Part Data:', mesh.partData);
        console.log('   🎨 Material:', mesh.material);
        console.log('   📊 Properties:', {
            position: mesh.position,
            scaling: mesh.scaling,
            isWorkBenchPart: mesh.isWorkBenchPart
        });
    });
    
    console.log('🚨 Ready for manual cutting test - select a cutting tool and try cutting the loaded board');
};

window.identifyBoardDifferences = function() {
    console.log('🔬 IDENTIFYING BOARD DIFFERENCES...');
    if (drawingWorld.workBenchParts.length < 2) {
        console.error('❌ Need at least 2 boards to compare');
        return;
    }
    
    const board1 = drawingWorld.workBenchParts[0];
    const board2 = drawingWorld.workBenchParts[1];
    
    console.log('🆚 COMPARING BOARD PROPERTIES:');
    
    const props = ['id', 'materialId', 'materialName', 'grade', 'status', 'cutHistory', 'meshGeometry'];
    props.forEach(prop => {
        const val1 = board1[prop];
        const val2 = board2[prop];
        const match = JSON.stringify(val1) === JSON.stringify(val2);
        console.log(`   ${match ? '✅' : '❌'} ${prop}: ${match ? 'MATCH' : 'DIFFERENT'}`);
        if (!match) {
            console.log(`      🔹 Board 1: `, val1);
            console.log(`      🔹 Board 2: `, val2);
        }
    });
    
    console.log('\n🎭 COMPARING MESH OBJECTS:');
    const meshes = drawingWorld.scene.meshes.filter(m => m.isWorkBenchPart);
    if (meshes.length >= 2) {
        const mesh1 = meshes[0];
        const mesh2 = meshes[1];
        
        const meshProps = ['id', 'material.name', 'position', 'scaling'];
        meshProps.forEach(prop => {
            const val1 = prop.includes('.') ? mesh1[prop.split('.')[0]][prop.split('.')[1]] : mesh1[prop];
            const val2 = prop.includes('.') ? mesh2[prop.split('.')[0]][prop.split('.')[1]] : mesh2[prop];
            const match = JSON.stringify(val1) === JSON.stringify(val2);
            console.log(`   ${match ? '✅' : '❌'} ${prop}: ${match ? 'MATCH' : 'DIFFERENT'}`);
            if (!match) {
                console.log(`      🔹 Mesh 1: `, val1);
                console.log(`      🔹 Mesh 2: `, val2);
            }
        });
    }
};

console.log('🛠️ DEBUG FUNCTIONS LOADED:');
console.log('   debugBoardComparison() - Compare all boards');
console.log('   testLoadedBoardCutting() - Test cutting loaded boards');
console.log('   identifyBoardDifferences() - Find differences between boards');
});