// Drawing World with Babylon.js - UPDATED FOR CAMERA FOCUS FIX
// UNIT STANDARD: 1 unit = 1 cm (eventually selectable between metric/imperial)
console.log("ðŸš€ DRAWING-WORLD.JS LOADED - CAMERA FIX VERSION 2024-07-14 18:43:00 TIMESTAMP");
import { GridSystem } from './grid/GridSystem.js';
import { Shape2D } from './modules/Shape2D.js?v=20250112001';
import { CutToolSystem } from './modules/CutToolSystem.js';
import { RouterBitSystem } from './modules/RouterBitSystem.js';
import { ScrollCuttingSystem } from './modules/ScrollCuttingSystem.js';
import { PlaneToolSystem } from './modules/PlaneToolSystem.js';
import { JoinToolSystem } from './modules/JoinToolSystem.js';
import { DrillPressSystem } from './modules/DrillPressSystem.js';

/**
 * Modern Gizmo System Redesign
 * - Smooth, professional appearance
 * - Easy to grab with larger hit zones
 * - Buttery smooth movement
 * - Visual feedback on hover and drag
 */

class ModernGizmoSystem {
    constructor(scene, camera, canvas) {
        this.scene = scene;
        // Modern gizmo system
        this.modernGizmo = null;
        
        // Pointer tool system for compatibility
        this.pointerToolSystem = {
            setMode: (mode) => {
                console.log('Pointer tool mode set to:', mode);
                this.pointerMode = mode;
            },
            showPositionGizmo: (mesh) => {
                console.log('Showing position gizmo for mesh:', mesh.name);
                if (this.selectedPart) {
                    this.createDragHandles(mesh);
                }
            }
        };

        this.camera = camera;
        this.canvas = canvas;
        
        // Gizmo components
        this.gizmoRoot = null;
        this.axisHandles = [];
        this.planeHandles = [];
        this.centerSphere = null;
        
        // Interaction state
        this.isDragging = false;
        this.hoveredHandle = null;
        this.activeHandle = null;
        this.targetMesh = null;
        
        // Drag state
        this.dragStartPosition = null;
        this.dragPlane = null;
        this.dragOffset = null;
        
        // Visual settings
        this.axisLength = 3;
        this.axisThickness = 0.15;
        this.arrowSize = 0.5;
        this.originGap = 0.5; // Gap between arrows and origin
        this.planeSize = 0.8;
        this.centerSize = 0.3;
        
        // Colors
        this.colors = {
            x: new BABYLON.Color3(0.9, 0.2, 0.2),      // Soft red
            y: new BABYLON.Color3(0.2, 0.9, 0.2),      // Soft green
            z: new BABYLON.Color3(0.2, 0.2, 0.9),      // Soft blue
            xy: new BABYLON.Color3(0.9, 0.9, 0.2),     // Yellow
            xz: new BABYLON.Color3(0.9, 0.2, 0.9),     // Magenta
            yz: new BABYLON.Color3(0.2, 0.9, 0.9),     // Cyan
            hover: new BABYLON.Color3(1, 1, 0),        // Bright yellow
            active: new BABYLON.Color3(1, 0.5, 0),     // Orange
            center: new BABYLON.Color3(0.8, 0.8, 0.8)  // Light gray
        };
        
        this.setupObservables();
    }
    
    createGizmo(targetMesh) {
        this.dispose();
        this.targetMesh = targetMesh;
        
        // Create root node at mesh position
        this.gizmoRoot = new BABYLON.TransformNode("gizmoRoot", this.scene);
        this.updateGizmoPosition();
        
        // Create axis handles
        this.createAxisHandles();
        
        // Create plane handles
        this.createPlaneHandles();
        
        // Create center sphere for free movement
        this.createCenterSphere();
        
        // Setup scaling based on camera distance
        this.setupCameraDistanceScaling();
    }
    
    createAxisHandles() {
        // Calculate camera position for dynamic axis orientation
        const cameraPos = this.camera.position.subtract(this.gizmoRoot.position);
        const xDir = cameraPos.x > 0 ? 1 : -1;
        const zDir = cameraPos.z > 0 ? 1 : -1;
        
        const axes = [
            { name: 'x', direction: new BABYLON.Vector3(xDir, 0, 0), color: this.colors.x },
            { name: 'y', direction: new BABYLON.Vector3(0, 1, 0), color: this.colors.y },
            { name: 'z', direction: new BABYLON.Vector3(0, 0, zDir), color: this.colors.z }
        ];
        
        axes.forEach(axis => {
            // Create axis line
            const line = BABYLON.MeshBuilder.CreateCylinder(`axis_${axis.name}`, {
                height: this.axisLength - this.originGap,
                diameter: this.axisThickness,
                tessellation: 32
            }, this.scene);
            
            // Position and orient
            line.parent = this.gizmoRoot;
            // Position line starting from originGap distance
            line.position = axis.direction.scale(this.originGap + (this.axisLength - this.originGap) / 2);
            
            if (axis.name === 'x') line.rotation.z = Math.PI / 2;
            else if (axis.name === 'z') line.rotation.x = Math.PI / 2;
            
            // Create arrow cone
            const arrow = BABYLON.MeshBuilder.CreateCylinder(`arrow_${axis.name}`, {
                height: this.arrowSize,
                diameterTop: 0,
                diameterBottom: this.arrowSize,
                tessellation: 32
            }, this.scene);
            
            arrow.parent = this.gizmoRoot;
            arrow.position = axis.direction.scale(this.axisLength);
            
            if (axis.name === 'x') {
                arrow.rotation.z = axis.direction.x > 0 ? -Math.PI / 2 : Math.PI / 2;
            } else if (axis.name === "z") {
                arrow.rotation.x = axis.direction.z > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            // Create material
            const material = new BABYLON.StandardMaterial(`mat_${axis.name}`, this.scene);
            material.diffuseColor = new BABYLON.Color3(1, 1, 1); // Pure white
            material.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            material.emissiveColor = new BABYLON.Color3(1, 1, 1); // Self-illuminated white
            material.disableLighting = true;
            
            // Create solid black border with cloned geometry (no blur/depth)
            const borderSize = 1.5; // 20% larger for visible border
            
            // Black line border
            const blackLine = line.clone('border_line_' + axis.name);
            blackLine.parent = this.gizmoRoot;
            blackLine.position = line.position.clone(); // Match main line position
            blackLine.scaling.x = borderSize;
            blackLine.scaling.z = borderSize;
            blackLine.renderingGroupId = 0;
            
            // Black arrow border - create truncated cone for consistent border
            const borderWidth = 0.04;
            const blackArrow = BABYLON.MeshBuilder.CreateCylinder('border_arrow_' + axis.name, {
                height: this.arrowSize,
                diameterTop: borderWidth * 2,
                diameterBottom: this.arrowSize + borderWidth * 2,
                tessellation: 32
            }, this.scene);
            
            blackArrow.parent = this.gizmoRoot;
            blackArrow.position = axis.direction.scale(this.axisLength);
            
            if (axis.name === 'x') {
                blackArrow.rotation.z = axis.direction.x > 0 ? -Math.PI / 2 : Math.PI / 2;
            } else if (axis.name === 'z') {
                blackArrow.rotation.x = axis.direction.z > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
            
            blackArrow.renderingGroupId = 0;
            
            // Black material
            const blackMat = new BABYLON.StandardMaterial('border_mat_' + axis.name, this.scene);
            blackMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            blackMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
            blackMat.specularColor = new BABYLON.Color3(0, 0, 0);
            blackMat.disableLighting = true;
            
            blackLine.material = blackMat;
            blackArrow.material = blackMat;
            
            // White renders on top
            line.renderingGroupId = 1;
            arrow.renderingGroupId = 1; // No shadows or lighting
            
            line.material = material;
            arrow.material = material;
            
            // Create invisible hit box for easier selection
            const hitBox = BABYLON.MeshBuilder.CreateBox(`hitbox_${axis.name}`, {
                width: axis.name === 'x' ? this.axisLength - this.originGap : this.axisThickness * 3,
                height: axis.name === 'y' ? this.axisLength - this.originGap : this.axisThickness * 3,
                depth: axis.name === 'z' ? this.axisLength - this.originGap : this.axisThickness * 3
            }, this.scene);
            
            hitBox.parent = this.gizmoRoot;
            hitBox.position = axis.direction.scale((this.axisLength + this.originGap) / 2);
            hitBox.isVisible = false;
            hitBox.isPickable = true;
            
            // Store references
            const handle = {
                axis: axis.name,
                direction: axis.direction,
                line: line,
                arrow: arrow,
                hitBox: hitBox,
                material: material,
                defaultColor: axis.color.clone(),
                type: 'axis'
            };
            
            // Tag meshes
            [line, arrow, hitBox].forEach(mesh => {
                mesh.gizmoHandle = handle;
                mesh.isGizmo = true;
            });
            
            this.axisHandles.push(handle);
        });
    }
    
    createPlaneHandles() {
        const planes = [
            { name: 'xy', normal: new BABYLON.Vector3(0, 0, 1), color: this.colors.xy },
            { name: 'xz', normal: new BABYLON.Vector3(0, 1, 0), color: this.colors.xz },
            { name: 'yz', normal: new BABYLON.Vector3(1, 0, 0), color: this.colors.yz }
        ];
        
        planes.forEach(plane => {
            const planeMesh = BABYLON.MeshBuilder.CreatePlane(`plane_${plane.name}`, {
                size: this.planeSize
            }, this.scene);
            
            planeMesh.parent = this.gizmoRoot;
            // Position plane outward from origin
            const offset = this.planeSize / 2 + this.originGap / 2;
            if (plane.name === 'xy') {
                planeMesh.position = new BABYLON.Vector3(offset, offset, 0);
            } else if (plane.name === 'xz') {
                planeMesh.position = new BABYLON.Vector3(offset, 0, offset);
            } else if (plane.name === 'yz') {
                planeMesh.position = new BABYLON.Vector3(0, offset, offset);
            }
            
            // Orient plane
            if (plane.name === 'xz') {
                planeMesh.rotation.x = Math.PI / 2;
            } else if (plane.name === 'yz') {
                planeMesh.rotation.y = Math.PI / 2;
            }
            
            // Create material
            const material = new BABYLON.StandardMaterial(`mat_plane_${plane.name}`, this.scene);
            material.diffuseColor = new BABYLON.Color3(1, 1, 1); // Pure white
            material.alpha = 0.3;
            material.backFaceCulling = false;
            material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            material.disableLighting = true;
            
            planeMesh.material = material;
            
            // Store reference
            const handle = {
                name: plane.name,
                normal: plane.normal,
                mesh: planeMesh,
                material: material,
                defaultColor: plane.color.clone(),
                defaultAlpha: 0.3,
                type: 'plane'
            };
            
            planeMesh.gizmoHandle = handle;
            planeMesh.isGizmo = true;
            
            // Create border plane for visibility
            const borderPlane = planeMesh.clone('border_plane_' + plane.name);
            borderPlane.parent = this.gizmoRoot;
            borderPlane.scaling = new BABYLON.Vector3(1.1, 1.1, 1.1); // 10% larger
            borderPlane.position = planeMesh.position.clone();
            borderPlane.rotation = planeMesh.rotation.clone();
            
            const borderMat = new BABYLON.StandardMaterial('mat_border_plane_' + plane.name, this.scene);
            borderMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3); // Dark gray
            borderMat.alpha = 0.5;
            borderMat.backFaceCulling = false;
            borderMat.disableLighting = true;
            borderPlane.material = borderMat;
            borderPlane.renderingGroupId = 0; // Render behind main plane
            planeMesh.renderingGroupId = 1;
            
            this.planeHandles.push(handle);
        });
    }
    
    createCenterSphere() {
        this.centerSphere = BABYLON.MeshBuilder.CreateSphere("gizmo_center", {
            diameter: this.centerSize,
            segments: 16
        }, this.scene);
        
        this.centerSphere.parent = this.gizmoRoot;
        
        const material = new BABYLON.StandardMaterial("mat_center", this.scene);
        material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        material.specularColor = new BABYLON.Color3(0, 0, 0);
        material.emissiveColor = new BABYLON.Color3(1, 1, 1);
        material.disableLighting = true;
        
        this.centerSphere.material = material;
        
        const handle = {
            type: 'center',
            mesh: this.centerSphere,
            material: material,
            defaultColor: this.colors.center.clone()
        };
        
        this.centerSphere.gizmoHandle = handle;
        this.centerSphere.isGizmo = true;
    }
    
    setupCameraDistanceScaling() {
        // Scale gizmo based on distance from camera
        this.scene.registerBeforeRender(() => {
            if (!this.gizmoRoot || !this.targetMesh) return;
            
            const distance = BABYLON.Vector3.Distance(
                this.camera.position,
                this.gizmoRoot.position
            );
            
            // Scale factor based on distance
            const scale = Math.max(distance * 0.05, 1);
            this.gizmoRoot.scaling = new BABYLON.Vector3(scale, scale, scale);
        });
    }
    
    setupObservables() {
        // Pointer move for hover effects
        this.scene.onPointerObservable.add((pointerInfo) => {
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.handlePointerMove(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    this.handlePointerDown(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    this.handlePointerUp(pointerInfo);
                    break;
            }
        });
    }
    
    handlePointerMove(pointerInfo) {
        if (this.isDragging) {
            this.updateDrag(pointerInfo);
            return;
        }
        
        // Check for hover
        const pickInfo = this.scene.pick(
            this.scene.pointerX,
            this.scene.pointerY,
            (mesh) => mesh.isGizmo
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh.gizmoHandle) {
            this.setHoveredHandle(pickInfo.pickedMesh.gizmoHandle);
        } else {
            this.setHoveredHandle(null);
        }
    }
    
    handlePointerDown(pointerInfo) {
        if (pointerInfo.event.button !== 0) return; // Only left click
        
        const pickInfo = pointerInfo.pickInfo;
        if (pickInfo.hit && pickInfo.pickedMesh.isGizmo) {
            this.startDrag(pickInfo.pickedMesh.gizmoHandle, pickInfo);
        }
    }
    
    handlePointerUp(pointerInfo) {
        if (this.isDragging) {
            this.endDrag();
        }
    }
    
    setHoveredHandle(handle) {
        if (this.hoveredHandle === handle) return;
        
        // Reset previous hover
        if (this.hoveredHandle) {
            this.resetHandleAppearance(this.hoveredHandle);
        }
        
        this.hoveredHandle = handle;
        
        // Apply hover effect
        if (handle && !this.isDragging) {
            this.applyHoverEffect(handle);
        }
    }
    
    applyHoverEffect(handle) {
        if (handle.type === 'axis') {
            // Change to axis color on hover
            const axisColor = this.colors[handle.axis];
            handle.material.emissiveColor = axisColor;
            handle.material.diffuseColor = axisColor;
            handle.material.emissiveColor = axisColor;
            handle.material.diffuseColor = axisColor;
        } else if (handle.type === 'plane') {
            handle.material.alpha = 0.5;
            handle.material.emissiveColor = this.colors.hover.scale(0.3);
        } else if (handle.type === 'center') {
            handle.material.emissiveColor = this.colors.hover.scale(0.5);
            handle.mesh.scaling = new BABYLON.Vector3(1.2, 1.2, 1.2);
        }
    }
    
    resetHandleAppearance(handle) {
        if (handle.type === 'axis') {
            handle.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            handle.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            handle.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            handle.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
            handle.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            handle.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        } else if (handle.type === 'plane') {
            handle.material.alpha = handle.defaultAlpha;
            handle.material.emissiveColor = handle.defaultColor.scale(0.2);
        } else if (handle.type === 'center') {
            handle.material.emissiveColor = handle.defaultColor.scale(0.2);
            handle.mesh.scaling = BABYLON.Vector3.One();
        }
    }
    
    startDrag(handle, pickInfo) {
        this.isDragging = true;
        this.activeHandle = handle;
        this.dragStartPosition = this.targetMesh.position.clone();
        
        // Calculate drag offset - difference between mesh position and picked point
        if (pickInfo && pickInfo.pickedPoint) {
            this.dragOffset = this.targetMesh.position.subtract(pickInfo.pickedPoint);
        } else {
            this.dragOffset = BABYLON.Vector3.Zero();
        }
        
        // Disable camera control
        this.camera.detachControl(this.canvas);
        
        // Apply active appearance
        handle.material.emissiveColor = this.colors.active.scale(0.6);
        
        // Setup drag plane based on handle type
        this.setupDragPlane(handle, pickInfo);
    }
    
    setupDragPlane(handle, pickInfo) {
        const meshPosition = this.targetMesh.position;
        
        if (handle.type === 'axis') {
            // Create plane perpendicular to camera that contains the axis
            const cameraDirection = this.camera.position.subtract(meshPosition).normalize();
            const normal = BABYLON.Vector3.Cross(handle.direction, cameraDirection).normalize();
            
            // If axis is parallel to camera, use alternate plane
            if (normal.length() < 0.1) {
                normal.copyFrom(BABYLON.Vector3.Cross(handle.direction, BABYLON.Vector3.Up()).normalize());
            }
            
            this.dragPlane = BABYLON.Plane.FromPositionAndNormal(meshPosition, normal);
            
        } else if (handle.type === 'plane') {
            // Use the plane's normal
            this.dragPlane = BABYLON.Plane.FromPositionAndNormal(meshPosition, handle.normal);
            
        } else if (handle.type === 'center') {
            // Use screen-aligned plane
            const cameraDirection = this.camera.position.subtract(meshPosition).normalize();
            this.dragPlane = BABYLON.Plane.FromPositionAndNormal(meshPosition, cameraDirection);
        }
    }
    
    updateDrag(pointerInfo) {
        if (!this.isDragging || !this.activeHandle || !this.dragPlane) return;
        
        // Create ray from mouse position
        const ray = this.scene.createPickingRay(
            this.scene.pointerX,
            this.scene.pointerY,
            BABYLON.Matrix.Identity(),
            this.camera
        );
        
        // Find intersection with drag plane
        const distance = this.dragPlane.intersectsLine(ray);
        if (!distance) return;
        
        const pickedPoint = ray.origin.add(ray.direction.scale(distance));
        let newPosition = pickedPoint.add(this.dragOffset);
        
        // Apply constraints based on handle type
        if (this.activeHandle.type === 'axis') {
            // Project movement onto axis
            const movement = newPosition.subtract(this.dragStartPosition);
            const axisMovement = BABYLON.Vector3.Dot(movement, this.activeHandle.direction);
            newPosition = this.dragStartPosition.add(
                this.activeHandle.direction.scale(axisMovement)
            );
            
        } else if (this.activeHandle.type === 'plane') {
            // Constrain to plane (remove component along normal)
            const movement = newPosition.subtract(this.dragStartPosition);
            const normalComponent = BABYLON.Vector3.Dot(movement, this.activeHandle.normal);
            newPosition = newPosition.subtract(
                this.activeHandle.normal.scale(normalComponent)
            );
        }
        
        // Apply position
        this.targetMesh.position = newPosition;
        this.updateGizmoPosition();
        
        // Update board transform data (convert from cm to inches)
        if (this.targetMesh.board) {
            this.targetMesh.board.transform.position.x = newPosition.x / 2.54;
            this.targetMesh.board.transform.position.y = newPosition.y / 2.54;
            this.targetMesh.board.transform.position.z = newPosition.z / 2.54;
            
            console.log('Updated board position:', this.targetMesh.board.transform.position);
        }
    }
    
    endDrag() {
        this.isDragging = false;
        
        // Re-enable camera control
        this.camera.attachControl(this.canvas, true);
        
        // Reset appearance
        if (this.activeHandle) {
            this.resetHandleAppearance(this.activeHandle);
        }
        
        this.activeHandle = null;
        this.dragPlane = null;
        this.dragOffset = null;
    }
    
    updateGizmoPosition() {
        if (this.gizmoRoot && this.targetMesh) {
            this.gizmoRoot.position = this.targetMesh.position.clone();
            // Add Y-axis offset to position gizmo above the object
            this.gizmoRoot.position.y += 10; // 10 units above the object center
        }
    }
    
    show() {
        if (this.gizmoRoot) {
            this.gizmoRoot.setEnabled(true);
            
            // Start updating axis orientations based on camera
            if (!this.updateObserver) {
                this.updateObserver = this.scene.onBeforeRenderObservable.add(() => {
                    this.updateAxisOrientations();
                });
            }
        }
    }
    
    hide() {
        if (this.gizmoRoot) {
            this.gizmoRoot.setEnabled(false);
            
            // Stop updating
            if (this.updateObserver) {
                this.scene.onBeforeRenderObservable.remove(this.updateObserver);
                this.updateObserver = null;
            }
        }
    }
    
    updateAxisOrientations() {
        if (!this.gizmoRoot || !this.gizmoRoot.isEnabled()) return;
        
        // Calculate camera position relative to gizmo
        const cameraPos = this.camera.position.subtract(this.gizmoRoot.position);
        const xDir = cameraPos.x > 0 ? 1 : -1;
        const zDir = cameraPos.z > 0 ? 1 : -1;
        
        // Update X axis
        const xLine = this.scene.getMeshByName('axis_x');
        const xArrow = this.scene.getMeshByName('arrow_x');
        const xBlackLine = this.scene.getMeshByName('border_line_x');
        const xBlackArrow = this.scene.getMeshByName('border_arrow_x');
        
        if (xLine && xArrow) {
            console.log('Found X axis meshes, xDir:', xDir);
            // Update positions
            xLine.position.x = xDir * (this.originGap + (this.axisLength - this.originGap) / 2);
            xLine.position.y = 0;
            xLine.position.z = 0;
            xArrow.position.x = xDir * this.axisLength;
            xArrow.position.y = 0;
            xArrow.position.z = 0;
            
            // Update rotations
            xArrow.rotation.z = xDir > 0 ? -Math.PI / 2 : Math.PI / 2;
            
            if (xBlackLine && xBlackArrow) {
                // Update black line position to match main line
                xBlackLine.position.x = xDir * (this.originGap + (this.axisLength - this.originGap) / 2);
                xBlackLine.position.y = 0;
                xBlackLine.position.z = 0;
                
                // Update black arrow position to match main arrow
                xBlackArrow.position.x = xDir * this.axisLength;
                xBlackArrow.position.y = 0;
                xBlackArrow.position.z = 0;
                xBlackArrow.rotation.z = xDir > 0 ? -Math.PI / 2 : Math.PI / 2;
            }
        }
        
        // Update Z axis
        const zLine = this.scene.getMeshByName('axis_z');
        const zArrow = this.scene.getMeshByName('arrow_z');
        const zBlackLine = this.scene.getMeshByName('border_line_z');
        const zBlackArrow = this.scene.getMeshByName('border_arrow_z');
        
        if (zLine && zArrow) {
            console.log('Found Z axis meshes, zDir:', zDir);
            // Update positions
            zLine.position.x = 0;
            zLine.position.y = 0;
            zLine.position.z = zDir * (this.originGap + (this.axisLength - this.originGap) / 2);
            zArrow.position.x = 0;
            zArrow.position.y = 0;
            zArrow.position.z = zDir * this.axisLength;
            
            // Update rotations
            zArrow.rotation.x = zDir > 0 ? Math.PI / 2 : -Math.PI / 2;
            
            if (zBlackLine && zBlackArrow) {
                // Update black line position to match main line
                zBlackLine.position.x = 0;
                zBlackLine.position.y = 0;
                zBlackLine.position.z = zDir * (this.originGap + (this.axisLength - this.originGap) / 2);
                
                // Update black arrow position to match main arrow
                zBlackArrow.position.x = 0;
                zBlackArrow.position.y = 0;
                zBlackArrow.position.z = zDir * this.axisLength;
                zBlackArrow.rotation.x = zDir > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
        }
        
        // Update drag planes to stay between axes
        const planeOffset = 0.15; // Offset from axes
        const xyPlane = this.scene.getMeshByName('plane_xy');
        const xzPlane = this.scene.getMeshByName('plane_xz');
        const yzPlane = this.scene.getMeshByName('plane_yz');
        
        console.log('Drag planes found:', { xy: !!xyPlane, xz: !!xzPlane, yz: !!yzPlane });
        
        if (xyPlane) {
            // XY plane moves with X axis (offset from both X and Y axes)
            xyPlane.position.x = xDir * (this.planeSize / 2 + this.originGap / 2);
            xyPlane.position.y = this.planeSize / 2 + this.originGap / 2;
            xyPlane.position.z = -planeOffset;
            
            // Update border plane too
            const xyBorder = this.scene.getMeshByName('border_plane_xy');
            if (xyBorder) {
                xyBorder.position.x = xyPlane.position.x;
                xyBorder.position = xyPlane.position.clone();
            }
        }
        
        if (xzPlane) {
            // XZ plane moves with both X and Z (offset from both axes)
            xzPlane.position.x = xDir * (this.planeSize / 2 + this.originGap / 2);
            xzPlane.position.y = -planeOffset;
            xzPlane.position.z = zDir * (this.planeSize / 2 + this.originGap / 2);
            
            // Update border plane too
            const xzBorder = this.scene.getMeshByName('border_plane_xz');
            if (xzBorder) {
                xzBorder.position.x = xzPlane.position.x;
                xzBorder.position = xzPlane.position.clone();
            }
        }
        
        if (yzPlane) {
            // YZ plane moves with Z axis (offset from both Y and Z axes)
            yzPlane.position.x = -planeOffset;
            yzPlane.position.y = this.planeSize / 2 + this.originGap / 2;
            yzPlane.position.z = zDir * (this.planeSize / 2 + this.originGap / 2);
            
            // Update border plane too
            const yzBorder = this.scene.getMeshByName('border_plane_yz');
            if (yzBorder) {
                yzBorder.position.x = yzPlane.position.x;
                yzBorder.position = yzPlane.position.clone();
            }
        }
    }
    
    dispose() {
        if (this.gizmoRoot) {
            this.gizmoRoot.dispose();
            this.gizmoRoot = null;
        }
        
        this.axisHandles = [];
        this.planeHandles = [];
        this.centerSphere = null;
        this.hoveredHandle = null;
        this.activeHandle = null;
        this.targetMesh = null;
    }
}

class DrawingWorld {
    constructor() {
        this.canvas = document.getElementById('renderCanvas');
        this.engine = null;
        this.scene = null;
        this.camera = null;
        this.grid = null;
        this.currentMode = 'model'; // Always start in 3D modeling mode
        this.sketchPlanes = [];
        this.selectedObject = null;
        
        // Initialize sketch drawing state
        this.closedShapes = [];
        
        // Initialize grid system
        this.lastGridCenter = null;
        
        // Initialize shape2D system
        this.shape2D = null;
        
        // Sketch tool state
        this.sketchToolSelected = false;
        this.waitingForSurface = false;
        this.isExtruding = false;
        
        // Active tool state
        this.activeTool = null;
        
        // Default sketch planes
        this.defaultSketchPlanes = null;
        
        // Materials system
        this.materialsLibrary = null;
        this.boardFactory = null;
        this.projectParts = [];
        this.workBenchParts = [];
        this.selectedMaterial = null;
        
        // Bench system
        this.currentBench = 'work'; // 'work' or 'assembly'
        this.currentWorkPart = null;
        
        // 3D Manipulation system
        this.selectedPart = null;
        this.manipulationGUI = null;
        this.dragHandles = null;
        
        // Cut tool system
        this.cutToolSystem = null;
        
        // Router bit system
        this.routerBitSystem = null;
        
        // Scroll cutting system
        this.scrollCuttingSystem = null;
        
        // Join tool system
        this.joinToolSystem = null;
        
        this.init();
    }

    // === MATERIALS SYSTEM ===
    async initializeMaterialsSystem() {
        try {
            console.log('Initializing materials system...');
            this.materialsLibrary = new MaterialsLibrary();
            
            // Initialize BoardFactory
            this.boardFactory = new BoardFactory(this.scene, this.materialsLibrary);
            console.log("BoardFactory initialized");
            
            // TEST: Verify Board system is available
            if (typeof Board !== "undefined" && typeof BoardFactory !== "undefined") {
                console.log("âœ… Board system loaded successfully");
                console.log("   Board class:", typeof Board);
                console.log("   BoardFactory class:", typeof BoardFactory);
                console.log("   boardFactory instance:", this.boardFactory ? "initialized" : "not initialized");
            } else {
                console.error("âŒ Board system not loaded properly");
            }
            
            console.log('Materials system initialized successfully');
        } catch (error) {
            console.error('Failed to initialize materials system:', error);
            // Create a basic materials library fallback
            this.materialsLibrary = {
                getMaterials: () => [],
                getMaterial: () => null
            };
        }
    }
    
        async init() {
        // Initialize Babylon.js
        this.engine = new BABYLON.Engine(this.canvas, true);
        this.scene = new BABYLON.Scene(this.engine);
        // Enable outline renderer for gizmo halo effect
        this.scene.outlineRenderer = new BABYLON.OutlineRenderer(this.scene);
        
        // Set light background color
        this.scene.clearColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        
        // Try to increase line width globally  
        const gl = this.engine._gl;
        if (gl) {
            gl.lineWidth(4.0); // Attempt to set thicker lines
        }
        
        // Also try setting line width at engine level
        this.engine.setHardwareScalingLevel(1.0);
        
        // Set up custom line material for thick lines
        this.setupThickLineMaterial();
        
        // Set up camera
        this.setupCamera();
        
        // Initialize grid LOD system
        this.initializeGridLOD();
        
        // Set up lighting
        this.setupLighting();
        
        // Set up grid
        this.setupGrid();
        
        // Set up sketch planes - DISABLED for now
        // this.setupSketchPlanes();
        
        // Set up event listeners
        
        // Set up selection system
        this.setupSelectionSystem();
        
        // Initialize materials system
        await this.initializeMaterialsSystem();

        // Set up event listeners (moved after materials system)
        this.setupEventListeners();
        
        // Initialize drag handle interaction
        this.enableDragHandleInteraction();
        
        // Initialize cut tool system
        this.cutToolSystem = new CutToolSystem(this);
        
        // Initialize router bit system
        this.routerBitSystem = new RouterBitSystem(this);
        
        // Initialize scroll cutting system
        this.scrollCuttingSystem = new ScrollCuttingSystem(this);
        
        // Initialize plane tool system
        this.planeToolSystem = new PlaneToolSystem(this);
        
        
        // Initialize join tool system
        this.joinToolSystem = new JoinToolSystem(this);
        
        // Initialize drill press system
        this.drillPressSystem = new DrillPressSystem(this);
        
        // Initialize preferences system
        this.initializePreferencesSystem();
        
        // Start render loop (simplified - no render loop modifications)
        this.engine.runRenderLoop(() => {
            // Update gizmo scaling based on camera distance
            this.updateExtrusionGizmoScale();
            
            // Enforce camera height constraint - cannot go below 4 units above XY plane
            this.enforceMinimumCameraHeight();
            
            this.scene.render();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.engine.resize();
        });
        
        // Initialize tool groups to correct state
        this.updateToolGroups();
        
        // DRAMATIC OPENING: Professional opening animation
        this.performOpeningAnimation();
        
    }
    
    /**
     * Create a native chamfered box using vertex geometry - no CSG
     */
    createChamferedBoardPrimitive() {
        // Create a simple box with chamfered front edge using vertices/indices
        const L = 50;  // Length
        const W = 15;  // Width
        const H = 5;   // Height
        const C = 3;   // Chamfer size
        
        // Define 12 vertices for a box with front edge chamfered
        const positions = [
            // Bottom vertices (6 vertices due to chamfer)
            -L/2, -H/2, -W/2 + C,     // 0: front-left bottom (chamfered)
            -L/2 + C, -H/2, -W/2,     // 1: front-left bottom (chamfer point)
            L/2 - C, -H/2, -W/2,      // 2: front-right bottom (chamfer point)
            L/2, -H/2, -W/2 + C,      // 3: front-right bottom (chamfered)
            L/2, -H/2, W/2,           // 4: back-right bottom
            -L/2, -H/2, W/2,          // 5: back-left bottom
            
            // Top vertices (6 vertices due to chamfer)
            -L/2, H/2, -W/2 + C,      // 6: front-left top (chamfered)
            -L/2 + C, H/2, -W/2,      // 7: front-left top (chamfer point)
            L/2 - C, H/2, -W/2,       // 8: front-right top (chamfer point)
            L/2, H/2, -W/2 + C,       // 9: front-right top (chamfered)
            L/2, H/2, W/2,            // 10: back-right top
            -L/2, H/2, W/2,           // 11: back-left top
        ];
        
        // Define triangular faces (each face needs 2 triangles)
        const indices = [
            // Bottom face (4 triangles for chamfered hexagon)
            0, 1, 5,  1, 2, 5,  2, 4, 5,  2, 3, 4,
            
            // Top face (4 triangles for chamfered hexagon)
            6, 11, 7,  7, 11, 10,  7, 10, 8,  8, 10, 9,
            
            // Side faces
            0, 5, 6,  5, 11, 6,    // Left face
            3, 9, 4,  4, 9, 10,    // Right face  
            4, 10, 5, 5, 10, 11,   // Back face
            
            // Chamfered front faces
            0, 6, 1,  1, 6, 7,     // Left chamfer
            1, 7, 2,  2, 7, 8,     // Front face
            2, 8, 3,  3, 8, 9,     // Right chamfer
            
            // Connect top and bottom chamfer
            0, 3, 6,  3, 9, 6,     // Connect chamfered corners
        ];
        
        // Create the mesh
        const chamferedBox = new BABYLON.Mesh("native_chamfered_box", this.scene);
        
        const vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        
        // Compute normals
        const normals = [];
        BABYLON.VertexData.ComputeNormals(positions, indices, normals);
        vertexData.normals = normals;
        
        vertexData.applyToMesh(chamferedBox);
        
        // Position and material
        chamferedBox.position = new BABYLON.Vector3(0, H/2, 0);
        
        // Apply material with texture
        material.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
        chamferedBox.material = material;
        
        chamferedBox.isWorkBenchPart = true;
        
        console.log('DrawingWorld: Created NATIVE chamfered box with vertex geometry - no original box exists');
        
        return chamferedBox;
    }

    setupCamera() {
        // Arc rotate camera (perfect for CAD applications)
        this.camera = new BABYLON.ArcRotateCamera(
            'camera',
            -Math.PI / 4, // 45 degrees from front-left angle
            Math.PI / 3,  // 60 degrees elevation
            200, // Start 2 meters away (200cm = 2m)
            BABYLON.Vector3.Zero(),
            this.scene
        );
        
        // COMPLETELY DISABLE default controls - we'll implement proper CAD controls
        // Don't attach controls at all to avoid conflicts
        // this.camera.attachControl(this.canvas, false);
        
        // Set camera limits - prevent going below bench surface
        this.camera.setTarget(BABYLON.Vector3.Zero());
        this.camera.lowerBetaLimit = 0.01;
        this.camera.upperBetaLimit = Math.PI / 2 - 0.1;
        this.camera.lowerRadiusLimit = 2;
        this.camera.upperRadiusLimit = 1000;
        
        // Set near/far planes to reduce clipping issues
        this.camera.minZ = 0.01;
        this.camera.maxZ = 1000;
        
        // Responsive camera movement - almost no inertia
        this.camera.inertia = 0.1;
        this.camera.wheelPrecision = 2;
        this.camera.pinchPrecision = 25;
        
        // Setup PROFESSIONAL camera controls like Shapr3D/Blender
        this.setupProfessionalCameraControls();
    }

    setupProfessionalCameraControls() {
        // Camera control state
        this.cameraState = {
            isOrbiting: false,
            isPanning: false,
            lastPointerX: 0,
            lastPointerY: 0
        };

        // Mouse/pointer event handlers for professional CAD controls
        this.canvas.addEventListener('pointerdown', (evt) => this.onCameraPointerDown(evt));
        this.canvas.addEventListener('pointermove', (evt) => this.onCameraPointerMove(evt));
        this.canvas.addEventListener('pointerup', (evt) => this.onCameraPointerUp(evt));
        this.canvas.addEventListener('wheel', (evt) => this.onCameraWheel(evt));
        
        // Prevent context menu on right-click
        this.canvas.addEventListener('contextmenu', (evt) => evt.preventDefault());
        
        console.log('Shapr3D-style camera controls enabled:');
        console.log('- LEFT CLICK: Tools and picking ONLY');
        console.log('- RIGHT CLICK + DRAG: Spin the world (orbit around object)'); 
        console.log('- MIDDLE CLICK + DRAG: Pan view');
        console.log('- WHEEL: Zoom in/out');
    }
    
    /**
     * Update camera target to center of visible objects for better orbiting
     */
    updateCameraTargetToObjects() {
        // Find all visible project parts and work bench parts
        const allParts = this.scene.meshes.filter(mesh => 
            (mesh.isProjectPart || mesh.isWorkBenchPart) && mesh.isVisible
        );
        
        if (allParts.length === 0) {
            console.log('No visible parts found, keeping current target');
            return;
        }
        
        // Calculate center of all parts
        let totalX = 0, totalY = 0, totalZ = 0;
        let validParts = 0;
        
        allParts.forEach(part => {
            if (part.position) {
                totalX += part.position.x;
                totalY += part.position.y;
                totalZ += part.position.z;
                validParts++;
            }
        });
        
        if (validParts > 0) {
            const centerX = totalX / validParts;
            const centerY = totalY / validParts;
            const centerZ = totalZ / validParts;
            
            const newTarget = new BABYLON.Vector3(centerX, centerY, centerZ);
            this.camera.setTarget(newTarget);
            
            console.log(`Updated camera target to center of ${validParts} objects:`, newTarget);
        }
    }
    
    /**
     * Initialize preferences system for user-configurable settings
     */
    initializePreferencesSystem() {
        // Default preferences
        this.preferences = {
            panSpeed: 0.3,
            rotateSpeed: 0.003,
            zoomSpeed: 12,
            units: "imperial"
        };
        
        // Load preferences from localStorage
        this.loadPreferences();
        
        // Setup preferences modal
        this.setupPreferencesModal();
        
        console.log('Preferences system initialized:', this.preferences);
    }
    
    /**
     * Load preferences from localStorage
     */
    loadPreferences() {
        const saved = localStorage.getItem('cutlist-preferences');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                this.preferences = { ...this.preferences, ...parsed };
                console.log('Loaded preferences from localStorage:', this.preferences);
            } catch (e) {
                console.warn('Failed to load preferences from localStorage:', e);
            }
        }
    }
    
    /**
     * Save preferences to localStorage
     */
    savePreferences() {
        localStorage.setItem('cutlist-preferences', JSON.stringify(this.preferences));
        console.log('Saved preferences to localStorage:', this.preferences);
    }
    
    /**
     * Setup preferences modal and event listeners
     */
    setupPreferencesModal() {
        const preferencesBtn = document.getElementById('preferences-btn');
        const preferencesModal = document.getElementById('preferences-modal');
        const closeBtn = document.getElementById('close-preferences-modal');
        const applyBtn = document.getElementById('apply-preferences');
        const resetBtn = document.getElementById('reset-preferences');
        
        // Open modal
        preferencesBtn.addEventListener('click', () => {
            this.showPreferencesModal();
        });
        
        // Close modal
        closeBtn.addEventListener('click', () => {
            this.hidePreferencesModal();
        });
        
        // Close on outside click
        preferencesModal.addEventListener('click', (e) => {
            if (e.target === preferencesModal) {
                this.hidePreferencesModal();
            }
        });
        
        // Apply changes
        applyBtn.addEventListener('click', () => {
            this.applyPreferences();
        });
        
        // Reset to defaults
        resetBtn.addEventListener('click', () => {
            this.resetPreferences();
        });
        
        // Update slider values in real-time
        const sliders = ['pan-speed', 'rotate-speed', 'zoom-speed'];
        sliders.forEach(sliderId => {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(sliderId + '-value');
            
            slider.addEventListener('input', (e) => {
                valueDisplay.textContent = e.target.value;
            });
        });
    }
    
    /**
     * Show preferences modal
     */
    showPreferencesModal() {
        const modal = document.getElementById('preferences-modal');
        
        // Load current values into sliders
        document.getElementById('pan-speed').value = this.preferences.panSpeed;
        document.getElementById('pan-speed-value').textContent = this.preferences.panSpeed;
        
        document.getElementById('rotate-speed').value = this.preferences.rotateSpeed;
        document.getElementById('rotate-speed-value').textContent = this.preferences.rotateSpeed;
        
        document.getElementById('zoom-speed').value = this.preferences.zoomSpeed;
        document.getElementById('zoom-speed-value').textContent = this.preferences.zoomSpeed;
        
        modal.style.display = 'flex';
    }
    
    /**
     * Hide preferences modal
     */
    hidePreferencesModal() {
        const modal = document.getElementById('preferences-modal');
        modal.style.display = 'none';
    }
    
    /**
     * Apply preferences from modal
     */
    applyPreferences() {
        // Get values from sliders
        this.preferences.panSpeed = parseFloat(document.getElementById('pan-speed').value);
        this.preferences.rotateSpeed = parseFloat(document.getElementById('rotate-speed').value);
        this.preferences.zoomSpeed = parseFloat(document.getElementById('zoom-speed').value);
        
        // Save to localStorage
        this.savePreferences();
        
        // Hide modal
        this.hidePreferencesModal();
        
        console.log('Applied preferences:', this.preferences);
    }
    
    /**
     * Reset preferences to defaults
     */
    resetPreferences() {
        this.preferences = {
            panSpeed: 0.3,
            rotateSpeed: 0.003,
            zoomSpeed: 12
        };
        
        // Update sliders
        document.getElementById('pan-speed').value = this.preferences.panSpeed;
        document.getElementById('pan-speed-value').textContent = this.preferences.panSpeed;
        
        document.getElementById('rotate-speed').value = this.preferences.rotateSpeed;
        document.getElementById('rotate-speed-value').textContent = this.preferences.rotateSpeed;
        
        document.getElementById('zoom-speed').value = this.preferences.zoomSpeed;
        document.getElementById('zoom-speed-value').textContent = this.preferences.zoomSpeed;
        
        console.log('Reset preferences to defaults');
    }

    /**
     * DRAMATIC OPENING: Professional opening animation for CutList
     * Creates a cinematic introduction that showcases the precision and quality of the CAD system
     */
    performOpeningAnimation() {
        console.log('Starting dramatic opening animation for CutList');
        
        // Start from a dramatic wide shot
        const startPosition = new BABYLON.Vector3(0, 300, 500);
        const startTarget = new BABYLON.Vector3(0, 0, 0);
        
        // End at professional working position - centered
        const endPosition = new BABYLON.Vector3(80, 60, 120);
        const endTarget = new BABYLON.Vector3(0, 0, 0);
        
        // Set initial dramatic position immediately - no flash
        this.camera.position = startPosition;
        this.camera.setTarget(startTarget);
        
        // Animation parameters - crisp 2.5 second cutscene
        const animationDuration = 150; // 2.5 seconds at 60fps
        const startTime = Date.now();
        
        // Professional ease-in-out cubic (slow start, fast middle, slow end)
        const easeInOutCubic = (t) => {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        };
        
        // Cinematic opening animation
        const animateOpening = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / (animationDuration * 1000 / 60), 1);
            const easedProgress = easeInOutCubic(progress);
            
            // Smooth camera descent and approach
            this.camera.position = BABYLON.Vector3.Lerp(startPosition, endPosition, easedProgress);
            this.camera.setTarget(BABYLON.Vector3.Lerp(startTarget, endTarget, easedProgress));
            
            // Continue animation
            if (progress < 1) {
                requestAnimationFrame(animateOpening);
            } else {
                console.log('CutList opening animation complete - Ready for work!');
                // No bounce - just clean finish
            }
        };
        
        // Start the opening animation
        requestAnimationFrame(animateOpening);
    }
    
    /**
     * Subtle bounce animation to indicate system is ready
     */
    performReadyBounce() {
        // Removed bounce - clean cutscene finish
        console.log('CutList is ready for professional woodworking!');
    }

    onCameraPointerDown(evt) {
        // Don't interfere with drag handle operations
        if (this.isDragging) return;

        this.cameraState.lastPointerX = evt.offsetX;
        this.cameraState.lastPointerY = evt.offsetY;

        // Reset camera states first
        this.cameraState.isOrbiting = false;
        this.cameraState.isPanning = false;

        if (evt.button === 0) {
            // LEFT MOUSE: Tools and picking ONLY - no camera control
            return; // Let tools handle left mouse
        } else if (evt.button === 1) {
            // MIDDLE MOUSE: Pan (move camera and target together)
            this.cameraState.isPanning = true;
            console.log('Started panning');
        } else if (evt.button === 2) {
            // RIGHT MOUSE: Spin the world (orbit around target) - Shapr3D style
            this.cameraState.isOrbiting = true;
            console.log('Started spinning world');
        }

        evt.preventDefault();
    }

    onCameraPointerMove(evt) {
        if (this.isDragging) return; // Don't interfere with object dragging

        const deltaX = evt.offsetX - this.cameraState.lastPointerX;
        const deltaY = evt.offsetY - this.cameraState.lastPointerY;
        
        const sensitivity = this.preferences ? this.preferences.rotateSpeed : 0.003;

        if (this.cameraState.isOrbiting) {
            // RIGHT MOUSE: Spin the world - orbit camera around target (Shapr3D style)
            this.camera.alpha += deltaX * sensitivity;
            this.camera.beta += deltaY * sensitivity;
            
            // Enforce limits
            this.camera.beta = Math.max(this.camera.lowerBetaLimit, 
                                      Math.min(this.camera.upperBetaLimit, this.camera.beta));
            
        } else if (this.cameraState.isPanning) {
            // TRUE PAN: Move camera position only, keep looking in same direction
            const panSensitivity = this.preferences ? this.preferences.panSpeed : 0.3;
            const cameraRight = this.camera.getDirection(BABYLON.Vector3.Right());
            const cameraUp = this.camera.getDirection(BABYLON.Vector3.Up());
            
            const panVector = cameraRight.scale(-deltaX * panSensitivity)
                                       .add(cameraUp.scale(deltaY * panSensitivity));
            
            // Move camera position AND target by the same amount (true pan)
            const currentTarget = this.camera.getTarget();
            const currentPosition = this.camera.position.clone();
            
            this.camera.position = currentPosition.add(panVector);
            this.camera.setTarget(currentTarget.add(panVector));
        }

        this.cameraState.lastPointerX = evt.offsetX;
        this.cameraState.lastPointerY = evt.offsetY;
    }

    onCameraPointerUp(evt) {
        console.log('Pointer up - stopping camera movement');
        this.cameraState.isOrbiting = false;
        this.cameraState.isPanning = false;
        
        // Enforce camera height constraint after any movement
        this.enforceMinimumCameraHeight();
    }

    onCameraWheel(evt) {
        if (this.isDragging) return;

        // ZOOM: Move camera toward/away from target
        const zoomSensitivity = this.preferences ? this.preferences.zoomSpeed : 12;
        const delta = evt.deltaY > 0 ? zoomSensitivity : -zoomSensitivity;
        
        this.camera.radius += delta;
        this.camera.radius = Math.max(this.camera.lowerRadiusLimit, 
                                    Math.min(this.camera.upperRadiusLimit, this.camera.radius));
        
        evt.preventDefault();
    }

    enforceMinimumCameraHeight() {
        // Calculate camera world position
        const cameraPosition = this.camera.globalPosition;
        
        // If camera is below 4 units above the XY plane, adjust it
        if (cameraPosition.y < 4) {
            // Calculate the camera position relative to target
            const targetPosition = this.camera.getTarget();
            const direction = cameraPosition.subtract(targetPosition).normalize();
            const distance = this.camera.radius;
            
            // Adjust beta angle to keep camera at minimum height
            const minHeight = 4;
            const horizontalDistance = Math.sqrt(
                Math.pow(cameraPosition.x - targetPosition.x, 2) + 
                Math.pow(cameraPosition.z - targetPosition.z, 2)
            );
            
            if (horizontalDistance > 0) {
                const minBeta = Math.atan2(horizontalDistance, minHeight - targetPosition.y);
                if (this.camera.beta > minBeta) {
                    this.camera.beta = minBeta;
                }
            }
        }
    }
    
    setupCustomMouseControls() {
        // Disable built-in camera controls
        this.camera.detachControl(this.canvas);
        
        // Custom mouse state
        this.mouseState = {
            isDown: false,
            button: -1,
            lastX: 0,
            lastY: 0
        };
        
        // Add custom mouse event listeners
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.onMouseWheel(e));
        
        // Prevent context menu on right click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
    }
    
    setupThickLineMaterial() {
        // Create a material that can make lines appear thicker
        this.thickLineMaterial = new BABYLON.StandardMaterial('thickLineMaterial', this.scene);
        this.thickLineMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.5, 1); // Blue color
        this.thickLineMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.5, 1); // Make it glow slightly
        this.thickLineMaterial.disableLighting = true;
        this.thickLineMaterial.backFaceCulling = false;
        
        // Store reference for sketch tools
        this.sketchLineMaterial = this.thickLineMaterial;
    }
    
    createThickLineLoop(points, name, material) {
        // Create thick lines using ribbons for closed shapes
        const ribbons = [];
        
        for (let i = 0; i < points.length; i++) {
            const start = points[i];
            const end = points[(i + 1) % points.length];
            const distance = BABYLON.Vector3.Distance(start, end);
            
            if (distance > 0.01) {
                const direction = end.subtract(start).normalize();
                const perpendicular = BABYLON.Vector3.Cross(direction, this.sketchForward).normalize();
                const halfWidth = 0.04;
                
                // Extend lines by half the border width for proper mitered corners
                const extension = halfWidth; // Extension equals half the border width
                const extendedStart = start.subtract(direction.scale(extension));
                const extendedEnd = end.add(direction.scale(extension));
                
                const path1 = [
                    extendedStart.add(perpendicular.scale(halfWidth)),
                    extendedEnd.add(perpendicular.scale(halfWidth))
                ];
                const path2 = [
                    extendedStart.subtract(perpendicular.scale(halfWidth)),
                    extendedEnd.subtract(perpendicular.scale(halfWidth))
                ];
                
                const ribbon = BABYLON.MeshBuilder.CreateRibbon(name + '_segment_' + i, {
                    pathArray: [path1, path2],
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, this.scene);
                
                ribbon.material = material;
                ribbons.push(ribbon);
            }
        }
        
        // Merge all ribbons into one mesh
        if (ribbons.length > 0) {
            const mergedMesh = BABYLON.Mesh.MergeMeshes(ribbons, true);
            mergedMesh.name = name;
            return mergedMesh;
        }
        
        return null;
    }
    
    createFilledRectangle(points, name, borderMaterial) {
        
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledRectangle(points, name, borderMaterial);
        } else {
            // Fallback to corrected original method
            
            // Create the thick border
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create fill material
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Make it glow to ensure visibility
            fillMaterial.backFaceCulling = false;
            fillMaterial.disableLighting = true;
            fillMaterial.alpha = 0.5; // Semi-transparent fill
            
            // Calculate rectangle dimensions more carefully
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            const minZ = Math.min(...points.map(p => p.z));
            const maxZ = Math.max(...points.map(p => p.z));
            
            // Better width/height calculation - use the larger dimension spans
            const xSpan = maxX - minX;
            const ySpan = maxY - minY;
            const zSpan = maxZ - minZ;
            
            // Choose the two largest spans (ignore the dimension with minimal variation)
            let width, height;
            if (xSpan >= ySpan && xSpan >= zSpan) {
                width = xSpan;
                height = Math.max(ySpan, zSpan);
            } else if (ySpan >= xSpan && ySpan >= zSpan) {
                width = Math.max(xSpan, zSpan);
                height = ySpan;
            } else {
                width = Math.max(xSpan, ySpan);
                height = zSpan;
            }
            
            // Rectangle center
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            // Create plane fill that matches the rectangle dimensions
            const fillMesh = BABYLON.MeshBuilder.CreatePlane(name + '_fill', {
                width: Math.max(width, 0.1),
                height: Math.max(height, 0.1),
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Position the fill at the rectangle center
            fillMesh.position.x = centerX;
            fillMesh.position.y = centerY - 0.001; // Slightly behind to avoid z-fighting
            fillMesh.position.z = centerZ;
            fillMesh.material = fillMaterial;
            fillMesh.renderingGroupId = 0; // Behind border
            fillMesh.isPickable = true;
            
            
            // Create parent to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (borderMesh) borderMesh.parent = parentMesh;
            if (fillMesh) fillMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    createFilledCircle(center, radius, name, borderMaterial) {
        
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledCircle(center, radius, name, borderMaterial);
        } else {
            // Fallback to original method
            
            // Create the thick border
            const points = this.getCirclePoints(center, radius);
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create fill material
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.7, 1.0);
            fillMaterial.backFaceCulling = false;
            fillMaterial.disableLighting = true;
            fillMaterial.alpha = 0.5; // Semi-transparent fill
            
            // Create disc fill
            const fillMesh = BABYLON.MeshBuilder.CreateDisc(name + '_fill', {
                radius: radius,
                tessellation: 32,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Position the fill at the circle center
            fillMesh.position = center.clone();
            fillMesh.position.y -= 0.001; // Slightly behind to avoid z-fighting
            fillMesh.material = fillMaterial;
            fillMesh.renderingGroupId = 0; // Behind border
            fillMesh.isPickable = true;
            
            // Create parent to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (borderMesh) borderMesh.parent = parentMesh;
            if (fillMesh) fillMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    createFilledEllipse(center, radiusX, radiusY, name, borderMaterial) {
        
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledEllipse(center, radiusX, radiusY, name, borderMaterial);
        } else {
            // Fallback to original method
            
            // Create the thick border
            const points = this.getEllipsePoints(center, radiusX, radiusY);
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create fill material
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.7, 1.0);
            fillMaterial.backFaceCulling = false;
            fillMaterial.disableLighting = true;
            fillMaterial.alpha = 0.5; // Semi-transparent fill
            
            // Create disc fill and scale it to create an ellipse
            const fillMesh = BABYLON.MeshBuilder.CreateDisc(name + '_fill', {
                radius: Math.max(radiusX, radiusY),
                tessellation: 32,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Scale the disc to create an ellipse
            const scaleX = radiusX / Math.max(radiusX, radiusY);
            const scaleY = radiusY / Math.max(radiusX, radiusY);
            fillMesh.scaling = new BABYLON.Vector3(scaleX, scaleY, 1);
            
            // Position the fill at the ellipse center
            fillMesh.position = center.clone();
            fillMesh.position.y -= 0.001; // Slightly behind to avoid z-fighting
            fillMesh.material = fillMaterial;
            fillMesh.renderingGroupId = 0; // Behind border
            fillMesh.isPickable = true;
            
            // Create parent to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (borderMesh) borderMesh.parent = parentMesh;
            if (fillMesh) fillMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    createFilledShape(points, name, borderMaterial) {
        // Use the new Shape2D system for proper coordinate handling
        if (this.shape2D) {
            return this.shape2D.createFilledPolygon(points, name, borderMaterial);
        } else {
            // Fallback to original method
            
            // Create ultra-thin extruded shape for filled appearance
            const fillMaterial = new BABYLON.StandardMaterial(name + '_fillMaterial', this.scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 1.0); // Light blue fill
            fillMaterial.backFaceCulling = false; // Show both sides
            fillMaterial.disableLighting = true; // Don't use lighting
            
            // Create 2D shape path for extrusion - fixed to handle any coordinate system
            const shape2D = points.map(p => new BABYLON.Vector2(p.x, p.z));
            
            let fillMesh;
            try {
                // Create ultra-thin extruded mesh (0.001 units thick)
                fillMesh = BABYLON.MeshBuilder.ExtrudePolygon(name + '_fill', {
                    shape: shape2D,
                    depth: 0.001,
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, this.scene);
                
                // Position at the sketch plane
                fillMesh.position.y = points[0].y;
                fillMesh.material = fillMaterial;
                fillMesh.renderingGroupId = 0; // Render behind the border
                fillMesh.isPickable = true;
                
            } catch (error) {
                fillMesh = null;
            }
            
            // Create thick border using ribbons
            const borderMesh = this.createThickLineLoop(points, name + '_border', borderMaterial);
            
            // Create parent mesh to hold both
            const parentMesh = new BABYLON.Mesh(name, this.scene);
            if (fillMesh) fillMesh.parent = parentMesh;
            if (borderMesh) borderMesh.parent = parentMesh;
            
            return parentMesh;
        }
    }
    
    onMouseDown(event) {
        this.mouseState.isDown = true;
        this.mouseState.button = event.button;
        this.mouseState.lastX = event.clientX;
        this.mouseState.lastY = event.clientY;
        
        // Only handle middle (1) and right (2) buttons
        if (event.button === 1 || event.button === 2) {
            event.preventDefault();
        }
    }
    
    onMouseMove(event) {
        if (!this.mouseState.isDown) return;
        
        const deltaX = event.clientX - this.mouseState.lastX;
        const deltaY = event.clientY - this.mouseState.lastY;
        
        if (this.mouseState.button === 2) {
            // Right mouse = rotate
            this.camera.alpha += deltaX * 0.01;
            this.camera.beta += deltaY * 0.01;
            
            // Clamp beta
            this.camera.beta = Math.max(0.1, Math.min(Math.PI - 0.1, this.camera.beta));
            
        } else if (this.mouseState.button === 1) {
            // Middle mouse = pan
            const sensitivity = 0.001 * this.camera.radius;
            
            const forward = this.camera.getTarget().subtract(this.camera.position).normalize();
            const right = BABYLON.Vector3.Cross(forward, this.camera.upVector).normalize();
            const up = BABYLON.Vector3.Cross(right, forward).normalize();
            
            const panVector = right.scale(-deltaX * sensitivity).add(up.scale(deltaY * sensitivity));
            
            this.camera.target = this.camera.target.add(panVector);
            this.camera.setTarget(this.camera.target);
        }
        
        this.mouseState.lastX = event.clientX;
        this.mouseState.lastY = event.clientY;
    }
    
    onMouseUp(event) {
        this.mouseState.isDown = false;
        this.mouseState.button = -1;
    }
    
    onMouseWheel(event) {
        event.preventDefault();
        
        const delta = event.deltaY;
        const zoomSensitivity = 0.15;  // Increased for more sensitive zooming
        
        this.camera.radius += delta * zoomSensitivity;
        this.camera.radius = Math.max(2, Math.min(1000, this.camera.radius));
    }

    setupLighting() {
        // Hemispheric light for general illumination
        const hemiLight = new BABYLON.HemisphericLight(
            'hemiLight',
            new BABYLON.Vector3(0, 1, 0),
            this.scene
        );
        hemiLight.intensity = 0.7;
        
        // Directional light for shadows and definition
        const dirLight = new BABYLON.DirectionalLight(
            'dirLight',
            new BABYLON.Vector3(-1, -1, -1),
            this.scene
        );
        dirLight.intensity = 0.5;
        dirLight.position = new BABYLON.Vector3(10, 10, 10);
    }

    setupGrid() {
        // Create modular grid system
        this.gridSystem = new GridSystem(this.scene, this.camera);
        
        // Create legacy grid object for compatibility
        this.grid = { 
            isVisible: true,
            setVisible: (visible) => this.gridSystem.setVisible(visible)
        };
        
        // Initialize shape2D system
        this.shape2D = new Shape2D(this.scene, null); // Will be updated by sketch mode
        
        // Create coordinate axes
        this.createAxes();
        
        // Sketch ground will be created when entering sketch mode
    }

    toggleGrid() {
        if (this.gridSystem) {
            this.gridSystem.isVisible = !this.gridSystem.isVisible;
            this.gridSystem.setVisible(this.gridSystem.isVisible);
            console.log("Grid toggled:", this.gridSystem.isVisible ? "ON" : "OFF");
        } else {
            console.error("GridSystem not initialized");
        }
    }

    
    
    
    
    // Grid clipping function - REMOVED
    // New approach: generate grid lines that are guaranteed to be in front of camera
    // instead of clipping lines that extend behind the camera
    
    initializeGridLOD() {
        // Metric measurement scale (in cm - 1 unit = 1 cm)
        this.gridScales = [
            { minor: 0.1, major: 1, label: "1mm" },        // Finest detail - 1mm minor, 1cm major
            { minor: 0.2, major: 2, label: "2mm" },        
            { minor: 0.5, major: 5, label: "5mm" },        
            { minor: 1, major: 10, label: "1cm" },         // 1cm minor, 10cm major
            { minor: 2, major: 20, label: "2cm" },         
            { minor: 5, major: 50, label: "5cm" },         
            { minor: 10, major: 100, label: "10cm" },      // 10cm minor, 1m major
            { minor: 20, major: 200, label: "20cm" },      
            { minor: 50, major: 500, label: "50cm" },      
            { minor: 100, major: 1000, label: "1m" },      // 1m minor, 10m major
            { minor: 200, major: 2000, label: "2m" },      
            { minor: 500, major: 5000, label: "5m" },      
            { minor: 1000, major: 10000, label: "10m" }    // Large scale
        ];
        
        this.currentGridScale = 0;
        this.currentGridInfo = this.gridScales[0];
    }
    
    updateGridLOD() {
        const cameraDistance = this.camera.radius;
        
        // Calculate appropriate grid scale based on camera distance
        // The goal is to keep minor grid lines at a reasonable screen density
        let targetScale = 0;
        
        // Scale selection based on camera distance (cm units)
        if (cameraDistance < 5) targetScale = 0;        // 1mm
        else if (cameraDistance < 10) targetScale = 1;   // 2mm
        else if (cameraDistance < 20) targetScale = 2;   // 5mm
        else if (cameraDistance < 50) targetScale = 3;   // 1cm
        else if (cameraDistance < 100) targetScale = 4;  // 2cm
        else if (cameraDistance < 200) targetScale = 5;  // 5cm
        else if (cameraDistance < 500) targetScale = 6;  // 10cm
        else if (cameraDistance < 1000) targetScale = 7; // 20cm
        else if (cameraDistance < 2000) targetScale = 8; // 50cm
        else if (cameraDistance < 5000) targetScale = 9; // 1m
        else if (cameraDistance < 10000) targetScale = 10; // 2m
        else if (cameraDistance < 20000) targetScale = 11; // 5m
        else targetScale = 12; // 10m
        
        // Only update if scale changed
        if (targetScale !== this.currentGridScale) {
            this.currentGridScale = targetScale;
            this.currentGridInfo = this.gridScales[targetScale];
            
            // Update properties panel
            this.updateGridProperties();
            

        }
    }
    
    updateGridProperties() {
        const gridInfoElement = document.getElementById('grid-info');
        if (gridInfoElement) {
            gridInfoElement.textContent = `Grid: ${this.currentGridInfo.label}`;
        }
    }
    

    createAxes() {
        // X axis (red)
        const xAxis = BABYLON.MeshBuilder.CreateLines('xAxis', {
            points: [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(5, 0, 0)
            ]
        }, this.scene);
        xAxis.color = new BABYLON.Color3(0.8, 0, 0);
        xAxis.isPickable = false;
        
        // Y axis (green)
        const yAxis = BABYLON.MeshBuilder.CreateLines('yAxis', {
            points: [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 5, 0)
            ]
        }, this.scene);
        yAxis.color = new BABYLON.Color3(0, 0.7, 0);
        yAxis.isPickable = false;
        
        // Z axis (blue)
        const zAxis = BABYLON.MeshBuilder.CreateLines('zAxis', {
            points: [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 0, 5)
            ]
        }, this.scene);
        zAxis.color = new BABYLON.Color3(0, 0, 0.8);
        zAxis.isPickable = false;
    }

    setupSketchPlanes() {
        // Create three orthographic sketch plane indicators
        this.createSketchPlaneIndicators();
    }

    createSketchPlaneIndicators() {
        const planeSize = 0.5;
        const planeDistance = 3;
        
        // XY plane (front view)
        const xyPlane = BABYLON.MeshBuilder.CreatePlane('xyPlane', {
            size: planeSize
        }, this.scene);
        xyPlane.position = new BABYLON.Vector3(0, 0, planeDistance);
        xyPlane.billboardMode = BABYLON.AbstractMesh.BILLBOARD_NONE;
        
        // XZ plane (top view)
        const xzPlane = BABYLON.MeshBuilder.CreatePlane('xzPlane', {
            size: planeSize
        }, this.scene);
        xzPlane.position = new BABYLON.Vector3(0, planeDistance, 0);
        xzPlane.rotation.x = Math.PI / 2;
        
        // YZ plane (side view)
        const yzPlane = BABYLON.MeshBuilder.CreatePlane('yzPlane', {
            size: planeSize
        }, this.scene);
        yzPlane.position = new BABYLON.Vector3(planeDistance, 0, 0);
        yzPlane.rotation.y = Math.PI / 2;
        
        // Create materials for sketch planes
        const planeMaterial = new BABYLON.StandardMaterial('planeMaterial', this.scene);
        planeMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
        planeMaterial.alpha = 0.7;
        planeMaterial.backFaceCulling = false;
        planeMaterial.doubleSided = true;
        
        xyPlane.material = planeMaterial;
        xzPlane.material = planeMaterial;
        yzPlane.material = planeMaterial;
        
        // Store planes for interaction
        this.sketchPlanes = [xyPlane, xzPlane, yzPlane];
        
        // Add click handlers with proper surface detection
        this.scene.onPointerObservable.add((pointerInfo) => {
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK && pointerInfo.pickInfo.hit) {
                const pickedMesh = pointerInfo.pickInfo.pickedMesh;
                
                // Check if it's one of our sketch plane indicators
                if (this.sketchPlanes.includes(pickedMesh)) {
                    const pickInfo = pointerInfo.pickInfo;
                    this.selectSketchPlane(pickedMesh, pickInfo);
                }
            }
        });
    }

    selectSketchPlane(mesh, pickInfo) {


        
        // Prevent entering sketch mode if already in sketch mode
        if (this.isSketchMode) {

            return;
        }
        
        // Get the surface normal at the picked point
        const surfaceNormal = pickInfo.getNormal(true, true);
        const pickPoint = pickInfo.pickedPoint;
        

        
        // Update selection info
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            selectionInfo.textContent = `${mesh.name} selected`;
        }
        
        // Enter sketch mode with surface data - DISABLED
        // Only enter sketch mode via the sketch tool now
        // this.enterSketchMode(mesh, pickPoint, surfaceNormal);

    }

    enterSketchMode(mesh, pickPoint, surfaceNormal) {

        
        this.currentSketchSurface = {
            mesh: mesh,
            point: pickPoint,
            normal: surfaceNormal.normalize()
        };
        this.isSketchMode = true;
        
        // Grid updates are managed by GridSystem internally
        
        // Update UI
        this.setMode('sketch');
        
        // STEP 1: Create coordinate system for the surface
        this.createSketchCoordinateSystem(surfaceNormal);
        
        // STEP 2: Animate camera to surface position
        this.animateCameraToSurface(pickPoint, surfaceNormal, () => {
            // STEP 3: After camera animation completes, create grid and enable tools
            this.createSketchEnvironment();
        });
        

    }

    createSketchCoordinateSystem(surfaceNormal) {

        
        // Create a robust coordinate system for any surface orientation
        const normal = surfaceNormal.normalize();

        
        // Choose the most stable reference vector based on the normal
        let up = new BABYLON.Vector3(0, 1, 0); // World up
        
        // If surface normal is nearly vertical, use a different reference
        const dotProduct = Math.abs(BABYLON.Vector3.Dot(normal, up));

        
        if (dotProduct > 0.9) {
            up = new BABYLON.Vector3(1, 0, 0); // World X if normal is too close to Y

        }
        
        // Create orthonormal basis using Gram-Schmidt process
        this.sketchForward = normal.clone(); // Surface normal points "out" from surface
        this.sketchRight = BABYLON.Vector3.Cross(up, this.sketchForward);
        

        
        if (this.sketchRight.length() < 0.001) {

            // Use a perpendicular vector
            if (Math.abs(normal.x) < 0.9) {
                this.sketchRight = BABYLON.Vector3.Cross(new BABYLON.Vector3(1, 0, 0), this.sketchForward);
            } else {
                this.sketchRight = BABYLON.Vector3.Cross(new BABYLON.Vector3(0, 0, 1), this.sketchForward);
            }
        }
        
        this.sketchRight = this.sketchRight.normalize();
        this.sketchUp = BABYLON.Vector3.Cross(this.sketchForward, this.sketchRight).normalize();
        
        // Verify we have a valid orthonormal basis
        if (this.sketchRight.length() < 0.1 || this.sketchUp.length() < 0.1) {

            // Fallback to a simple XY plane
            this.sketchRight = new BABYLON.Vector3(1, 0, 0);
            this.sketchUp = new BABYLON.Vector3(0, 1, 0);
            this.sketchForward = new BABYLON.Vector3(0, 0, 1);
        }
        
        // Store surface origin (the picked point)
        this.sketchOrigin = this.currentSketchSurface.point.clone();
        
        // Update Shape2D coordinate system
        if (this.shape2D) {
            
            this.shape2D.sketchSystem = {
                sketchForward: this.sketchForward,
                sketchRight: this.sketchRight,
                sketchUp: this.sketchUp,
                sketchOrigin: this.sketchOrigin
            };
        }

    }
    
    animateCameraToSurface(pickPoint, surfaceNormal, onComplete) {
        const normal = surfaceNormal.normalize();
        
        // Calculate the vector from pick point to current camera position
        const pickPointToCamera = this.camera.position.subtract(pickPoint);
        const normalDot = BABYLON.Vector3.Dot(pickPointToCamera, normal);
        
        // If dot product is positive, camera is on the side the normal points to
        // If negative, camera is on the opposite side - we want to keep it there
        const correctNormal = normalDot > 0 ? normal : normal.scale(-1);
        
        // Maintain the same distance from target as when picking
        const currentDistance = BABYLON.Vector3.Distance(this.camera.position, pickPoint);
        const targetPosition = pickPoint.add(correctNormal.scale(currentDistance));
        
        // Target should be the face center passed in (not the original picked point)
        const targetTarget = pickPoint.clone();
        const targetUp = this.sketchUp.clone();
        
        // Store current camera state
        const startPosition = this.camera.position.clone();
        const startTarget = this.camera.getTarget().clone();
        const startUp = this.camera.upVector.clone();
        
        // Animation timing - smooth and elegant but not too dramatic
        const animationDuration = 1800; // 1.8 seconds total
        const startTime = Date.now();
        
        // Start 3D grid fade out immediately
        this.beginGridFadeTransition();
        
        // Single-phase smooth animation - orientation and subtle position change together
        const animateCamera = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            const easedProgress = this.easeInOutCubic(progress);
            
            // Smooth orientation alignment
            this.camera.setTarget(BABYLON.Vector3.Lerp(startTarget, targetTarget, easedProgress));
            this.camera.upVector = BABYLON.Vector3.Lerp(startUp, targetUp, easedProgress);
            
            // Subtle position adjustment - only 10% closer
            this.camera.position = BABYLON.Vector3.Lerp(startPosition, targetPosition, easedProgress);
            
            if (progress < 1) {
                // Continue animation
                requestAnimationFrame(animateCamera);
            } else {
                // Animation complete - finalize camera setup
                this.finalizeCameraSetup(pickPoint, surfaceNormal);
                onComplete();
            }
        };
        
        // Start animation
        requestAnimationFrame(animateCamera);
    }
    
    // Beautiful easing function for smooth animations
    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    // Begin the gentle fade transition between 3D grid and sketch grid
    beginGridFadeTransition() {
        // Fade out 3D grid slowly and beautifully
        if (this.grid && this.grid.gridLines) {
            const fadeOutDuration = 2000; // 2 seconds for beautiful fade out
            const startTime = Date.now();
            const initialAlpha = this.grid.gridLines[0]?.material?.alpha || 1;
            
            const fadeOut3DGrid = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / fadeOutDuration, 1);
                const easedProgress = this.easeInOutCubic(progress);
                
                // Fade out 3D grid
                const newAlpha = initialAlpha * (1 - easedProgress);
                this.grid.gridLines.forEach(line => {
                    if (line.material) {
                        line.material.alpha = newAlpha;
                    }
                });
                
                if (progress < 1) {
                    requestAnimationFrame(fadeOut3DGrid);
                }
            };
            
            requestAnimationFrame(fadeOut3DGrid);
        }
    }
    
    finalizeCameraSetup(pickPoint, surfaceNormal) {

        
        // Switch to orthographic projection
        this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        
        // Set orthographic bounds based on camera distance to maintain same scale
        const cameraDistance = BABYLON.Vector3.Distance(this.camera.position, pickPoint);
        const viewSize = cameraDistance * 0.4; // Scale factor to match perspective view
        const aspectRatio = this.engine.getAspectRatio(this.camera);
        this.camera.orthoLeft = -viewSize * aspectRatio;
        this.camera.orthoRight = viewSize * aspectRatio;
        this.camera.orthoBottom = -viewSize;
        this.camera.orthoTop = viewSize;
        
        // Disable camera animations and inertia for precise control
        this.camera.inertia = 0;
        this.camera.panningInertia = 0;
        
        
        // Setup sketch-specific camera controls
        this.setupSketchCameraControls();
    }

    createSketchEnvironment() {

        
        // Initialize sketching system - preserve existing elements if any
        this.currentSketch = {
            surface: this.currentSketchSurface,
            elements: this.closedShapes || [], // Preserve existing shapes
            isDrawing: false,
            currentTool: 'line',
            // Reset tool-specific state
            startPoint: null,
            trianglePoints: []
        };
        
        // Create sketch plane grid with fade-in effect
        this.createSketchPlaneGrid();
        
        // Add sketch drawing toolbar
        this.showSketchToolbar();
        
        // Set up mouse handlers for sketching
        this.setupSketchingMouseHandlers();
        

    }

    showSketchToolbar() {
        // Add sketch tools to the toolbar
        const toolbar = document.querySelector('.toolbar');
        
        // Clear existing tools
        toolbar.innerHTML = '';
        
        // Add sketch tools
        const tools = [
            { name: 'line', label: 'Line', icon: 'ðŸ“' },
            { name: 'rectangle', label: 'Rectangle', icon: 'â–­' },
            { name: 'circle', label: 'Circle', icon: 'â—‹' },
            { name: 'ellipse', label: 'Ellipse', icon: 'â¬­' },
            { name: 'triangle', label: 'Triangle', icon: 'â–³' },
            { name: 'exit', label: 'Exit Sketch', icon: 'âœ“' }
        ];
        
        tools.forEach(tool => {
            const btn = document.createElement('button');
            btn.className = 'tool-btn';
            btn.id = `${tool.name}-tool`;
            btn.innerHTML = `${tool.icon} ${tool.label}`;
            
            if (tool.name === 'line') {
                btn.classList.add('active');
            }
            
            btn.addEventListener('click', () => {
                if (tool.name === 'exit') {
                    this.exitSketchMode();
                } else {
                    this.selectSketchTool(tool.name);
                }
            });
            
            toolbar.appendChild(btn);
        });
    }

    selectSketchTool(toolName) {
        console.log('selectSketchTool called with toolName:', toolName);
        
        if (toolName === 'sketch') {
            // Sketch tool selected - enter surface selection mode
            this.sketchToolSelected = true;
            this.waitingForSurface = true;
            
            // Show the 3 default sketch planes
            this.showSketchTargets();
            
            // Update mode indicator
            const modeIndicator = document.getElementById('mode-indicator');
            if (modeIndicator) {
                modeIndicator.textContent = 'Select a surface for sketching';
            }
            
            // Update properties panel
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Click on a flat surface to create a sketch';
            }
            
            
        } else if (toolName === 'exit-sketch') {
            // Exit sketch mode
            this.exitSketchMode();
            
        } else if (toolName === 'extrude') {
            // Activate extrude tool
            console.log('EXTRUDE TOOL ACTIVATED! selectedFace:', this.selectedFace?.name);
            this.activeTool = 'extrude';
            
            // Update button visual state
            this.updateToolButtonStates();
            
            if (this.selectedFace) {
                console.log('Starting extrusion for face:', this.selectedFace.name);
                this.startBidirectionalExtrusion();
            } else {
                console.log('Extrude tool active - waiting for face selection');
                // Show instruction in UI
                const selectionInfo = document.getElementById('selection-info');
                if (selectionInfo) {
                    selectionInfo.textContent = 'Extrude tool active - Click on a 2D face to extrude';
                }
            }
            
        } else if (toolName === 'rip-cut') {
            // Activate rip cut tool (cut along grain/length)
            console.log('RIP CUT TOOL ACTIVATED!');
            this.activeTool = 'rip-cut';
            
            // Clear drag handles and manipulation buttons since cut tools don't use them
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate cut tool system
            this.cutToolSystem.activate('rip');
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Rip Cut active - Hover over lumber to preview cut line, click to cut';
            }
            
        } else if (toolName === 'cross-cut') {
            // Activate cross cut tool (cut across grain/width)
            console.log('CROSS CUT TOOL ACTIVATED!');
            this.activeTool = 'cross-cut';
            
            // Clear drag handles and manipulation buttons since cut tools don't use them
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate cut tool system
            this.cutToolSystem.activate('cross');
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Cross Cut active - Hover over lumber to preview cut line, click to cut';
            }
            
        } else if (toolName === 'pointer') {
            // Activate pointer tool (default selection)
            console.log('POINTER TOOL ACTIVATED!');
            this.activeTool = 'pointer';
            
            // Deactivate cut tool if it's active
            if (this.cutToolSystem) {
                this.cutToolSystem.deactivate();
            }
            
            // CRITICAL: Deactivate router tool if it's active 
            if (this.routerBitSystem) {
                this.routerBitSystem.deactivate();
            }
            
            // Clear drag handles and manipulation buttons since pointer tool doesn't use them
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Pointer active - Click to select parts';
            }
            
        } else if (toolName === 'move') {
            // Activate move tool (shows manipulation buttons immediately)
            console.log('MOVE TOOL ACTIVATED!');
            this.activeTool = 'move';
            
            // Deactivate cut tool if it's active
            if (this.cutToolSystem) {
                this.cutToolSystem.deactivate();
            }
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Show manipulation buttons immediately (even without selection)
            this.showManipulationInPropertiesPanel(null);
            
            // Show gizmos if part is selected
            if (this.selectedPart) {
                const selectedMesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                this.createDragHandles(selectedMesh);
                // Update panel with selected part info
                this.showManipulationInPropertiesPanel(selectedMesh);
            }
            
        } else if (toolName === 'router') {
            // Activate router tool for edge shaping
            console.log('ROUTER TOOL ACTIVATED!');
            console.log('DEBUG: selectedPart before router activation:', this.selectedPart);
            this.activeTool = 'router';
            
            // Clear drag handles and manipulation buttons but preserve part selection
            this.clearDragHandles();
            this.clearManipulationButtons();
            console.log('DEBUG: selectedPart after clearing handles:', this.selectedPart);
            
            // Update button visual state
            this.updateToolButtonStates();
            console.log('DEBUG: selectedPart after updateToolButtonStates:', this.selectedPart);
            
            // Activate router bit system with default roundover profile
            this.routerBitSystem.activate('roundover');
            
            // If a part is already selected, focus edge detection on that part
            if (this.selectedPart) {
                const selectedMesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (selectedMesh) {
                    this.routerBitSystem.setFocusPart(selectedMesh);
                    console.log('RouterBitSystem: Focused on selected part for edge detection');
                }
            }
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                if (this.selectedPart) {
                    selectionInfo.textContent = 'Router tool active - Click edges of selected board to select them, then press R';
                } else {
                    selectionInfo.textContent = 'Router tool active - Select a board first, then click its edges';
                }
            }
            
        } else if (toolName === 'scroll-cut') {
            // Activate scroll cutting tool for freehand cutting
            console.log('ðŸŽ¨ SCROLL CUTTING TOOL ACTIVATED!');
            this.activeTool = 'scroll-cut';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Check if a part is selected
            if (this.selectedPart) {
                const selectedMesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (selectedMesh && selectedMesh.isWorkBenchPart) {
                    // Activate scroll cutting on the selected part
                    const success = this.scrollCuttingSystem.activate(selectedMesh);
                    if (success) {
                        console.log('ðŸŽ¨ Scroll cutting activated on:', selectedMesh.partData?.materialName);
                    } else {
                        console.warn('ðŸŽ¨ Failed to activate scroll cutting');
                    }
                } else {
                    console.warn('ðŸŽ¨ Selected part is not suitable for scroll cutting');
                }
            } else {
                // No part selected - try to find any workbench part
                console.log('ðŸŽ¨ No part selected, looking for workbench parts...');
                const workBenchParts = this.workBenchParts.filter(part => part.isWorkBenchPart);
                
                if (workBenchParts.length > 0) {
                    // Use the first workbench part
                    const firstPart = workBenchParts[0];
                    const success = this.scrollCuttingSystem.activate(firstPart);
                    if (success) {
                        console.log('ðŸŽ¨ Scroll cutting activated on first workbench part:', firstPart.partData?.materialName);
                    } else {
                        console.warn('ðŸŽ¨ Failed to activate scroll cutting on first workbench part');
                    }
                } else {
                    console.warn('ðŸŽ¨ No workbench parts available for scroll cutting');
                    
                    // Show message to select a part first
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        selectionInfo.innerHTML = '<strong style="color: red;">âš ï¸ No Parts Available</strong><br><span style="font-size: 0.9em;">Please add a part to the workbench first to use scroll cutting.</span>';
                    }
                }
            }
            
        } else if (toolName === 'plane') {
            // Activate planing tool for thickness reduction
            console.log('ðŸªš PLANE TOOL ACTIVATED!');
            this.activeTool = 'plane';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate plane tool system
            this.planeToolSystem.activate();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Plane tool active - Hover over lumber to preview thickness removal, click to plane';
            }
            
        } else if (toolName === 'join') {
            // Activate join tool for precision part alignment
            console.log('ðŸ§© JOIN TOOL ACTIVATED!');
            this.activeTool = 'join';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate join tool system
            this.joinToolSystem.activate();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Join tool active - Click first piece to join';
            }
            
        } else if (toolName === 'drill') {
            // Activate drill press tool for precision hole drilling
            console.log('ðŸ”© DRILL PRESS ACTIVATED!');
            this.activeTool = 'drill';
            
            // Clear other tool states
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Update button visual state
            this.updateToolButtonStates();
            
            // Activate drill press system
            this.drillPressSystem.activate();
            
            // Show instruction in UI
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Drill press active - Click on surface to position orthographic view, then place hole markers';
            }
            
        } else {
            // Deactivate scroll cutting system when switching away from scroll-cut tool
            if (this.scrollCuttingSystem && this.activeTool === 'scroll-cut') {
                this.scrollCuttingSystem.deactivate();
            }
            
            // Deactivate plane tool system when switching away from plane tool
            if (this.planeToolSystem && this.activeTool === 'plane') {
                this.planeToolSystem.deactivate();
            }
            
            // Deactivate saw tool system when switching away from saw tool
            if (this.sawToolSystem && this.activeTool === 'saw') {
                this.sawToolSystem.deactivate();
            }
            
            // Deactivate join tool system when switching away from join tool
            if (this.joinToolSystem && this.activeTool === 'join') {
                this.joinToolSystem.deactivate();
            }
            
            // Deactivate drill press system when switching away from drill tool
            if (this.drillPressSystem && this.activeTool === 'drill') {
                this.drillPressSystem.deactivate();
            }
            
            // Other tools selected - clear active tool and sketch tool
            this.activeTool = null;
            this.sketchToolSelected = false;
            this.waitingForSurface = false;
            
            // Clear drag handles and manipulation buttons since we're switching away from Move tool
            this.clearDragHandles();
            this.clearManipulationButtons();
            
            // Deactivate cut tool system
            if (this.cutToolSystem) {
                this.cutToolSystem.deactivate();
            }
            
            // Deactivate router bit system
            if (this.routerBitSystem) {
                this.routerBitSystem.deactivate();
            }
            
            // Hide the default sketch planes
            this.hideSketchTargets();
            
            // Reset mode indicator
            const modeIndicator = document.getElementById('mode-indicator');
            if (modeIndicator) {
                modeIndicator.textContent = '3D Modeling';
            }
            
            // Reset properties panel
            const selectionInfo = document.getElementById('selection-info');
            if (selectionInfo) {
                selectionInfo.textContent = 'Nothing selected';
            }
            
            // Handle regular sketch drawing tools if in sketch mode
            if (this.currentMode === 'sketch' && this.currentSketch) {
                this.currentSketch.currentTool = toolName;
            }
        }
    }
    
    updateToolButtonStates() {
        // Clear all active states
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set active state for current tool
        if (this.activeTool) {
            const activeButton = document.querySelector(`[data-tool="${this.activeTool}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
                console.log('Set active state for tool:', this.activeTool);
            }
        }
    }

    enterSketchModeOnSurface(mesh, pickPoint, normal) {
        
        // Clear sketch tool selection state
        this.sketchToolSelected = false;
        this.waitingForSurface = false;
        
        // Hide the sketch targets
        this.hideSketchTargets();
        
        // Deselect the sketch tool button
        document.querySelectorAll('[data-tool="sketch"]').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // For the cube, just use the position + half size in the normal direction
        const cubePosition = mesh.position;
        const cubeSize = 4; // 8cm cube = 4cm from center to face
        
        const faceCenter = cubePosition.add(normal.scale(cubeSize));
        
        this.setMode('sketch');
        this.enterSketchMode(mesh, faceCenter, normal);
    }

    createDefaultSketchTarget() {
        // UNITS: 1 unit = 1 cm
        const cubeSize = 8; // 8cm cube for easy selection
        
        // Force dispose any existing cube first
        const existingCube = this.scene.getMeshByName('sketchTarget');
        if (existingCube) {
            existingCube.dispose();
        }
        
        // Create completely solid target material with new name
        const targetMaterial = new BABYLON.StandardMaterial('solidCubeMaterial_' + Date.now(), this.scene);
        targetMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8); // Solid dark blue
        targetMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        targetMaterial.backFaceCulling = false;
        targetMaterial.disableLighting = false;
        
        // Create the cube - this is just the default target, any geometry can be used
        const sketchTarget = BABYLON.MeshBuilder.CreateBox('sketchTarget', {
            size: cubeSize
        }, this.scene);
        
        sketchTarget.position = new BABYLON.Vector3(0, cubeSize/2 + 2, 0); // Above grid with 2cm clearance
        sketchTarget.material = targetMaterial;
        sketchTarget.isPickable = true;
        sketchTarget.setEnabled(false); // Hidden by default
        
        // Add metadata to identify this as a sketch target (generic approach)
        sketchTarget.metadata = {
            isSketchTarget: true,
            targetType: 'default'
        };
        
        // Store reference
        this.defaultSketchTarget = sketchTarget;
        
    }

    showSketchTargets() {
        // Show default sketch target if no other geometry exists
        if (!this.defaultSketchTarget) {
            this.createDefaultSketchTarget();
        }
        
        // Enable and animate the target to fade in
        this.defaultSketchTarget.setEnabled(true);
        
        // Start with alpha 0 and animate to solid
        const material = this.defaultSketchTarget.material;
        const targetAlpha = 1.0; // Solid opacity
        material.alpha = 0;
        
        // Animate fade in
        BABYLON.Animation.CreateAndStartAnimation(
            'fadeInSketchTarget',
            material,
            'alpha',
            60, // 60 fps
            30, // 0.5 seconds
            0,  // start alpha
            targetAlpha, // end alpha
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            null,
            null
        );
        
    }

    hideSketchTargets() {
        // Hide default sketch target
        if (this.defaultSketchTarget && this.defaultSketchTarget.isEnabled()) {
            const material = this.defaultSketchTarget.material;
            
            // Animate fade out
            BABYLON.Animation.CreateAndStartAnimation(
                'fadeOutSketchTarget',
                material,
                'alpha',
                60, // 60 fps
                15, // 0.25 seconds (faster fade out)
                material.alpha, // current alpha
                0,  // end alpha
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                null,
                () => {
                    // Disable the target after animation
                    this.defaultSketchTarget.setEnabled(false);
                }
            );
        }
        
        // Future: Could also handle hiding other sketch targets from existing geometry
    }
    
    // Generic method to determine if any mesh can be used for sketching
    isMeshSketchable(mesh) {
        // Basic requirements for any sketchable surface
        if (!mesh || !mesh.isPickable || !mesh.isEnabled()) {
            return false;
        }
        
        // Exclude system meshes (grid, axes, etc.)
        const systemMeshNames = ['sketchGround', 'gridGround', 'gridGroundBelow', 'xAxis', 'yAxis', 'zAxis'];
        if (systemMeshNames.includes(mesh.name)) {
            return false;
        }
        
        // Exclude sketch preview meshes
        if (mesh.name.includes('Preview') || mesh.name.includes('preview')) {
            return false;
        }
        
        // Any other mesh with proper geometry is sketchable
        // This includes: default sketch targets, user-created geometry, imported models, etc.
        return true;
    }

    setupSketchingMouseHandlers() {

        
        // Track mouse down/up for drag detection
        this.mouseDownTime = 0;
        this.mouseDownPos = null;
        this.isDragging = false;
        
        // Unified mouse down handler for both drawing and camera
        this.sketchMouseDownHandler = (e) => {

            if (!this.isSketchMode) return;
            
            // Prevent Babylon.js from handling this event
            e.preventDefault();
            e.stopPropagation();
            
            if (e.button === 0) {
                // Left click - drawing
                this.mouseDownTime = Date.now();
                this.mouseDownPos = { x: e.clientX, y: e.clientY };
                this.isDragging = false;

            } else if (e.button === 1 || e.button === 2) {
                // Middle or right click - camera panning
                this.sketchCameraState.isPanning = true;
                this.sketchCameraState.lastX = e.clientX;
                this.sketchCameraState.lastY = e.clientY;
                e.preventDefault();

            }
        };
        
        // Unified mouse up handler for both drawing and camera
        this.sketchMouseUpHandler = (e) => {

            if (!this.isSketchMode) return;
            
            // Prevent Babylon.js from handling this event
            e.preventDefault();
            e.stopPropagation();
            
            if (e.button === 0) {
                // Left click - drawing
                const timeDiff = Date.now() - this.mouseDownTime;
                const posDiff = this.mouseDownPos ? 
                    Math.sqrt(Math.pow(e.clientX - this.mouseDownPos.x, 2) + 
                             Math.pow(e.clientY - this.mouseDownPos.y, 2)) : 0;
                

                
                // If it's a quick click (not a drag)
                if (timeDiff < 200 && posDiff < 5) {

                    e.preventDefault();
                    e.stopPropagation();
                    this.handleSketchClick(e);
                } else if (this.isDragging && this.currentSketch.currentTool === 'rectangle') {
                    // End drag for rectangle

                    this.handleSketchClick(e);
                }
                
                this.isDragging = false;
                this.mouseDownPos = null;
            } else if (e.button === 1 || e.button === 2) {
                // Middle or right click - stop camera panning
                this.sketchCameraState.isPanning = false;

            }
        };
        
        // Unified mouse move handler for both drawing and camera
        this.sketchMoveHandler = (e) => {
            if (!this.isSketchMode) return;
            
            // Handle camera panning
            if (this.sketchCameraState.isPanning) {
                const deltaX = e.clientX - this.sketchCameraState.lastX;
                const deltaY = e.clientY - this.sketchCameraState.lastY;
                
                // Pan along the sketch plane
                const panSensitivity = 0.01;
                const panVector = this.sketchRight.scale(-deltaX * panSensitivity)
                    .add(this.sketchUp.scale(deltaY * panSensitivity));
                
                this.camera.position = this.camera.position.add(panVector);
                this.camera.setTarget(this.camera.getTarget().add(panVector));
                
                this.sketchCameraState.lastX = e.clientX;
                this.sketchCameraState.lastY = e.clientY;
                return; // Don't process drawing when panning
            }
            
            // Handle drawing interactions
            if (this.currentSketch) {
                // Rectangle drawing is already started on mouse down, just continue updating
                // No need for drag detection threshold
                
                // Update preview if drawing
                if (this.currentSketch.isDrawing) {
                    this.updateSketchPreview(e);
                }
            }
        };
        
        // Unified wheel handler for camera zoom
        this.sketchWheelHandler = (e) => {
            if (!this.isSketchMode) return;
            
            e.preventDefault();
            
            // Zoom by adjusting orthographic bounds - more responsive
            const zoomFactor = e.deltaY > 0 ? 1.05 : 0.95;  // Smaller steps for smoother zoom
            const aspectRatio = this.engine.getAspectRatio(this.camera);
            
            const currentHeight = this.camera.orthoTop - this.camera.orthoBottom;
            const newHeight = currentHeight * zoomFactor;
            const newWidth = newHeight * aspectRatio;
            
            this.camera.orthoLeft = -newWidth / 2;
            this.camera.orthoRight = newWidth / 2;
            this.camera.orthoBottom = -newHeight / 2;
            this.camera.orthoTop = newHeight / 2;
        };
        
        // Use Babylon.js pointer event system instead of direct mouse events
        this.scene.onPointerObservable.add((pointerInfo) => {

            
            if (!this.isSketchMode) return;
            
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:

                    this.handleBabylonPointerDown(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:

                    this.handleBabylonPointerUp(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.handleBabylonPointerMove(pointerInfo);
                    break;
            }
        });
        

        
        // Test that canvas is receiving events
        // Removed duplicate click handler
    }
    
    handleBabylonPointerDown(pointerInfo) {
        try {
            const event = pointerInfo.event;
            
            // Handle surface selection for sketch tool
            if (this.waitingForSurface && event.button === 0) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                
                // Pick any surface in the scene
                const pickInfo = this.scene.pick(x, y, (mesh) => {
                    // Accept any pickable mesh that could be a surface, including default sketch planes
                    const isValid = mesh.isPickable && mesh.name !== 'sketchGround';
                    return isValid;
                });
                
                
                if (pickInfo.hit && pickInfo.pickedMesh) {
                    this.enterSketchModeOnSurface(pickInfo.pickedMesh, pickInfo.pickedPoint, pickInfo.getNormal());
                    return; // Stop processing - we handled the surface selection
                } else {
                }
            }

            // Check for part selection (only if not waiting for surface)
            if (!this.waitingForSurface && event.button === 0) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // FIRST check if we clicked on a gizmo - they have priority
                const gizmoPickInfo = this.scene.pick(x, y, (mesh) => mesh && mesh.isGizmo);
                if (gizmoPickInfo.hit) {
                    console.log("Clicked on gizmo, skipping part selection");
                    return; // Let the gizmo handle this click
                }
                
                // Check if we clicked on a mesh with partData property
                const partPickInfo = this.scene.pick(x, y, (mesh) => mesh && mesh.partData);
                
                if (partPickInfo.hit && partPickInfo.pickedMesh && partPickInfo.pickedMesh.partData) {
                    this.selectPart(partPickInfo.pickedMesh.partData);
                    return; // Stop processing - we handled the part selection
                } else {
                    // Clicked on empty space - deselect current part
                    if (this.selectedPart) {
                        console.log("Clicked empty space, deselecting part");
                        this.deselectPart();
                    }
                }
            }

            if (event.button === 0) {
                // Left click - drawing
                console.log('LEFT CLICK - sketch mode:', this.isSketchMode, 'current tool:', this.currentSketch?.currentTool);
                try {
                    this.mouseDownTime = Date.now();
                    this.mouseDownPos = { x: event.clientX, y: event.clientY };
                    this.isDragging = false;
                
                
                // For rectangle tool, start drawing immediately on mouse down
                if (this.currentSketch && this.currentSketch.currentTool === 'rectangle') {
                    console.log('RECTANGLE TOOL DETECTED');
                    const rect = this.canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                    console.log('PICK RESULT:', pickInfo.hit, pickInfo.pickedMesh?.name);
                    
                    if (pickInfo.hit) {
                        console.log('STARTING RECTANGLE DRAW');
                        // Start rectangle drawing immediately on mouse down
                        this.currentSketch.isDrawing = true;
                        // Apply grid snapping to start point (half-grid if Shift is held)
                        this.currentSketch.startPoint = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);
                        this.isDragging = true; // Set dragging immediately
                        
                        // Clear any existing preview
                        if (this.shapePreview) {
                            this.shapePreview.dispose();
                            this.shapePreview = null;
                        }
                        
                        this.createRectanglePreview(pickInfo.pickedPoint, pickInfo.pickedPoint);
                    }
                }
                
                // For circle tool, start drawing immediately on mouse down
                if (this.currentSketch && this.currentSketch.currentTool === 'circle') {
                    console.log('CIRCLE TOOL DETECTED');
                    const rect = this.canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                    console.log('CIRCLE PICK RESULT:', pickInfo.hit, pickInfo.pickedMesh?.name);
                    
                    if (pickInfo.hit) {
                        console.log('STARTING CIRCLE DRAW');
                        // Start circle drawing immediately on mouse down
                        this.currentSketch.isDrawing = true;
                        // Apply grid snapping to start point (half-grid if Shift is held)
                        this.currentSketch.startPoint = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);
                        this.isDragging = true; // Set dragging immediately
                        
                        // Clear any existing preview
                        if (this.shapePreview) {
                            this.shapePreview.dispose();
                            this.shapePreview = null;
                        }
                        
                        this.createCirclePreview(pickInfo.pickedPoint, 0);
                    }
                }
            
            } catch (error) {

            }
            

        } else if (event.button === 1 || event.button === 2) {
            // Middle or right click - camera panning
            this.sketchCameraState.isPanning = true;
            this.sketchCameraState.lastX = event.clientX;
            this.sketchCameraState.lastY = event.clientY;

        }
        
        } catch (error) {

        }
    }
    
    handleBabylonPointerUp(pointerInfo) {
        const event = pointerInfo.event;

        
        if (event.button === 0) {
            // Left click - drawing
            const timeDiff = Date.now() - this.mouseDownTime;
            const posDiff = this.mouseDownPos ? 
                Math.sqrt(Math.pow(event.clientX - this.mouseDownPos.x, 2) + 
                         Math.pow(event.clientY - this.mouseDownPos.y, 2)) : 0;
            

            



            
            // For rectangle tool, finish drawing on mouse up if we were dragging
            if (this.currentSketch && this.currentSketch.currentTool === 'rectangle' && this.currentSketch.isDrawing) {

                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                if (pickInfo.hit) {
                    // Apply grid snapping to end point (half-grid if Shift is held)
                    const snappedPoint = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);
                    this.finishRectangle(snappedPoint);
                    this.currentSketch.isDrawing = false;
                } else {

                }
            }
            // For circle tool, finish drawing on mouse up if we were dragging
            else if (this.currentSketch && this.currentSketch.currentTool === 'circle' && this.currentSketch.isDrawing) {
                console.log('FINISHING CIRCLE DRAW');
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
                if (pickInfo.hit) {
                    // Apply grid snapping to end point
                    const snappedPoint = this.snapToGrid(pickInfo.pickedPoint);
                    // Calculate radius from start point to snapped end point
                    const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, snappedPoint);
                    console.log('Circle radius:', radius);
                    this.finishCircle(radius);
                    this.currentSketch.isDrawing = false;
                }
            }
            // For NON-rectangle/circle tools, use the old click system
            else if (this.currentSketch && this.currentSketch.currentTool !== 'rectangle' && this.currentSketch.currentTool !== 'circle' && 
                     timeDiff < 1000 && posDiff < 20) {

                this.handleSketchClick(event);
            }
            // For rectangle tool with quick clicks, also avoid the old system
            else if (this.currentSketch && this.currentSketch.currentTool === 'rectangle') {

            }
            else {

            }
            
            this.isDragging = false;
            this.mouseDownPos = null;
        } else if (event.button === 1 || event.button === 2) {
            // Middle or right click - stop camera panning
            this.sketchCameraState.isPanning = false;

        }
    }
    
    handleBabylonPointerMove(pointerInfo) {
        const event = pointerInfo.event;
        
        // Handle camera panning
        if (this.sketchCameraState.isPanning) {
            const deltaX = event.clientX - this.sketchCameraState.lastX;
            const deltaY = event.clientY - this.sketchCameraState.lastY;
            
            // Pan along the sketch plane
            const panSensitivity = 0.01;
            const panVector = this.sketchRight.scale(-deltaX * panSensitivity)
                .add(this.sketchUp.scale(deltaY * panSensitivity));
            
            this.camera.position = this.camera.position.add(panVector);
            this.camera.setTarget(this.camera.getTarget().add(panVector));
            
            this.sketchCameraState.lastX = event.clientX;
            this.sketchCameraState.lastY = event.clientY;
            return;
        }
        
        // Handle drawing preview with proper coordinate handling
        if (this.currentSketch && this.currentSketch.isDrawing) {

            
            // Get canvas coordinates from Babylon pointer event
            const rect = this.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Pick the sketch ground for preview
            const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
            
            if (pickInfo.hit) {
                // Apply grid snapping to preview point (half-grid if Shift is held)
                const point = this.snapToGrid(pickInfo.pickedPoint, event.shiftKey);

                this.updateSketchPreviewWithPoint(point);
            } else {

            }
        }
    }
    
    setupSketchCameraControls() {
        // Disable default camera controls for sketch mode
        this.camera.detachControl(this.canvas);
        
        // Custom sketch camera controls for pan and zoom only
        this.sketchCameraState = {
            isPanning: false,
            lastX: 0,
            lastY: 0
        };
        
        // Note: Mouse handlers are now handled via Babylon.js pointer system

        
        // Add escape key handler
        this.sketchEscapeHandler = (e) => {
            if (e.key === 'Escape' && this.isSketchMode) {
                if (this.currentSketch && this.currentSketch.isDrawing) {
                    {
                        // Cancel current drawing
                        this.cancelCurrentDrawing();
                    }
                } else {
                    this.exitSketchMode();
                }
            }
        };
        document.addEventListener('keydown', this.sketchEscapeHandler);
    }
    
    setupSketchCameraControls() {
        // Disable default camera controls for sketch mode
        this.camera.detachControl(this.canvas);
        
        // Custom sketch camera controls for pan and zoom only
        this.sketchCameraState = {
            isPanning: false,
            lastX: 0,
            lastY: 0
        };
        
        // Note: Mouse handlers will be set up in setupSketchingMouseHandlers to avoid conflicts

    }
    
    createSketchPlaneGrid() {
        // Remove existing sketch grid if it exists
        if (this.sketchGrid) {
            this.sketchGrid.dispose();
            this.sketchGrid = null;
        }
        
        // Hide the main grid when in sketch mode
        if (this.gridSystem.gridGround) {
            this.gridSystem.gridGround.setEnabled(false);
        }
        
        // DIM NON-SKETCH MESHES BUT KEEP THEM VISIBLE FOR REFERENCE
        this.scene.meshes.forEach(mesh => {
            // Keep sketch shapes visible (rectangles, circles, etc.)
            const isSketchShape = mesh.name.includes('sketch') || mesh.name.includes('Sketch');
            
            if (!mesh.name.includes('Plane') && mesh.name !== 'sketchGround' && !isSketchShape) {
                // Dim background objects instead of hiding them
                if (mesh.material && !mesh.originalAlpha) {
                    // Store original alpha for restoration later
                    mesh.originalAlpha = mesh.material.alpha !== undefined ? mesh.material.alpha : 1.0;
                    // Dim to 30% opacity
                    mesh.material.alpha = mesh.originalAlpha * 0.3;
                }
                // Make them non-pickable during sketch mode
                mesh.isPickable = false;
            }
            
            // Hide the sketch plane indicators after entering sketch mode
            if (mesh.name.includes('Plane')) {
                mesh.isVisible = false;
                mesh.isPickable = false; // Also make them non-pickable
            }
        });
        
        // Create or update the sketch ground plane for picking
        this.updateSketchGround();
        
        // Create sketch grid lines
        this.createSketchGridLines();
        
        // Force the ground to update
        this.sketchGround.computeWorldMatrix(true);
    }
    
    createSketchGridLines() {
        // Create grid lines for sketch mode - positioned on the sketch surface
        const gridSize = 300; // 300cm grid (3 meters) - large area for sketching
        const divisions = 60; // 60 divisions = 5cm spacing
        const lineSpacing = gridSize / divisions;
        
        // Store grid spacing for snapping
        this.gridSpacing = lineSpacing; // 5cm
        this.halfGridSpacing = lineSpacing / 2; // 2.5cm
        
        this.sketchGridLines = [];
        
        // Get the sketch surface position and orientation
        const surfacePosition = this.currentSketchSurface.point;
        const surfaceNormal = this.currentSketchSurface.normal;
        
        // Create grid material
        const gridMaterial = new BABYLON.StandardMaterial('sketchGridMaterial', this.scene);
        gridMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
        gridMaterial.emissiveColor = new BABYLON.Color3(0.7, 0.7, 0.7);
        gridMaterial.disableLighting = true;
        gridMaterial.alpha = 0.8;
        
        // Use sketch coordinate system for proper grid orientation
        const right = this.sketchRight;
        const up = this.sketchUp;
        
        // Create horizontal lines (along the right direction)
        for (let i = 0; i <= divisions; i++) {
            const upOffset = -gridSize/2 + i * lineSpacing;
            const start = surfacePosition.add(right.scale(-gridSize/2)).add(up.scale(upOffset));
            const end = surfacePosition.add(right.scale(gridSize/2)).add(up.scale(upOffset));
            
            const points = [start, end];
            const line = BABYLON.MeshBuilder.CreateLines(`sketchGridH${i}`, {points: points}, this.scene);
            line.material = gridMaterial;
            line.isPickable = false;
            this.sketchGridLines.push(line);
        }
        
        // Create vertical lines (along the up direction)
        for (let i = 0; i <= divisions; i++) {
            const rightOffset = -gridSize/2 + i * lineSpacing;
            const start = surfacePosition.add(right.scale(rightOffset)).add(up.scale(-gridSize/2));
            const end = surfacePosition.add(right.scale(rightOffset)).add(up.scale(gridSize/2));
            
            const points = [start, end];
            const line = BABYLON.MeshBuilder.CreateLines(`sketchGridV${i}`, {points: points}, this.scene);
            line.material = gridMaterial;
            line.isPickable = false;
            this.sketchGridLines.push(line);
        }
    }
    
    snapToGrid(point, useHalfGrid = false) {
        if (!this.gridSpacing || !this.sketchRight || !this.sketchUp || !this.currentSketchSurface) return point;
        
        const spacing = useHalfGrid ? this.halfGridSpacing : this.gridSpacing;
        
        // Convert world point to sketch plane coordinates
        const sketchOrigin = this.currentSketchSurface.point;
        const localVector = point.subtract(sketchOrigin);
        
        // Project onto sketch plane axes
        const rightComponent = BABYLON.Vector3.Dot(localVector, this.sketchRight);
        const upComponent = BABYLON.Vector3.Dot(localVector, this.sketchUp);
        
        // Snap in sketch plane coordinates
        const snappedRight = Math.round(rightComponent / spacing) * spacing;
        const snappedUp = Math.round(upComponent / spacing) * spacing;
        
        // Convert back to world coordinates
        const snappedPoint = sketchOrigin
            .add(this.sketchRight.scale(snappedRight))
            .add(this.sketchUp.scale(snappedUp));
            
        return snappedPoint;
    }
    
    updateSketchGround() {
        // Remove existing sketch ground if it exists
        const existingGround = this.scene.getMeshByName('sketchGround');
        if (existingGround) {
            existingGround.dispose();
        }
        
        // Create a ground plane aligned with the selected surface - make it much larger
        this.sketchGround = BABYLON.MeshBuilder.CreatePlane('sketchGround', {
            width: 1000,  // 10 meter wide sketch area
            height: 1000  // 10 meter tall sketch area
        }, this.scene);
        
        // Position at the picked point on the surface
        this.sketchGround.position = this.currentSketchSurface.point.clone();
        
        // Align the ground plane with the surface normal
        // Create rotation to align plane normal with surface normal
        const surfaceNormal = this.currentSketchSurface.normal.normalize();
        const defaultNormal = new BABYLON.Vector3(0, 0, 1); // Default plane normal
        
        // Calculate rotation quaternion to align default normal with surface normal
        const rotationAxis = BABYLON.Vector3.Cross(defaultNormal, surfaceNormal);
        const rotationAngle = Math.acos(BABYLON.Vector3.Dot(defaultNormal, surfaceNormal));
        
        if (rotationAxis.length() > 0.001) {
            // Non-parallel normals - create rotation
            rotationAxis.normalize();
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.RotationAxis(rotationAxis, rotationAngle);
        } else if (BABYLON.Vector3.Dot(defaultNormal, surfaceNormal) < 0) {
            // Opposite normals - rotate 180 degrees around X axis
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(1, 0, 0), Math.PI);
        } else {
            // Same direction - no rotation needed
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.Identity();
        }
        
        // Create material for ground plane
        const groundMaterial = new BABYLON.StandardMaterial('sketchGroundMat', this.scene);
        groundMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 1.0); // Light blue tint
        groundMaterial.alpha = 0.001; // Nearly invisible but still pickable
        groundMaterial.backFaceCulling = false;
        this.sketchGround.material = groundMaterial;
        
        this.sketchGround.isVisible = true; // Must be visible for picking
        this.sketchGround.isPickable = true;
        

    }
    
    createLineGrid() {

        
        const gridSize = 20;
        const lineSpacing = 1;
        
        // Grid center at the surface origin (picked point) - CRITICAL for 3D geometry placement
        const gridCenter = this.sketchOrigin.clone();

        
        // Create arrays to hold all line segments
        const verticalLines = [];
        const horizontalLines = [];
        

        
        // Create grid lines aligned with the surface coordinate system
        for (let i = -gridSize; i <= gridSize; i += lineSpacing) {
            // Vertical lines (along sketch Up direction)
            const vStart = gridCenter
                .add(this.sketchRight.scale(i))
                .add(this.sketchUp.scale(-gridSize));
            const vEnd = gridCenter
                .add(this.sketchRight.scale(i))
                .add(this.sketchUp.scale(gridSize));
            verticalLines.push([vStart, vEnd]);
            
            // Horizontal lines (along sketch Right direction)
            const hStart = gridCenter
                .add(this.sketchRight.scale(-gridSize))
                .add(this.sketchUp.scale(i));
            const hEnd = gridCenter
                .add(this.sketchRight.scale(gridSize))
                .add(this.sketchUp.scale(i));
            horizontalLines.push([hStart, hEnd]);
        }
        

        
        // Log first few line positions for debugging
        if (verticalLines.length > 0) {

        }
        if (horizontalLines.length > 0) {

        }
        
        // Create line systems for better performance
        const verticalLineSystem = BABYLON.MeshBuilder.CreateLineSystem("verticalSketchGrid", {
            lines: verticalLines
        }, this.scene);
        verticalLineSystem.color = new BABYLON.Color3(0.6, 0.6, 0.6); // Grid lines
        verticalLineSystem.isPickable = false;
        
        const horizontalLineSystem = BABYLON.MeshBuilder.CreateLineSystem("horizontalSketchGrid", {
            lines: horizontalLines
        }, this.scene);
        horizontalLineSystem.color = new BABYLON.Color3(0.6, 0.6, 0.6); // Grid lines
        horizontalLineSystem.isPickable = false;
        
        // Create center axis lines with different colors
        const centerLines = [];
        
        // X axis (red) - along surface Right direction
        centerLines.push(BABYLON.MeshBuilder.CreateLines("sketchCenterX", {
            points: [
                gridCenter.add(this.sketchRight.scale(-gridSize)),
                gridCenter.add(this.sketchRight.scale(gridSize))
            ]
        }, this.scene));
        centerLines[0].color = new BABYLON.Color3(0.9, 0.2, 0.2); // Red
        centerLines[0].isPickable = false;
        
        // Y axis (green) - along surface Up direction
        centerLines.push(BABYLON.MeshBuilder.CreateLines("sketchCenterY", {
            points: [
                gridCenter.add(this.sketchUp.scale(-gridSize)),
                gridCenter.add(this.sketchUp.scale(gridSize))
            ]
        }, this.scene));
        centerLines[1].color = new BABYLON.Color3(0.2, 0.9, 0.2); // Green
        centerLines[1].isPickable = false;
        
        // Store all grid elements for cleanup
        this.sketchGridLines = [verticalLineSystem, horizontalLineSystem, ...centerLines];
        
        // Add fade-in effect for grid
        this.animateGridFadeIn();
        

    }
    
    animateGridFadeIn() {
        // Start with invisible grid
        this.sketchGridLines.forEach(gridLine => {
            gridLine.alpha = 0;
        });
        
        // Beautiful slow fade-in synchronized with camera movement
        const fadeInDuration = 1800; // 1.8 seconds for gentle appearance
        const startDelay = 800; // Start fade after 0.8s (during camera alignment phase)
        const startTime = Date.now();
        
        const fadeIn = () => {
            const elapsed = Date.now() - startTime;
            
            if (elapsed < startDelay) {
                // Wait for camera alignment to progress before starting fade
                requestAnimationFrame(fadeIn);
                return;
            }
            
            const fadeProgress = Math.min((elapsed - startDelay) / fadeInDuration, 1);
            
            // Beautiful ease-in-out effect
            const easedProgress = this.easeInOutCubic(fadeProgress);
            
            // Update alpha of all grid lines with gentle fade
            this.sketchGridLines.forEach(gridLine => {
                gridLine.alpha = easedProgress * 0.8; // Slightly more subtle than full opacity
            });
            
            if (fadeProgress < 1) {
                requestAnimationFrame(fadeIn);
            }
        };
        
        requestAnimationFrame(fadeIn);
    }

    handleSketchClick(event) {



        
        if (!this.isSketchMode || !this.currentSketch) {

            return;
        }
        
        // Get canvas-relative coordinates from the Babylon pointer event
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        

        
        // Use Babylon's picking with proper coordinates
        const pickInfo = this.scene.pick(x, y, (mesh) => {
            // Only pick the sketch ground for drawing
            return mesh.name === 'sketchGround';
        });
        
        
        if (pickInfo.hit && pickInfo.pickedMesh.name === 'sketchGround') {
            const point = pickInfo.pickedPoint;
            
            // Use the picked point directly since it's on the sketch plane
            const sketchPoint = point.clone();
            

            
            // Handle different tools
            switch (this.currentSketch.currentTool) {
                case 'line':

                    this.handleLineDrawing(sketchPoint);
                    break;
                case 'rectangle':

                    this.handleRectangleDrawing(sketchPoint);
                    break;
                case 'circle':

                    this.handleCircleDrawing(sketchPoint);
                    break;
                case 'ellipse':
                    this.handleEllipseDrawing(sketchPoint);
                    break;
                case 'triangle':
                    this.handleTriangleDrawing(sketchPoint);
                    break;
            }
        } else {

            
            const generalPick = this.scene.pick(x, y);
        }

    }

    projectToSketchPlane(point) {
        // Project the 3D point onto the sketch plane using the surface coordinate system
        // The sketch plane is defined by the surface origin and normal
        
        // Vector from surface origin to the point
        const toPoint = point.subtract(this.sketchOrigin);
        
        // Project out the component along the surface normal (keep point on the plane)
        const normalComponent = BABYLON.Vector3.Dot(toPoint, this.sketchForward);
        const projectedPoint = point.subtract(this.sketchForward.scale(normalComponent));
        
        return projectedPoint;
    }

    handleLineDrawing(point) {

        
        if (!this.currentSketch.isDrawing) {
            // Start line
            this.currentSketch.startPoint = point;
            this.currentSketch.isDrawing = true;

            
            // Create temporary line preview
            this.createLinePreview(point, point);
        } else {
            // End line

            this.finishLine(point);
            this.currentSketch.isDrawing = false;
        }
    }

    createLinePreview(start, end) {
        // Remove existing preview
        if (this.linePreview) {
            this.linePreview.dispose();
        }
        
        // Create new line preview using ribbon for thickness
        const distance = BABYLON.Vector3.Distance(start, end);
        if (distance > 0.01) { // Only create if line has meaningful length
            const direction = end.subtract(start).normalize();
            
            // Create a perpendicular vector for ribbon width
            const perpendicular = BABYLON.Vector3.Cross(direction, this.sketchForward).normalize();
            const halfWidth = 0.02; // Thin ribbon width for 2D appearance
            
            // Create ribbon path with slight width
            const path1 = [
                start.add(perpendicular.scale(halfWidth)),
                end.add(perpendicular.scale(halfWidth))
            ];
            const path2 = [
                start.subtract(perpendicular.scale(halfWidth)),
                end.subtract(perpendicular.scale(halfWidth))
            ];
            
            this.linePreview = BABYLON.MeshBuilder.CreateRibbon('linePreview', {
                pathArray: [path1, path2],
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Apply thick line material
            this.linePreview.material = this.thickLineMaterial.clone('previewMaterial');
            this.linePreview.material.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green preview
            this.linePreview.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
            this.linePreview.isPickable = false;
            this.linePreview.renderingGroupId = 2;
        }
    }

    finishLine(endPoint) {
        // Remove preview
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        
        // Create final line using ribbon for thickness
        const start = this.currentSketch.startPoint;
        const distance = BABYLON.Vector3.Distance(start, endPoint);
        
        if (distance > 0.01) { // Only create if line has meaningful length
            const direction = endPoint.subtract(start).normalize();
            
            // Create a perpendicular vector for ribbon width
            const perpendicular = BABYLON.Vector3.Cross(direction, this.sketchForward).normalize();
            const halfWidth = 0.02; // Thin ribbon width for 2D appearance
            
            // Create ribbon path with slight width
            const path1 = [
                start.add(perpendicular.scale(halfWidth)),
                endPoint.add(perpendicular.scale(halfWidth))
            ];
            const path2 = [
                start.subtract(perpendicular.scale(halfWidth)),
                endPoint.subtract(perpendicular.scale(halfWidth))
            ];
            
            const line = BABYLON.MeshBuilder.CreateRibbon('sketchLine', {
                pathArray: [path1, path2],
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.scene);
            
            // Apply thick line material
            line.material = this.thickLineMaterial.clone('lineMaterial');
            line.isPickable = true;
            line.renderingGroupId = 2;
            
            // Add to sketch elements
            this.currentSketch.elements.push({
                type: 'line',
                start: this.currentSketch.startPoint,
                end: endPoint,
                mesh: line
            });
        }
        

    }
    
    createRectanglePreview(start, end) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        // Calculate rectangle corners
        const corners = this.getRectangleCorners(start, end);
        
        // Create thick line loop for rectangle preview
        const previewMaterial = this.thickLineMaterial.clone('rectPreviewMaterial');
        previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
        previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
        
        this.shapePreview = this.createThickLineLoop(corners, 'rectPreview', previewMaterial);
        
        if (this.shapePreview) {
            this.shapePreview.isPickable = false;
            this.shapePreview.renderingGroupId = 2;
        }
        

    }
    
    finishRectangle(endPoint) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        const corners = this.getRectangleCorners(this.currentSketch.startPoint, endPoint);
        
        // Create thick rectangle with filled face
        const rect = this.createFilledRectangle(corners, 'sketchRectangle', this.thickLineMaterial.clone('rectMaterial'));
        
        if (rect) {
            rect.isPickable = true;
            rect.renderingGroupId = 1;
            
            // Store as closed shape
            this.currentSketch.elements.push({
                type: 'rectangle',
                points: corners,
                mesh: rect,
                closed: true
            });
        }
    }
    
    createCirclePreview(center, radius) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (radius > 0.1) { // Only show circle preview if radius is meaningful
            const points = this.getCirclePoints(center, radius);
            
            // Create thick line loop for circle preview
            const previewMaterial = this.thickLineMaterial.clone('circlePreviewMaterial');
            previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
            previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
            
            this.shapePreview = this.createThickLineLoop(points, 'circlePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        } else {
            // Show center point indicator when radius is too small
            const centerIndicator = BABYLON.MeshBuilder.CreateSphere('circleCenterPreview', {
                diameter: 0.2
            }, this.scene);
            centerIndicator.position = center.clone();
            
            const centerMaterial = new BABYLON.StandardMaterial('centerMaterial', this.scene);
            centerMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green
            centerMaterial.emissiveColor = new BABYLON.Color3(0, 1, 0);
            centerMaterial.disableLighting = true;
            
            centerIndicator.material = centerMaterial;
            centerIndicator.isPickable = false;
            centerIndicator.renderingGroupId = 2;
            
            this.shapePreview = centerIndicator;
        }
    }
    
    finishCircle(radius) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        const points = this.getCirclePoints(this.currentSketch.startPoint, radius);
        
        // Create filled circle
        const circle = this.createFilledCircle(this.currentSketch.startPoint, radius, 'sketchCircle', this.thickLineMaterial.clone('circleMaterial'));
        
        if (circle) {
            circle.isPickable = true;
            circle.renderingGroupId = 1;
            
            this.currentSketch.elements.push({
                type: 'circle',
                center: this.currentSketch.startPoint,
                radius: radius,
                mesh: circle,
                closed: true
            });
        }
    }
    
    createEllipsePreview(center, radiusX, radiusY) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (radiusX > 0 || radiusY > 0) {
            const points = this.getEllipsePoints(center, radiusX, radiusY);
            
            // Create thick line loop for ellipse preview
            const previewMaterial = this.thickLineMaterial.clone('ellipsePreviewMaterial');
            previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
            previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
            
            this.shapePreview = this.createThickLineLoop(points, 'ellipsePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    finishEllipse(endPoint) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        const center = this.currentSketch.startPoint;
        
        // Calculate radii using surface coordinate system
        const endOffset = endPoint.subtract(center);
        const radiusX = Math.abs(BABYLON.Vector3.Dot(endOffset, this.sketchRight));
        const radiusY = Math.abs(BABYLON.Vector3.Dot(endOffset, this.sketchUp));
        
        const points = this.getEllipsePoints(center, radiusX, radiusY);
        
        // Create filled ellipse
        const ellipse = this.createFilledEllipse(center, radiusX, radiusY, 'sketchEllipse', this.thickLineMaterial.clone('ellipseMaterial'));
        
        if (ellipse) {
            ellipse.isPickable = true;
            ellipse.renderingGroupId = 1;
            
            this.currentSketch.elements.push({
                type: 'ellipse',
                center: center,
                radiusX: radiusX,
                radiusY: radiusY,
                mesh: ellipse,
                closed: true
            });
        }
    }
    
    
    createTrianglePreview(points) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (points.length >= 2) {
            const previewPoints = [...points];
            if (points.length === 2) {
                // Show two sides of triangle
                previewPoints.push(points[0]);
            } else if (points.length === 3) {
                // Complete triangle
                previewPoints.push(points[0]);
            }
            
            // Create thick line loop for triangle preview
            const previewMaterial = this.thickLineMaterial.clone('trianglePreviewMaterial');
            previewMaterial.diffuseColor = new BABYLON.Color3(0, 0.6, 0); // Dark green preview
            previewMaterial.emissiveColor = new BABYLON.Color3(0, 0.6, 0);
            
            this.shapePreview = this.createThickLineLoop(previewPoints.slice(0, -1), 'trianglePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    finishTriangle() {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        // Create filled triangle using filled shape
        const triangle = this.createFilledShape(this.currentSketch.trianglePoints, 'sketchTriangle', this.thickLineMaterial.clone('triangleMaterial'));
        
        if (triangle) {
            triangle.isPickable = true;
            triangle.renderingGroupId = 1;
            
            this.currentSketch.elements.push({
                type: 'triangle',
                points: this.currentSketch.trianglePoints,
                mesh: triangle,
                closed: true
            });
        }
        
        this.currentSketch.trianglePoints = [];
    }
    
    // Helper methods for shape generation using surface coordinate system
    getRectangleCorners(start, end) {
        
        // Use Shape2D method for proper coordinate system handling
        if (this.shape2D) {
            const corners = this.shape2D.getRectangleCorners(start, end);
            if (!corners || corners.length !== 4) {
                // Fallback if Shape2D method fails
                return this.getFallbackRectangleCorners(start, end);
            }
            return corners;
        }
        
        return this.getFallbackRectangleCorners(start, end);
    }
    
    getFallbackRectangleCorners(start, end) {
        // Create proper rectangle corners using sketch coordinate system
        if (this.sketchRight && this.sketchUp) {
            // Calculate dimensions in the sketch coordinate system
            const startToEnd = end.subtract(start);
            const rightComponent = BABYLON.Vector3.Dot(startToEnd, this.sketchRight);
            const upComponent = BABYLON.Vector3.Dot(startToEnd, this.sketchUp);
            
            // Calculate the actual corners based on the min/max of the two points
            const minRight = Math.min(0, rightComponent);
            const maxRight = Math.max(0, rightComponent);
            const minUp = Math.min(0, upComponent);
            const maxUp = Math.max(0, upComponent);
            
            // Create proper rectangle corners using the sketch coordinate system
            const corners = [
                start.add(this.sketchRight.scale(minRight)).add(this.sketchUp.scale(minUp)),     // Bottom-left
                start.add(this.sketchRight.scale(maxRight)).add(this.sketchUp.scale(minUp)),     // Bottom-right
                start.add(this.sketchRight.scale(maxRight)).add(this.sketchUp.scale(maxUp)),     // Top-right
                start.add(this.sketchRight.scale(minRight)).add(this.sketchUp.scale(maxUp))      // Top-left
            ];
            
            return corners;
        } else {
            // Final fallback to XZ plane
            const corners = [
                start.clone(),                                // Corner 1 (start)
                new BABYLON.Vector3(end.x, start.y, start.z), // Corner 2 (end.x, start.y)
                end.clone(),                                  // Corner 3 (end)
                new BABYLON.Vector3(start.x, start.y, end.z)  // Corner 4 (start.x, end.z) - FIXED!
            ];
            
            return corners;
        }
    }
    
    getCirclePoints(center, radius, segments = 32) {
        const points = [];
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            
            // Generate circle points in the surface coordinate system
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            
            // Convert to world coordinates using surface vectors
            const worldPoint = center
                .add(this.sketchRight.scale(x))
                .add(this.sketchUp.scale(y));
            
            points.push(worldPoint);
        }
        
        return points;
    }
    
    getEllipsePoints(center, radiusX, radiusY, segments = 32) {
        const points = [];
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            
            // Generate ellipse points in the surface coordinate system
            const x = radiusX * Math.cos(angle);
            const y = radiusY * Math.sin(angle);
            
            // Convert to world coordinates using surface vectors
            const worldPoint = center
                .add(this.sketchRight.scale(x))
                .add(this.sketchUp.scale(y));
            
            points.push(worldPoint);
        }
        
        return points;
    }
    
    updateSketchPreview(event) {
        const pickInfo = this.scene.pick(event.clientX, event.clientY, (mesh) => mesh.name === 'sketchGround');
        
        if (pickInfo.hit) {
            const point = pickInfo.pickedPoint; // Use direct coordinates - no double transformation
            
            switch (this.currentSketch.currentTool) {
                case 'line':
                    if (this.linePreview) {
                        this.linePreview.dispose();
                        this.createLinePreview(this.currentSketch.startPoint, point);
                    }
                    break;
                    
                case 'rectangle':
                    if (this.currentSketch.startPoint) {
                        this.createRectanglePreview(this.currentSketch.startPoint, point);
                    }
                    break;
                    
                case 'circle':
                    if (this.currentSketch.startPoint) {
                        const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, point);
                        this.createCirclePreview(this.currentSketch.startPoint, radius);
                    }
                    break;
                    
                case 'ellipse':
                    if (this.currentSketch.startPoint) {
                        const offset = point.subtract(this.currentSketch.startPoint);
                        const radiusX = Math.abs(BABYLON.Vector3.Dot(offset, this.sketchRight));
                        const radiusY = Math.abs(BABYLON.Vector3.Dot(offset, this.sketchUp));
                        this.createEllipsePreview(this.currentSketch.startPoint, radiusX, radiusY);
                    }
                    break;
            }
        }
    }
    
    cancelCurrentDrawing() {
        // Clean up any preview shapes
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        // Reset drawing state
        this.currentSketch.isDrawing = false;
        this.currentSketch.startPoint = null;
        this.currentSketch.trianglePoints = [];
    }
    
    processSketchGeometry() {
        // Analyze sketch elements and remove non-closed geometry
        const closedElements = [];
        const elementsToRemove = [];
        
        for (const element of this.currentSketch.elements) {
            if (element.closed) {
                // Keep closed shapes (rectangles, circles, triangles)
                closedElements.push(element);
            } else if (element.type === 'line') {
                // Check if this line is part of a closed shape
                if (!this.isLinePartOfClosedShape(element)) {
                    elementsToRemove.push(element);
                }
            }
        }
        
        // Remove non-closed geometry
        for (const element of elementsToRemove) {
            if (element.mesh) {
                element.mesh.dispose();
            }
            const index = this.currentSketch.elements.indexOf(element);
            if (index > -1) {
                this.currentSketch.elements.splice(index, 1);
            }
        }
        

        
        // Store the closed shapes for potential extrusion
        this.closedShapes = closedElements;
    }
    
    isLinePartOfClosedShape(line) {
        // This is a simplified check - in a full implementation,
        // you would check if the line connects with other lines to form a closed shape
        // For now, we'll just remove all standalone lines
        return false;
    }

    handleRectangleDrawing(point) {


        
        if (!this.currentSketch.isDrawing) {
            // Start rectangle

            this.currentSketch.startPoint = point.clone();
            this.currentSketch.isDrawing = true;
            this.createRectanglePreview(point, point);
        } else {
            // End rectangle

            this.finishRectangle(point);
            this.currentSketch.isDrawing = false;
        }
    }

    handleCircleDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start circle (center point)
            this.currentSketch.startPoint = point;
            this.currentSketch.isDrawing = true;
            this.createCirclePreview(point, 0);
        } else {
            // End circle (radius point)
            const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, point);
            
            // Only create circle if radius is meaningful (prevent accidental tiny circles)
            if (radius > 0.1) {
                this.finishCircle(radius);
                this.currentSketch.isDrawing = false;
            }
            // If radius is too small, stay in drawing mode - user needs to move mouse further
        }
    }
    
    handleEllipseDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start ellipse (center point)
            this.currentSketch.startPoint = point;
            this.currentSketch.isDrawing = true;
            this.createEllipsePreview(point, 0, 0);
        } else {
            // End ellipse
            this.finishEllipse(point);
            this.currentSketch.isDrawing = false;
        }
    }
    
    
    handleTriangleDrawing(point) {
        if (!this.currentSketch.trianglePoints) {
            this.currentSketch.trianglePoints = [];
        }
        
        this.currentSketch.trianglePoints.push(point);
        
        if (this.currentSketch.trianglePoints.length === 1) {
            this.currentSketch.isDrawing = true;
            this.createTrianglePreview([point]);
        } else if (this.currentSketch.trianglePoints.length === 2) {
            this.createTrianglePreview(this.currentSketch.trianglePoints);
        } else if (this.currentSketch.trianglePoints.length === 3) {
            // Complete triangle
            this.finishTriangle();
            this.currentSketch.isDrawing = false;
            this.currentSketch.trianglePoints = [];
        }
    }

    exitSketchMode() {
        // Check for closed geometry before exiting
        if (this.currentSketch && this.currentSketch.elements) {
            this.processSketchGeometry();
            // Preserve shapes for next sketch session
            this.closedShapes = this.currentSketch.elements;
        }
        
        this.isSketchMode = false;
        this.currentSketchPlane = null;
        this.currentSketch = null;
        
        // Return to modeling mode - this will restore the Sketch tool button
        this.setMode('model');
        
        // Reset sketch tool selection state
        this.sketchToolSelected = false;
        this.waitingForSurface = false;
        
        // Hide any sketch targets that might still be visible
        this.hideSketchTargets();
        
        // Remove sketch mouse handlers
        if (this.sketchMouseDownHandler) {
            this.canvas.removeEventListener('mousedown', this.sketchMouseDownHandler, true);
            this.sketchMouseDownHandler = null;
        }
        
        if (this.sketchMouseUpHandler) {
            this.canvas.removeEventListener('mouseup', this.sketchMouseUpHandler, true);
            this.sketchMouseUpHandler = null;
        }
        
        if (this.sketchMoveHandler) {
            this.canvas.removeEventListener('mousemove', this.sketchMoveHandler, true);
            this.sketchMoveHandler = null;
        }
        
        // Remove escape key handler
        if (this.sketchEscapeHandler) {
            document.removeEventListener('keydown', this.sketchEscapeHandler);
            this.sketchEscapeHandler = null;
        }
        
        // Remove unified sketch handlers
        if (this.sketchMouseDownHandler) {
            this.canvas.removeEventListener('mousedown', this.sketchMouseDownHandler, true);
            this.canvas.removeEventListener('mouseup', this.sketchMouseUpHandler, true);
            this.canvas.removeEventListener('mousemove', this.sketchMoveHandler, true);
            this.canvas.removeEventListener('wheel', this.sketchWheelHandler, true);
            
            this.sketchMouseDownHandler = null;
            this.sketchMouseUpHandler = null;
            this.sketchMoveHandler = null;
            this.sketchWheelHandler = null;
        }
        
        // Restore perspective projection
        this.camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
        
        // Re-attach normal camera controls
        // this.camera.attachControl(this.canvas, true); // Commented out to prevent conflicts with custom camera controls
        
        // Remove sketch grid and restore main grid
        if (this.sketchGrid) {
            this.sketchGrid.dispose();
            this.sketchGrid = null;
        }
        
        // Remove sketch grid lines
        if (this.sketchGridLines) {
            this.sketchGridLines.forEach(line => line.dispose());
            this.sketchGridLines = null;
        }
        
        // Re-enable the main grid
        if (this.grid.isVisible) {
            if (this.gridSystem.gridGround) {
                // Dispose and recreate grid to ensure visibility
                this.gridSystem.recreate();
            } else {
                this.gridSystem.updateDynamicGrid();
            }
        }
        
        // Make all hidden meshes visible and pickable again
        this.scene.meshes.forEach(mesh => {
            if (mesh.name.includes('Plane')) {
                mesh.isVisible = true;
                mesh.isPickable = true; // Re-enable picking for target planes
            }
            // Also make sketch shapes visible and pickable
            if (mesh.name.includes('sketch') || mesh.name.includes('Rectangle') || mesh.name.includes('Circle')) {
                mesh.isVisible = true;
                mesh.isPickable = true;
            }
            // Restore original alpha for dimmed background objects
            if (mesh.originalAlpha !== undefined && mesh.material) {
                mesh.material.alpha = mesh.originalAlpha;
                mesh.originalAlpha = undefined; // Clean up
                mesh.isPickable = true; // Re-enable picking
            }
        });
        
        // Grid updates are managed by GridSystem internally
        
        // Restore original toolbar
        this.restoreMainToolbar();
        
        // Update properties panel to show kept shapes
        if (this.closedShapes && this.closedShapes.length > 0) {
            document.getElementById('selection-info').textContent = 
                `${this.closedShapes.length} shape(s) ready - Click to select and extrude`;
        } else {
            document.getElementById('selection-info').textContent = 
                'No shapes available - Enter sketch mode to draw';
        }
        

    }

    restoreMainToolbar() {
        const toolbar = document.querySelector('.toolbar');
        toolbar.innerHTML = `
            <button id="sketch-btn" class="tool-btn active">Sketch</button>
            <button id="model-btn" class="tool-btn">Model</button>
        `;
        
        // Re-add event listeners
        // Mode switching removed - sketch is now a tool, not a mode
    }

    setupEventListeners() {
        // Mode switching removed - sketch is now a tool, not a mode
        
        // Grid toggle
        document.getElementById('grid-toggle').addEventListener('click', () => {
            this.toggleGrid();
        });
        
        // Reset view
        document.getElementById('reset-view').addEventListener('click', () => {
            this.resetView();
        });
        
        // Back to dashboard
        document.getElementById('back-btn').addEventListener('click', () => {
            window.location.href = 'index.php';
        });
        
        // Bench switching
        document.getElementById('work-bench-btn').addEventListener('click', () => {
            this.switchBench('work');
        });
        
        document.getElementById('assembly-bench-btn').addEventListener('click', () => {
            this.switchBench('assembly');
        });
        
        // Include in project button (removed from UI - now handled via context menu)
        
        // Mouse position tracking
        this.canvas.addEventListener('mousemove', (event) => {
            this.updateCoordinates(event);
        });
        
        // Tool selection
        document.querySelectorAll('[data-tool]').forEach(button => {
            button.addEventListener('click', () => {
                // Update active tool button
                document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Set the current tool
                const tool = button.dataset.tool;
                this.selectSketchTool(tool);
            });
        });

        // Project Explorer part selection
        const projectPartsList = document.getElementById('project-parts-list');
        if (projectPartsList) {
            projectPartsList.addEventListener('click', (event) => {
                const listItem = event.target.closest('li');
                if (listItem) {
                    // Find the part based on the list item content
                    const partName = listItem.textContent.trim();
                    let selectedPart = null;
                    
                    // Search in project parts
                    selectedPart = this.projectParts.find(part => 
                        (part.name && part.name === partName) || 
                        (part.title && part.title === partName)
                    );
                    
                    // If not found in project parts, search in work bench parts
                    if (!selectedPart) {
                        selectedPart = this.workBenchParts.find(part => 
                            (part.name && part.name === partName) || 
                            (part.title && part.title === partName)
                        );
                    }
                    
                    if (selectedPart) {
                        this.selectPart(selectedPart);
                    }
                }
            });
        }

        // Escape key handler for deselecting parts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                // Deselect parts and faces
                if (this.selectedPart) {
                    console.log("Same part clicked, keeping selection");
                }
                if (this.selectedFace) {
                    this.deselectFace();
                }
            } else if (event.key === 'r' || event.key === 'R') {
                // Router bit library is now in properties panel - show message
                if (this.activeTool === 'router' && this.routerBitSystem) {
                    const selectionInfo = document.getElementById('selection-info');
                    if (selectionInfo) {
                        if (this.routerBitSystem.selectedEdges.length > 0) {
                            selectionInfo.innerHTML = '<strong>Router Tool:</strong><br>Router bit library is now available in the Properties panel â†’';
                        } else {
                            selectionInfo.innerHTML = '<strong>Router Tool:</strong><br>Select edges first - router bits will appear in Properties panel';
                        }
                    }
                }
            }
        });

        // Material Modal Event Handlers
        this.setupMaterialModalListeners();
    }

    async openMaterialModal() {
        const modal = document.getElementById('material-modal');
        if (!modal) return;

        // Load materials database if not loaded
        if (!this.materialsLibrary.isLoaded) {
            const loaded = await this.materialsLibrary.loadDatabase();
            if (!loaded) {
                console.error('Failed to load materials database');
                return;
            }
        }

        // Show modal
        modal.style.display = 'flex';
        
        // Reset modal state
        this.showMaterialGrid();
        
        // Populate materials and categories
        this.populateMaterialCategories();
        this.populateMaterialGrid();
        
        // Clear search
        const searchInput = document.getElementById('material-search');
        if (searchInput) {
            searchInput.value = '';
        }
    }

    closeMaterialModal() {
        const modal = document.getElementById('material-modal');
        if (modal) {
            modal.style.display = 'none';
        }
        
        // Reset state
        this.selectedMaterialId = null;
        this.selectedMaterial = null;
        this.showMaterialGrid();
    }

    populateMaterialCategories() {
        const tabsContainer = document.getElementById('material-category-tabs');
        if (!tabsContainer || !this.materialsLibrary.categories) return;

        tabsContainer.innerHTML = '';
        
        // Add "All" tab
        const allTab = document.createElement('div');
        allTab.className = 'category-tab active';
        allTab.dataset.category = 'all';
        allTab.textContent = 'All';
        tabsContainer.appendChild(allTab);

        // Add category tabs
        Object.entries(this.materialsLibrary.categories).forEach(([categoryId, category]) => {
            const tab = document.createElement('div');
            tab.className = 'category-tab';
            tab.dataset.category = categoryId;
            tab.textContent = category.name;
            tabsContainer.appendChild(tab);
        });
    }

    populateMaterialGrid(filteredMaterials = null) {
        const grid = document.getElementById('material-grid');
        if (!grid || !this.materialsLibrary.materials) return;

        let materials;
        if (filteredMaterials && typeof filteredMaterials === 'string') {
            // Filter by category
            materials = {};
            Object.entries(this.materialsLibrary.materials).forEach(([materialId, material]) => {
                if (material.category === filteredMaterials) {
                    materials[materialId] = material;
                }
            });
        } else {
            materials = filteredMaterials || this.materialsLibrary.materials;
        }
        grid.innerHTML = '';

        Object.entries(materials).forEach(([materialId, material]) => {
            const card = document.createElement('div');
            card.className = 'material-card';
            card.dataset.materialId = materialId;
            
            // Get proper thumbnail and material info
            const thumbnail = material.visual_assets?.thumbnail || 'placeholder-material.jpg';
            const materialName = material.name || 'Unknown Material';
            const scientificName = material.basic_info?.scientific_name || material.species || '';
            const pricePerBF = material.cost_structure?.base_price_bf || 'N/A';
            
            console.log("ðŸ” Material ID:", materialId, "- Name:", materialName);
            console.log("ðŸ” Full material object:", material);
            // Debug logging for thumbnails
            if (material.visual_assets?.thumbnail) {
                console.log(`Material ${materialName} has thumbnail:`, material.visual_assets.thumbnail.substring(0, 50) + '...');
            } else {
                console.log(`Material ${materialName} has no thumbnail, using placeholder`);
            }
            
            card.innerHTML = `
                <div class="material-image">
                    <img src="${thumbnail}" alt="${materialName}" loading="lazy" onerror="this.style.display='none'; console.error('Failed to load material image:', this.src)">
                </div>
                <div class="material-info">
                    <h4>${materialName}</h4>
                    <p class="material-species">${scientificName}</p>
                    <p class="material-price">Starting at $${pricePerBF}/bf</p>
                </div>
            `;
            
            grid.appendChild(card);
        });
    }

    filterMaterials(searchTerm) {
        if (!this.materialsLibrary.materials) return;

        const filtered = {};
        const term = searchTerm.toLowerCase();

        Object.entries(this.materialsLibrary.materials).forEach(([id, material]) => {
            if (material.name.toLowerCase().includes(term) ||
                (material.species && material.species.toLowerCase().includes(term)) ||
                (material.description && material.description.toLowerCase().includes(term))) {
                filtered[id] = material;
            }
        });

        this.populateMaterialGrid(filtered);
    }

    filterByCategory(categoryId) {
        // Update active tab
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelector(`[data-category="${categoryId}"]`).classList.add('active');

        if (categoryId === 'all') {
            this.populateMaterialGrid();
            return;
        }

        if (!this.materialsLibrary.materials) return;

        const filtered = {};
        Object.entries(this.materialsLibrary.materials).forEach(([id, material]) => {
            if (material.category === categoryId) {
                filtered[id] = material;
            }
        });

        this.populateMaterialGrid(filtered);
    }

    selectMaterial(materialId) {
        this.selectedMaterialId = materialId;
        const material = this.materialsLibrary.materials[materialId];
        
        if (!material) return;

        // Show configuration panel
        this.showMaterialConfig(material);
    }

    showMaterialConfig(material) {
        const grid = document.getElementById('material-grid');
        const config = document.getElementById('material-config');
        const materialName = document.getElementById('selected-material-name');

        if (grid) grid.style.display = 'none';
        if (config) config.style.display = 'block';
        if (materialName) materialName.textContent = `${material.name} Configuration`;

        // Populate configuration options
        this.populateConfigOptions(material.id);
        this.updateMaterialCost();
    }

    showMaterialGrid() {
        const grid = document.getElementById('material-grid');
        const config = document.getElementById('material-config');

        if (grid) grid.style.display = 'grid';
        if (config) config.style.display = 'none';
    }

    updateMaterialCost() {
        if (!this.selectedMaterialId) return;

        const material = this.materialsLibrary.materials[this.selectedMaterialId];
        const length = parseFloat(document.getElementById('config-length')?.value || 0);
        const width = parseFloat(document.getElementById('config-width')?.value || 0);
        const thickness = parseFloat(document.getElementById('config-thickness')?.value || 0);
        const grade = document.getElementById('config-grade')?.value || '';

        if (length && width && thickness) {
            // Calculate board feet: (length Ã— width Ã— thickness) / 144
            const boardFeet = (length * width * thickness) / 144;
            const basePriceBF = material.base_price_per_bf || 0;
            
            // Apply grade multiplier if available
            let gradeMultiplier = 1;
            if (material.grade_multipliers && material.grade_multipliers[grade]) {
                gradeMultiplier = material.grade_multipliers[grade];
            }
            
            const totalCost = boardFeet * basePriceBF * gradeMultiplier;

            // Display cost information
            const costDisplay = document.getElementById('cost-display');
            if (costDisplay) {
                costDisplay.innerHTML = `
                    <div class="cost-breakdown">
                        <p><strong>Dimensions:</strong> ${length}" Ã— ${width}" Ã— ${thickness}"</p>
                        <p><strong>Board Feet:</strong> ${boardFeet.toFixed(2)} bf</p>
                        <p><strong>Grade:</strong> ${grade}</p>
                        <p><strong>Price per BF:</strong> $${(basePriceBF * gradeMultiplier).toFixed(2)}</p>
                        <p class="total-cost"><strong>Total Cost: $${totalCost.toFixed(2)}</strong></p>
                    </div>
                `;
            }
        }
    }

    addMaterialToProject() {
        if (!this.selectedMaterialId) return;

        const material = this.materialsLibrary.materials[this.selectedMaterialId];
        const length = document.getElementById('config-length')?.value;
        const width = document.getElementById('config-width')?.value;
        const thickness = document.getElementById('config-thickness')?.value;
        const grade = document.getElementById('config-grade')?.value;

        if (!length || !width || !thickness || !grade) {
            alert('Please select all configuration options');
            return;
        }

        // Create material entry for project
        const materialEntry = {
            id: Date.now(), // Simple ID generation
            materialId: this.selectedMaterialId,
            name: material.name,
            species: material.species,
            length: parseFloat(length),
            width: parseFloat(width),
            thickness: parseFloat(thickness),
            grade: grade,
            boardFeet: (parseFloat(length) * parseFloat(width) * parseFloat(thickness)) / 144,
            cost: this.calculateMaterialCost(material, length, width, thickness, grade),
            dateAdded: new Date().toISOString()
        };

        // Add to project parts list (you may need to implement this method)
        this.addToProjectPartsList(materialEntry);

        // Show success message
        alert(`${material.name} added to project successfully!`);

        // Close modal
        this.closeMaterialModal();
    }

    calculateMaterialCost(material, length, width, thickness, grade) {
        const boardFeet = (parseFloat(length) * parseFloat(width) * parseFloat(thickness)) / 144;
        const basePriceBF = material.base_price_per_bf || 0;
        
        let gradeMultiplier = 1;
        if (material.grade_multipliers && material.grade_multipliers[grade]) {
            gradeMultiplier = material.grade_multipliers[grade];
        }
        
        return boardFeet * basePriceBF * gradeMultiplier;
    }

    addToProjectPartsList(materialEntry) {
        // Initialize project parts list if it doesn't exist
        if (!this.projectPartsList) {
            this.projectPartsList = [];
        }

        // Add material to parts list
        this.projectPartsList.push(materialEntry);

        // Update parts list display
        this.updatePartsListDisplay();

        console.log('Material added to project:', materialEntry);
    }

    updatePartsListDisplay() {
        const partsList = document.getElementById('parts-list');
        if (!partsList || !this.projectPartsList) return;

        partsList.innerHTML = '';

        this.projectPartsList.forEach(part => {
            const listItem = document.createElement('li');
            listItem.className = 'parts-list-item';
            listItem.innerHTML = `
                <div class="part-info">
                    <strong>${part.name}</strong>
                    <span class="part-dimensions">${part.length}" Ã— ${part.width}" Ã— ${part.thickness}"</span>
                    <span class="part-cost">$${part.cost.toFixed(2)}</span>
                </div>
            `;
            partsList.appendChild(listItem);
        });
    }

    setMode(mode) {
        this.currentMode = mode;
        
        // Update UI
        const modeIndicator = document.getElementById('mode-indicator');
        if (modeIndicator) {
            modeIndicator.textContent = mode === 'sketch' ? 'Sketch Mode' : '3D Modeling';
        }
        
        // Update context-sensitive tool groups
        this.updateToolGroups();

    }
    
    updateToolGroups() {
        // Debug logging
        console.log('updateToolGroups called - currentMode:', this.currentMode, 'selectedFace:', this.selectedFace?.name, 'isSketchMode:', this.isSketchMode);
        
        // FORCE OVERRIDE - if mode is sketch but we're not in sketch mode, fix it
        if (this.currentMode === 'sketch' && !this.isSketchMode) {
            this.currentMode = 'model';
            console.log('Mode corrected to model');
        }
        
        
        // Hide all tool groups first
        const allGroups = [
            'sketch-tools',
            'model-tools-main', 
            'model-tools-face',
            'model-tools-object'
        ];
        
        allGroups.forEach(groupId => {
            const group = document.getElementById(groupId);
            if (group) {
                group.style.display = 'none';
            }
        });
        
        // Show appropriate group based on mode and selection state
        if (this.currentMode === 'sketch') {
            // In sketch mode, always show drawing tools
            const sketchTools = document.getElementById('sketch-tools');
            if (sketchTools) {
                sketchTools.style.display = 'block';
            }
        } else {
            // In model mode, always show main tools
            const mainTools = document.getElementById('model-tools-main');
            if (mainTools) {
                mainTools.style.display = 'block';
            }
            
            // Additionally show context tools based on selection
            if (this.selectedFace) {
                // Face selected - show selection info
                console.log('Showing face info for selected face:', this.selectedFace.name);
                const faceTools = document.getElementById('model-tools-face');
                if (faceTools) {
                    faceTools.style.display = 'block';
                    // Update the info text
                    const faceInfo = document.getElementById('face-selection-info');
                    if (faceInfo) {
                        faceInfo.textContent = `${this.selectedFace.name} selected - Use active tool`;
                    }
                }
            } else if (this.selectedObject) {
                // 3D object selected - show transform tools
                const objectTools = document.getElementById('model-tools-object');
                if (objectTools) {
                    objectTools.style.display = 'block';
                }
            }
        }
    }

    resetView() {
        this.camera.setTarget(BABYLON.Vector3.Zero());
        this.camera.alpha = -Math.PI / 2;
        this.camera.beta = Math.PI / 2.5;
        this.camera.radius = Math.max(200, this.camera.radius); // Ensure minimum radius
        console.log('resetView: Set camera radius to', this.camera.radius);
    }

    switchBench(benchType) {
        // Update current bench property
        this.currentBench = benchType;
        
        // Update bench button states
        document.querySelectorAll('.bench-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        if (benchType === 'work') {
            document.getElementById('work-bench-btn').classList.add('active');
            // Show work bench tools, hide assembly bench tools
            document.getElementById('work-bench-tools').style.display = 'block';
            document.getElementById('assembly-bench-tools').style.display = 'none';
        } else if (benchType === 'assembly') {
            document.getElementById('assembly-bench-btn').classList.add('active');
            // Show assembly bench tools, hide work bench tools
            document.getElementById('work-bench-tools').style.display = 'none';
            document.getElementById('assembly-bench-tools').style.display = 'block';
        }
        
        // Clear any active tool selections when switching benches
        document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
        this.activeTool = null;
        
        // DRAMATIC BENCH REVEAL: Animate camera to showcase the bench contents
        this.animateCameraToShowcaseBench(benchType);
        
        console.log(`Switched to ${benchType} bench`);
    }

    /**
     * DRAMATIC BENCH REVEAL: Professional camera animation to showcase bench contents
     * Automatically frames all parts optimally with cinematic camera movement
     */
    animateCameraToShowcaseBench(benchType) {
        console.log(`Starting dramatic bench reveal animation for ${benchType} bench`);
        
        // Get all parts on the current bench
        const parts = benchType === 'work' ? 
            this.scene.meshes.filter(m => m.isWorkBenchPart) : 
            this.scene.meshes.filter(m => m.isProjectPart);
        
        if (parts.length === 0) {
            console.log(`No parts to showcase on ${benchType} bench`);
            // Still animate to origin for clean empty bench view
            this.animateCameraToPosition(new BABYLON.Vector3(0, 50, 100), BABYLON.Vector3.Zero());
            return;
        }
        
        // Calculate bounding box of all parts
        const partPositions = parts.map(part => part.position);
        const bounds = this.calculateSceneBounds(partPositions, parts);
        
        // Calculate optimal camera position for dramatic showcase
        const centerPoint = bounds.center;
        const sceneSize = bounds.size;
        const maxDimension = Math.max(sceneSize.x, sceneSize.y, sceneSize.z);
        
        // Professional camera positioning for multiple parts
        const cameraDistance = maxDimension * 2.2; // Extra distance for multiple parts
        const cameraHeight = maxDimension * 0.6;   // Elevated perspective
        
        // Create cinematic camera angle
        const targetCameraPosition = new BABYLON.Vector3(
            centerPoint.x + cameraDistance * 0.8,
            centerPoint.y + cameraHeight,
            centerPoint.z + cameraDistance * 0.6
        );
        
        // Animate to showcase position
        this.animateCameraToPosition(targetCameraPosition, centerPoint);
        
        console.log(`Showcasing ${parts.length} parts on ${benchType} bench`);
    }
    
    /**
     * Calculate bounding box for multiple parts
     */
    calculateSceneBounds(positions, parts) {
        if (positions.length === 0) {
            return { center: BABYLON.Vector3.Zero(), size: new BABYLON.Vector3(10, 10, 10) };
        }
        
        // Find min/max across all parts
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        
        parts.forEach(part => {
            const bounds = part.getBoundingInfo();
            const worldMin = part.position.add(bounds.minimum);
            const worldMax = part.position.add(bounds.maximum);
            
            minX = Math.min(minX, worldMin.x);
            maxX = Math.max(maxX, worldMax.x);
            minY = Math.min(minY, worldMin.y);
            maxY = Math.max(maxY, worldMax.y);
            minZ = Math.min(minZ, worldMin.z);
            maxZ = Math.max(maxZ, worldMax.z);
        });
        
        const center = new BABYLON.Vector3(
            (minX + maxX) / 2,
            (minY + maxY) / 2,
            (minZ + maxZ) / 2
        );
        
        const size = new BABYLON.Vector3(
            maxX - minX,
            maxY - minY,
            maxZ - minZ
        );
        
        return { center, size };
    }
    
    /**
     * Smooth camera animation to specific position and target
     */
    animateCameraToPosition(targetPosition, targetLookAt) {
        // Store current camera state
        const startPosition = this.camera.position.clone();
        const startTarget = this.camera.getTarget().clone();
        
        // Crisp 2-second cutscene animation
        const animationDuration = 2000; // 2 seconds in milliseconds
        const startTime = Date.now();
        
        // Professional ease-in-out cubic (slow-fast-slow)
        const easeInOutCubic = (t) => {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        };
        
        // Immediate camera position set to prevent flash
        this.camera.position = startPosition;
        this.camera.setTarget(startTarget);
        
        // Smooth camera animation
        const animateCamera = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            const easedProgress = easeInOutCubic(progress);
            
            // Interpolate camera position
            this.camera.position = BABYLON.Vector3.Lerp(startPosition, targetPosition, easedProgress);
            
            // Smooth target transition - always end centered
            const currentTarget = BABYLON.Vector3.Lerp(startTarget, targetLookAt, easedProgress);
            this.camera.setTarget(currentTarget);
            
            // Continue animation
            if (progress < 1) {
                requestAnimationFrame(animateCamera);
            } else {
                console.log(`Camera cutscene complete`);
            }
        };
        
        // Start the animation
        requestAnimationFrame(animateCamera);
    }

    updateCoordinates(event) {
        // Get canvas-relative coordinates
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Get 3D coordinates from mouse position
        const pickInfo = this.scene.pick(x, y);
        if (pickInfo.hit) {
            const pos = pickInfo.pickedPoint;
            document.getElementById('coordinates').textContent = 
                `X: ${pos.x.toFixed(2)}, Y: ${pos.y.toFixed(2)}, Z: ${pos.z.toFixed(2)}`;
        }
    }
    
    updateSketchPreviewWithPoint(point) {
        // Use the point directly since it's already on the sketch plane
        const sketchPoint = point.clone();
        



        
        // Update preview based on current tool
        switch (this.currentSketch.currentTool) {
            case 'line':
                if (this.linePreview) {
                    this.createLinePreview(this.currentSketch.startPoint, sketchPoint);
                }
                break;
            case 'rectangle':

                this.createRectanglePreview(this.currentSketch.startPoint, sketchPoint);
                break;
            case 'circle':
                const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, sketchPoint);
                this.createCirclePreview(this.currentSketch.startPoint, radius);
                break;
            case 'ellipse':
                const ellipseOffset = sketchPoint.subtract(this.currentSketch.startPoint);
                this.createEllipsePreview(
                    this.currentSketch.startPoint,
                    Math.abs(BABYLON.Vector3.Dot(ellipseOffset, this.sketchRight)),
                    Math.abs(BABYLON.Vector3.Dot(ellipseOffset, this.sketchUp))
                );
                break;
            case 'triangle':
                if (this.currentSketch.trianglePoints && this.currentSketch.trianglePoints.length > 0) {
                    this.createTrianglePreview([...this.currentSketch.trianglePoints, sketchPoint]);
                }
                break;
        }
    }
    
    updateSketchPreview(event) {
        // Legacy function - redirect to new implementation
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
        if (pickInfo.hit) {
            this.updateSketchPreviewWithPoint(pickInfo.pickedPoint);
        }
    }
    
    cancelCurrentDrawing() {
        // Clean up any preview shapes
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        // Reset drawing state
        this.currentSketch.isDrawing = false;
        this.currentSketch.startPoint = null;
        this.currentSketch.trianglePoints = [];
        

    }
    
    // ==================== SELECTION AND EXTRUSION SYSTEM ====================
    
    setupSelectionSystem() {
        // Initialize selection state
        this.selectedFace = null;
        this.hoveredFace = null;
        this.selectionOutlineMaterial = null;
        this.hoverOutlineMaterial = null;
        this.isExtruding = false;
        
        // Create outline materials
        this.createOutlineMaterials();
        
        // Setup selection event handlers
        this.setupSelectionEventHandlers();
        

    }
    
    createOutlineMaterials() {
        // Create hover material (pale green face)
        this.hoverOutlineMaterial = new BABYLON.StandardMaterial('hoverOutline', this.scene);
        this.hoverOutlineMaterial.diffuseColor = new BABYLON.Color3(0.8, 1.0, 0.8); // Pale green
        this.hoverOutlineMaterial.emissiveColor = new BABYLON.Color3(0.8, 1.0, 0.8);
        this.hoverOutlineMaterial.wireframe = false; // Solid face
        this.hoverOutlineMaterial.alpha = 0.7;
        this.hoverOutlineMaterial.backFaceCulling = false;
        
        // Create selection outline material (orange)
        this.selectionOutlineMaterial = new BABYLON.StandardMaterial('selectionOutline', this.scene);
        this.selectionOutlineMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0); // Orange
        this.selectionOutlineMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.15, 0);
        this.selectionOutlineMaterial.wireframe = true;
        this.selectionOutlineMaterial.alpha = 1.0;
    }
    
    setupSelectionEventHandlers() {
        // Mouse move for hover detection
        this.scene.onPointerObservable.add((pointerInfo) => {
            // Handle surface selection for sketch tool (highest priority)
            if (this.waitingForSurface && pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) {
                this.handleSurfaceSelection(pointerInfo);
                return;
            }
            
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) {
                if (this.isSketchMode || this.isExtruding) {
                    return;
                }
                this.handleFaceSelection(pointerInfo);
            } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 2) {
                // Right-click for context menu
                if (this.isSketchMode || this.isExtruding) {
                    return;
                }
                this.handleRightClickContextMenu(pointerInfo);
            } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
                if (!this.isSketchMode && !this.isExtruding) {
                    this.handleFaceHover(pointerInfo);
                }
            }
        });
    }
    
    handleSurfaceSelection(pointerInfo) {
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => {
                // Accept any pickable mesh that could be a surface (completely generic approach)
                const isSketchable = this.isMeshSketchable(mesh);
                return isSketchable;
            }
        );
        
        
        if (pickInfo.hit && pickInfo.pickedMesh) {
            this.enterSketchModeOnSurface(pickInfo.pickedMesh, pickInfo.pickedPoint, pickInfo.getNormal());
        } else {
        }
    }
    
    clearHover() {
        if (this.hoveredFace) {
            this.setFaceHover(this.hoveredFace, false);
            this.hoveredFace = null;
        }
    }
    
        handleFaceHover(pointerInfo) {
        // Check if cut tool is active - skip hover effects
        if (this.cutToolSystem && this.cutToolSystem.cutPreviewActive) {
            return;
        }
        
        // Allow hover handling even when something is selected
        // This lets users see other selectable shapes
        
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => this.isSelectableFace(mesh)
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh) {
            const face = pickInfo.pickedMesh;
            
            // If hovering over a new face
            if (this.hoveredFace !== face) {
                // Clear previous hover
                this.clearHover();
                
                // Set new hover
                this.hoveredFace = face;
                this.setFaceHover(face, true);
            }
        } else {
            // Clear hover if not over any face
            this.clearHover();
        }
    }
    
    handleFaceSelection(pointerInfo) {
        // Check if cut tool is active - delegate to cut system
        if (this.cutToolSystem && this.cutToolSystem.cutPreviewActive) {
            // Let the cut tool system handle this interaction
            return;
        }
        
        // First check what we're hitting without filter
        const anyPick = this.scene.pick(this.scene.pointerX, this.scene.pointerY);
        
        // Check for parts with partData first (higher priority)
        const partPickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => mesh && mesh.partData
        );
        
        if (partPickInfo.hit && partPickInfo.pickedMesh && partPickInfo.pickedMesh.partData) {
            const partMesh = partPickInfo.pickedMesh;
            const part = partMesh.partData;
            
            // Toggle part selection
            if (this.selectedPart === part) {
                // Don't deselect if drill press tool is active
                if (this.activeTool !== 'drill') {
                    console.log("Same part clicked, keeping selection");
                }
            } else {
                this.selectPart(part);
            }
            return; // Exit early to prevent face selection
        }
        
        // If no part was clicked, check for selectable faces
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => this.isSelectableFace(mesh)
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh) {
            const face = pickInfo.pickedMesh;
            
            // Toggle selection only if clicking the same face
            if (this.selectedFace === face) {
                this.deselectFace();
            } else {
                // Select new face (this will auto-deselect the previous one)
                this.selectFace(face);
            }
        } else {
            // Don't deselect when clicking empty space - allows rotation/manipulation
            // Only deselect on explicit same-face click or different face selection
        }
    }
    
    handleRightClickContextMenu(pointerInfo) {
        // Prevent browser context menu
        pointerInfo.event.preventDefault();
        pointerInfo.event.stopPropagation();
        
        // Pick what's under the mouse
        const pickInfo = this.scene.pick(
            this.scene.pointerX, 
            this.scene.pointerY, 
            (mesh) => {
                // Check if it's a workbench part or project part
                return mesh.isWorkBenchPart || mesh.isProjectPart;
            }
        );
        
        if (pickInfo.hit && pickInfo.pickedMesh && pickInfo.pickedMesh.partData) {
            const mesh = pickInfo.pickedMesh;
            const part = mesh.partData;
            
            // Select the part if not already selected
            if (this.selectedPart !== part) {
                this.selectPart(part);
            }
            
            // Get mouse position for context menu
            const canvas = this.scene.getEngine().getRenderingCanvas();
            const rect = canvas.getBoundingClientRect();
            const x = pointerInfo.event.clientX;
            const y = pointerInfo.event.clientY;
            
            // Show context menu using the workspace ContextMenuSystem
            if (window.ContextMenuSystem) {
                window.ContextMenuSystem.showContextMenu(x, y, part);
            }
            
            console.log('Right-clicked on part:', part.materialName);
        }
    }
    
    isSelectableFace(mesh) {
        if (!mesh || !mesh.name) return false;
        
        
        // Check if it's one of our closed shapes (check both mesh and parent)
        for (const shape of this.closedShapes) {
            if (shape.mesh === mesh || shape.mesh === mesh.parent) {
                return true;
            }
        }
        
        // Also check current sketch elements if we just finished drawing
        if (this.currentSketch && this.currentSketch.elements) {
            for (const element of this.currentSketch.elements) {
                if (element.closed && (element.mesh === mesh || element.mesh === mesh.parent)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    performExtrusion(isPositive) {
        console.log('startExtrusion called with isPositive:', isPositive);
        if (!this.selectedFace) {
            console.log('No selected face for extrusion');
            return;
        }
        
        console.log('Looking for shape data for face:', this.selectedFace.name);
        
        // Find the shape data for the selected face
        let shapeData = null;
        
        // Check closedShapes first
        console.log('Checking closedShapes:', this.closedShapes.length, 'shapes');
        for (const shape of this.closedShapes) {
            console.log('Checking shape:', shape.type, 'mesh:', shape.mesh?.name);
            if (shape.mesh === this.selectedFace || shape.mesh === this.selectedFace.parent) {
                shapeData = shape;
                console.log('Found matching shape in closedShapes:', shape.type);
                break;
            }
        }
        
        // Check current sketch elements if not found
        if (!shapeData && this.currentSketch && this.currentSketch.elements) {
            console.log('Checking current sketch elements:', this.currentSketch.elements.length, 'elements');
            for (const element of this.currentSketch.elements) {
                console.log('Checking element:', element.type, 'mesh:', element.mesh?.name);
                if (element.closed && (element.mesh === this.selectedFace || element.mesh === this.selectedFace.parent)) {
                    shapeData = element;
                    console.log('Found matching element in sketch:', element.type);
                    break;
                }
            }
        }
        
        if (shapeData) {
            // Default extrusion height
            const height = 5; // 5cm extrusion
            
            // Perform the extrusion based on shape type
            console.log('About to extrude shape type:', shapeData.type, 'height:', height, 'isPositive:', isPositive);
            switch (shapeData.type) {
                case 'rectangle':
                    console.log('Calling extrudeRectangle');
                    this.extrudeRectangle(shapeData, height, isPositive);
                    break;
                case 'circle':
                    console.log('Calling extrudeCircle');
                    this.extrudeCircle(shapeData, height, isPositive);
                    break;
                case 'ellipse':
                    console.log('Calling extrudeEllipse');
                    this.extrudeEllipse(shapeData, height, isPositive);
                    break;
                case 'triangle':
                    console.log('Calling extrudeTriangle');
                    this.extrudeTriangle(shapeData, height, isPositive);
                    break;
            }
            console.log('Extrusion method completed');
            
            // Deselect the face after extrusion
            this.deselectFace();
        }
    }
    
    selectFace(face) {
        console.log('selectFace called for:', face.name);
        
        // Clear previous selection only if different face
        if (this.selectedFace && this.selectedFace !== face) {
            this.deselectFace();
        }
        
        // Set new selection
        this.selectedFace = face;
        this.setFaceSelection(face, true);
        
        // Clear hover since we've selected
        this.clearHover();
        
        // Update UI - this should show the extrusion buttons
        this.updateSelectionUI();
        this.updateToolGroups();
        
        // Check if extrude tool is active and auto-start extrusion
        if (this.activeTool === 'extrude') {
            console.log('Extrude tool is active, starting extrusion for selected face:', this.selectedFace?.name);
            this.startBidirectionalExtrusion();
        }
        
        console.log('Face selection complete, selectedFace:', this.selectedFace?.name);
    }
    
    deselectFace() {
        if (this.selectedFace) {
            console.log('deselectFace called for:', this.selectedFace.name);
            console.trace('Deselection stack trace');
            
            // Clean up any active extrusion
            if (this.isInteractiveExtruding) {
                console.log('Cleaning up active extrusion during deselection');
                this.cleanupInteractiveExtrusion();
            }
            
            this.setFaceSelection(this.selectedFace, false);
            this.selectedFace = null;
            this.disableExtrusionMode();
            this.updateSelectionUI();
            this.updateToolGroups();

        }
    }
    
    selectPart(part) {
        console.log('Selecting part:', part);
        
        // If clicking same part, just keep it selected (dont toggle)
        if (this.selectedPart === part) {
            console.log('Same part clicked, keeping selection');
            return; // Keep the part selected
        }
        
        // Deselect current part if different
        if (this.selectedPart && this.selectedPart !== part) {
            this.deselectPart();
        }
        
        // Select new part
        this.selectedPart = part;
        
        // Find the mesh for this part
        const mesh = this.scene.meshes.find(m => m.partData === part);
        console.log('SELECT DEBUG: Looking for mesh with partData === part');
        console.log('SELECT DEBUG: part:', part);
        console.log('SELECT DEBUG: found mesh:', mesh);
        console.log('SELECT DEBUG: mesh.name:', mesh?.name);
        console.log('SELECT DEBUG: mesh.id:', mesh?.id);
        console.log('SELECT DEBUG: mesh.dimensions:', mesh?.dimensions);
        console.log('SELECT DEBUG: mesh.partData:', mesh?.partData);
        console.log('SELECT DEBUG: mesh.partData?.dimensions:', mesh?.partData?.dimensions);
        
        if (mesh) {
            this.setPartSelection(mesh, true);
            
            // Only create manipulation UI if Move tool is explicitly active
            if (this.activeTool === 'move') {
                this.createManipulationButtons(mesh);
                this.createDragHandles(mesh);
            }
        }
        
        // Update UI
        this.updatePartSelectionUI();
        
        // Deselect any face selection
        if (this.selectedFace) {
            this.deselectFace();
        }
    }

    deselectPart() {
        if (!this.selectedPart) return;
        
        console.log('Deselecting part:', this.selectedPart);
        
        // Find the mesh for this part
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (mesh) {
            this.setPartSelection(mesh, false);
        }
        
        // Clear manipulation UI
        this.clearManipulationButtons();
        this.clearDragHandles();
        
        // Clear selection
        this.selectedPart = null;
        
        // Update UI
        this.updatePartSelectionUI();
    }

    setPartSelection(mesh, isSelected) {
        // DEBUG: Track position before/after selection
        const positionBefore = mesh.position.clone();
        console.log(`MESH POSITION BEFORE selection (${isSelected}):`, positionBefore);
        
        if (isSelected) {
            // Store original material
            mesh.originalMaterial = mesh.material;
            
            // Apply selection material (yellow outline)
            if (!this.selectionMaterial) {
                this.selectionMaterial = new BABYLON.StandardMaterial('selectionMaterial', this.scene);
                this.selectionMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0); // Yellow
                this.selectionMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);
                this.selectionMaterial.wireframe = false;
                this.selectionMaterial.alpha = 0.8;
            }
            
            // Create outline effect
            mesh.enableEdgesRendering();
            mesh.edgesWidth = 4.0;
            mesh.edgesColor = new BABYLON.Color4(1, 1, 0, 1); // Yellow outline
            
        } else {
            // Restore original material
            if (mesh.originalMaterial) {
                mesh.material = mesh.originalMaterial;
                mesh.originalMaterial = null;
            }
            
            // Remove outline
            mesh.disableEdgesRendering();
        }
        
        // DEBUG: Track position after selection
        const positionAfter = mesh.position.clone();
        console.log(`MESH POSITION AFTER selection (${isSelected}):`, positionAfter);
        
        // DEBUG: Check if position changed
        const positionDelta = positionAfter.subtract(positionBefore);
        if (positionDelta.length() > 0.001) {
            console.error(`âŒ MESH POSITION CHANGED during selection! Delta:`, positionDelta);
        }
    }

    updatePartSelectionUI() {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            if (this.selectedPart) {
                selectionInfo.innerHTML = `
                    <strong>Selected Part:</strong><br>
                    ${this.selectedPart.materialName}<br>
                    ${this.selectedPart.dimensions.length}" Ã— ${this.selectedPart.dimensions.width}" Ã— ${this.selectedPart.dimensions.thickness}"<br>
                    <em>Use manipulation buttons to move</em>
                `;
            } else {
                selectionInfo.textContent = 'Nothing selected';
            }
        }
        
        // Show/hide bench transfer buttons based on selection and current bench
        if (this.selectedPart) {
            const selectedMesh = this.scene.meshes.find(mesh => 
                mesh.partData && mesh.partData.id === this.selectedPart.id
            );
            
            if (this.currentBench === 'work' && selectedMesh && selectedMesh.isWorkBenchPart) {
                // On Work Bench with work bench part selected - show "To Assembly"
                this.showIncludeInProjectButton();
                this.hideBackToWorkBenchButton();
            } else if (this.currentBench === 'assembly' && selectedMesh && selectedMesh.isProjectPart) {
                // On Assembly Bench with assembly part selected - show "To Work Bench"
                this.hideIncludeInProjectButton();
                this.showBackToWorkBenchButton();
            } else {
                // No valid selection for current bench
                this.hideIncludeInProjectButton();
                this.hideBackToWorkBenchButton();
            }
        } else {
            // Nothing selected
            this.hideIncludeInProjectButton();
            this.hideBackToWorkBenchButton();
        }
        
        // Update project explorer selection
        this.updateProjectExplorerSelection();
    }

    updateProjectExplorerSelection() {
        // Clear all active states
        document.querySelectorAll('.part-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Highlight selected part
        if (this.selectedPart) {
            const partId = this.selectedPart.id;
            const partItem = document.querySelector(`[data-part-id="${partId}"]`);
            if (partItem) {
                partItem.classList.add('active');
            }
        }
    }

    createManipulationButtons(mesh) {
        // Clear existing buttons
        this.clearManipulationButtons();
        
        try {
            // Use properties panel instead of popup
            this.showManipulationInPropertiesPanel(mesh);
            console.log('Created manipulation buttons in properties panel');
        } catch (error) {
            console.error('Error creating manipulation buttons:', error);
            // Fallback: Show manipulation info in selection panel
            this.showManipulationInstructions();
        }
    }

    showManipulationInPropertiesPanel(mesh) {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            // Show part info if mesh has part data, otherwise show general manipulation
            const partInfo = mesh && mesh.partData ? `
                <strong>Selected Part:</strong><br>
                ${mesh.partData.materialName}<br>
                ${mesh.partData.dimensions.length}" Ã— ${mesh.partData.dimensions.width}" Ã— ${mesh.partData.dimensions.thickness}"<br>
                <br>
            ` : `<strong>Move Tool Active</strong><br>Select a part to manipulate<br><br>`;

            selectionInfo.innerHTML = `
                ${partInfo}
                <div style="background: rgba(52, 152, 219, 0.1); padding: 10px; border-radius: 5px; margin-top: 10px;">
                    <strong>Object Manipulation:</strong><br>
                    
                    <div style="margin: 8px 0;">
                        <strong>Spin on Table:</strong><br>
                        <button onclick="window.drawingWorld.rotatePart(90, 'Y')" class="manip-btn" title="Rotate 90Â° clockwise">â†» 90Â°</button>
                        <button onclick="window.drawingWorld.rotatePart(-90, 'Y')" class="manip-btn" title="Rotate 90Â° counter-clockwise">â†º 90Â°</button>
                        <button onclick="window.drawingWorld.rotatePart(45, 'Y')" class="manip-btn" title="Rotate 45Â° clockwise">â†» 45Â°</button>
                        <button onclick="window.drawingWorld.rotatePart(-45, 'Y')" class="manip-btn" title="Rotate 45Â° counter-clockwise">â†º 45Â°</button>
                    </div>
                    
                    <div style="margin: 8px 0;">
                        <strong>Position & Orientation:</strong><br>
                        <button onclick="window.drawingWorld.flattenBoard()" class="manip-btn" title="Lay flat on table">Flat</button>
                        <button onclick="window.drawingWorld.dropPart()" class="manip-btn" title="Drop part flat onto surface">Drop</button>
                        <button onclick="window.drawingWorld.standOnEndEdge()" class="manip-btn" title="Stand on width edge">Width Edge Up</button>
                        <button onclick="window.drawingWorld.standOnSideEdge()" class="manip-btn" title="Stand on length edge">Length Edge Up</button>
                    </div>
                    
                    <div style="margin: 8px 0;">
                        <strong>Tip & Roll:</strong><br>
                        <button onclick="window.drawingWorld.rotatePart(90, 'X')" class="manip-btn" title="Tip away 90Â°">â¤´ 90Â°</button>
                        <button onclick="window.drawingWorld.rotatePart(-90, 'X')" class="manip-btn" title="Tip toward 90Â°">â¤µ 90Â°</button>
                        <button onclick="window.drawingWorld.rotatePart(90, 'Z')" class="manip-btn" title="Roll right 90Â°">â­® 90Â°</button>
                        <button onclick="window.drawingWorld.rotatePart(-90, 'Z')" class="manip-btn" title="Roll left 90Â°">â­¯ 90Â°</button>
                    </div>
                    
                    <div style="margin: 8px 0;">
                        <strong>Flip Operations:</strong><br>
                        <button onclick="window.drawingWorld.flipPart('X')" class="manip-btn" title="Flip front-to-back">Flip Fâ†”B</button>
                        <button onclick="window.drawingWorld.flipPart('Y')" class="manip-btn" title="Flip left-to-right">Flip Lâ†”R</button>
                        <button onclick="window.drawingWorld.flipPart('Z')" class="manip-btn" title="Flip top-to-bottom">Flip Tâ†”B</button>
                    </div>
                </div>
            `;
        }
    }

    // Old popup-based manipulation buttons method
    createManipulationButtonsPopup(mesh) {
        // Clear existing buttons
        this.clearManipulationButtons();
        
        try {
            // Create GUI container
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ManipulationUI");
            this.manipulationGUI = advancedTexture;
            
            // Create main container with border
            const mainContainer = new BABYLON.GUI.Rectangle();
            mainContainer.widthInPixels = 400;
            mainContainer.heightInPixels = 280;
            mainContainer.cornerRadius = 12;
            mainContainer.color = "#3498db";
            mainContainer.thickness = 3;
            mainContainer.background = "rgba(44, 62, 80, 0.95)";
            
            // Create title
            const title = new BABYLON.GUI.TextBlock();
            title.text = "Object Manipulator";
            title.color = "white";
            title.fontSize = 16;
            title.fontWeight = "bold";
            title.heightInPixels = 30;
            title.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            title.topInPixels = 10;
            
            // Create button container
            const buttonPanel = new BABYLON.GUI.StackPanel();
            buttonPanel.widthInPixels = 380;
            buttonPanel.heightInPixels = 240;
            buttonPanel.paddingTopInPixels = 40;
            buttonPanel.paddingBottomInPixels = 10;
            
            // Position main container in top right area
            mainContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            mainContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            mainContainer.leftInPixels = -20;
            mainContainer.topInPixels = 80;
            
            // Rotation buttons row 1 - Y axis (around vertical - like spinning on table)
            const rotationRow1 = new BABYLON.GUI.StackPanel();
            rotationRow1.isVertical = false;
            rotationRow1.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Right 90Â°", () => this.rotatePart(90, 'Y'), "Rotate board clockwise when viewed from above");
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Left 90Â°", () => this.rotatePart(-90, 'Y'), "Rotate board counter-clockwise when viewed from above");
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Right 45Â°", () => this.rotatePart(45, 'Y'), "Rotate board 45Â° clockwise when viewed from above");
            this.createManipulationButtonWithPreview(rotationRow1, "Spin Left 45Â°", () => this.rotatePart(-45, 'Y'), "Rotate board 45Â° counter-clockwise when viewed from above");
            
            // Rotation buttons row 2 - X axis (tip up/down - like standing board on edge)
            const rotationRow2 = new BABYLON.GUI.StackPanel();
            rotationRow2.isVertical = false;
            rotationRow2.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(rotationRow2, "Tip Away 90Â°", () => this.rotatePart(90, 'X'), "Tip the far end of board upward 90Â°");
            this.createManipulationButtonWithPreview(rotationRow2, "Tip Toward 90Â°", () => this.rotatePart(-90, 'X'), "Tip the near end of board upward 90Â°");
            this.createManipulationButtonWithPreview(rotationRow2, "Lay Flat", () => this.flattenBoard(), "Board lies flat - thickness (3/4\") on top/bottom");
            this.createManipulationButtonWithPreview(rotationRow2, "Drop", () => this.dropPart(), "Drop part flat onto surface directly below");
            this.createManipulationButtonWithPreview(rotationRow2, "Width Edge Up", () => this.standOnEndEdge(), "Board stands on width edge - thickness (3/4\") shows as width");
            
            // Rotation buttons row 3 - Z axis (side edge)
            const rotationRow3 = new BABYLON.GUI.StackPanel();
            rotationRow3.isVertical = false;
            rotationRow3.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(rotationRow3, "Length Edge Up", () => this.standOnSideEdge(), "Board stands on length edge - thickness (3/4\") shows as height");
            this.createManipulationButtonWithPreview(rotationRow3, "Roll Right 90Â°", () => this.rotatePart(90, 'Z'), "Roll board to the right 90Â°");
            this.createManipulationButtonWithPreview(rotationRow3, "Roll Left 90Â°", () => this.rotatePart(-90, 'Z'), "Roll board to the left 90Â°");
            
            // Flip buttons row 2
            const flipRow = new BABYLON.GUI.StackPanel();
            flipRow.isVertical = false;
            flipRow.heightInPixels = 40;
            
            this.createManipulationButtonWithPreview(flipRow, "Flip Front-to-Back", () => this.flipPart('X'), "Flip board end-over-end (front becomes back)");
            this.createManipulationButtonWithPreview(flipRow, "Flip Left-to-Right", () => this.flipPart('Y'), "Flip board side-to-side (left becomes right)");
            this.createManipulationButtonWithPreview(flipRow, "Flip Top-to-Bottom", () => this.flipPart('Z'), "Flip board upside-down (top becomes bottom)");
            
            // Add precision sliders row
            const sliderRow = new BABYLON.GUI.StackPanel();
            sliderRow.isVertical = false;
            sliderRow.heightInPixels = 40;
            
            this.createPrecisionSliders(sliderRow);
            
            // Add rows to panel
            buttonPanel.addControl(rotationRow1);
            buttonPanel.addControl(rotationRow2);
            buttonPanel.addControl(rotationRow3);
            buttonPanel.addControl(flipRow);
            buttonPanel.addControl(sliderRow);
            
            // Add title and panel to main container
            mainContainer.addControl(title);
            mainContainer.addControl(buttonPanel);
            
            // Add to GUI
            advancedTexture.addControl(mainContainer);
            
            console.log('Created manipulation buttons for part');
        } catch (error) {
            console.error('Error creating manipulation buttons:', error);
            // Fallback: Show manipulation info in selection panel
            this.showManipulationInstructions();
        }
    }

    showManipulationInstructions() {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo && this.selectedPart) {
            selectionInfo.innerHTML = `
                <strong>Selected Part:</strong><br>
                ${this.selectedPart.materialName}<br>
                ${this.selectedPart.dimensions.length}" Ã— ${this.selectedPart.dimensions.width}" Ã— ${this.selectedPart.dimensions.thickness}"<br>
                <br>
                <strong>Spin on Table:</strong><br>
                <button onclick="window.drawingWorld.rotatePart(90, 'Y')" class="manip-btn">â†» 90Â°</button>
                <button onclick="window.drawingWorld.rotatePart(-90, 'Y')" class="manip-btn">â†º 90Â°</button><br>
                <strong>Tip Up/Down:</strong><br>
                <button onclick="window.drawingWorld.flattenBoard()" class="manip-btn">Flat</button>
                <button onclick="window.drawingWorld.standOnEdge()" class="manip-btn">Edge</button><br>
                <button onclick="window.drawingWorld.rotatePart(90, 'X')" class="manip-btn">â¤´ 90Â°</button>
                <button onclick="window.drawingWorld.rotatePart(-90, 'X')" class="manip-btn">â¤µ 90Â°</button>
            `;
        }
    }

    createManipulationButton(parent, text, onClick) {
        const button = BABYLON.GUI.Button.CreateSimpleButton(null, text);
        button.widthInPixels = 65;
        button.heightInPixels = 30;
        button.color = "white";
        button.background = "#3498db";
        button.cornerRadius = 4;
        button.fontSize = 12;
        button.paddingLeftInPixels = 5;
        button.paddingRightInPixels = 5;
        
        button.onPointerUpObservable.add(onClick);
        
        // Hover effects
        button.onPointerEnterObservable.add(() => {
            button.background = "#2980b9";
        });
        
        button.onPointerOutObservable.add(() => {
            button.background = "#3498db";
        });
        
        parent.addControl(button);
        return button;
    }

    createManipulationButtonWithPreview(parent, text, onClick, description) {
        const button = BABYLON.GUI.Button.CreateSimpleButton(null, text);
        button.widthInPixels = 75;
        button.heightInPixels = 30;
        button.color = "white";
        button.background = "#3498db";
        button.cornerRadius = 4;
        button.fontSize = 10;
        button.paddingLeftInPixels = 2;
        button.paddingRightInPixels = 2;
        
        button.onPointerUpObservable.add(onClick);
        
        // Create tooltip that appears on hover
        let tooltipContainer = null;
        
        // Hover effects with tooltip
        button.onPointerEnterObservable.add(() => {
            button.background = "#2980b9";
            
            // Create tooltip
            if (!tooltipContainer) {
                tooltipContainer = new BABYLON.GUI.Rectangle();
                tooltipContainer.widthInPixels = 200;
                tooltipContainer.heightInPixels = 40;
                tooltipContainer.cornerRadius = 5;
                tooltipContainer.color = "#2c3e50";
                tooltipContainer.thickness = 2;
                tooltipContainer.background = "rgba(44, 62, 80, 0.95)";
                
                const tooltipText = new BABYLON.GUI.TextBlock();
                tooltipText.text = description;
                tooltipText.color = "white";
                tooltipText.fontSize = 11;
                tooltipText.textWrapping = true;
                tooltipText.resizeToFit = true;
                
                tooltipContainer.addControl(tooltipText);
                
                // Position tooltip above the button
                tooltipContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                tooltipContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                tooltipContainer.topInPixels = -50;
                
                this.manipulationGUI.addControl(tooltipContainer);
            }
        });
        
        button.onPointerOutObservable.add(() => {
            button.background = "#3498db";
            
            // Remove tooltip
            if (tooltipContainer) {
                this.manipulationGUI.removeControl(tooltipContainer);
                tooltipContainer.dispose();
                tooltipContainer = null;
            }
        });
        
        parent.addControl(button);
        return button;
    }

    clearManipulationButtons() {
        if (this.manipulationGUI) {
            this.manipulationGUI.dispose();
            this.manipulationGUI = null;
        }
        // Also clear properties panel if it contains manipulation buttons
        this.clearPropertiesPanel();
    }

    clearPropertiesPanel() {
        const selectionInfo = document.getElementById('selection-info');
        if (selectionInfo) {
            selectionInfo.textContent = 'Nothing selected';
        }
    }

    createDragHandles(mesh) {
        // Check if mesh is valid
        if (!mesh) {
            console.warn('createDragHandles called with invalid mesh');
            return;
        }
        
        // Clear any existing handles
        this.clearDragHandles();
        
        // Create new modern gizmo
        if (!this.modernGizmo) {
            this.modernGizmo = new ModernGizmoSystem(this.scene, this.camera, this.canvas);
        }
        
        this.modernGizmo.createGizmo(mesh);
        this.modernGizmo.show();
        
        console.log('Created modern gizmo for mesh:', mesh.name);
    }

    clearDragHandles() {
        // Dispose modern gizmo
        if (this.modernGizmo) {
            this.modernGizmo.dispose();
        }
        
        // Clear old drag handles if any remain
        if (this.dragHandles) {
            this.dragHandles.forEach(handle => handle.dispose());
            this.dragHandles = [];
        }
        
        console.log('Cleared all drag handles and gizmos');
    }

    rotatePart(degrees, axis) {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log(`Rotating part ${degrees}Â° around ${axis} axis`);
        
        const radians = degrees * (Math.PI / 180);
        
        switch(axis) {
            case 'X':
                mesh.rotation.x += radians;
                break;
            case 'Y':
                mesh.rotation.y += radians;
                break;
            case 'Z':
                mesh.rotation.z += radians;
                break;
        }
        
        // AUTO-LIFT: Ensure part doesn't go below XY plane after rotation
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        // Update drag handles position (only if Move tool is active)
        if (this.dragHandles && this.activeTool === 'move') {
            this.clearDragHandles();
            this.createDragHandles(mesh);
        }
        
        // Update manipulation buttons position (only if Move tool is active)
        if (this.activeTool === 'move') {
            this.clearManipulationButtons();
            this.createManipulationButtons(mesh);
        }
    }

    /**
     * Update partData.dimensions to reflect current mesh orientation after rotation
     */
    updatePartDataDimensions(mesh) {
        if (!mesh || !mesh.partData) return;
        
        // Get current world-space bounding vectors
        mesh.computeWorldMatrix(true);
        const hierarchyBounds = mesh.getHierarchyBoundingVectors(true);
        const worldMin = hierarchyBounds.min;
        const worldMax = hierarchyBounds.max;
        
        // Calculate current world-space dimensions
        const worldSizeX = Math.abs(worldMax.x - worldMin.x);
        const worldSizeY = Math.abs(worldMax.y - worldMin.y);
        const worldSizeZ = Math.abs(worldMax.z - worldMin.z);
        
        // Convert from cm to inches
        const currentXInches = worldSizeX / 2.54;
        const currentYInches = worldSizeY / 2.54;
        const currentZInches = worldSizeZ / 2.54;
        
        // Find the longest and shortest horizontal dimensions (X and Z)
        const horizontalDims = [currentXInches, currentZInches].sort((a, b) => b - a);
        
        // Update partData.dimensions based on current world-space orientation
        mesh.partData.dimensions.length = horizontalDims[0];     // Longer horizontal dimension
        mesh.partData.dimensions.width = horizontalDims[1];      // Shorter horizontal dimension
        mesh.partData.dimensions.thickness = currentYInches;     // Vertical dimension
        
        // Also update the selectedPart reference if it exists
        if (this.selectedPart === mesh.partData) {
            this.selectedPart.dimensions = mesh.partData.dimensions;
        }
    }

    flipPart(axis) {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log(`Flipping part along ${axis} axis`);
        
        switch(axis) {
            case 'X':
                mesh.rotation.x += Math.PI;
                break;
            case 'Y':
                mesh.rotation.y += Math.PI;
                break;
            case 'Z':
                mesh.rotation.z += Math.PI;
                break;
        }
        
        // AUTO-LIFT: Ensure part doesn't go below XY plane after flip
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        // Update drag handles position (only if Move tool is active)
        if (this.dragHandles && this.activeTool === 'move') {
            this.clearDragHandles();
            this.createDragHandles(mesh);
        }
        
        // Update manipulation buttons position (only if Move tool is active)
        if (this.activeTool === 'move') {
            this.clearManipulationButtons();
            this.createManipulationButtons(mesh);
        }
    }

    flattenBoard() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Flattening board (3/4" on top/bottom)');
        
        // Reset rotation to lay flat
        mesh.rotation.x = 0;
        mesh.rotation.y = 0;
        mesh.rotation.z = 0;
        
        // AUTO-LIFT: Ensure part doesn't go below XY plane
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    dropPart() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Dropping part to flat surface below');
        
        // Reset rotation to lay flat (like flattenBoard)
        mesh.rotation.x = 0;
        mesh.rotation.y = 0;
        mesh.rotation.z = 0;
        
        // Drop to XY plane (Y = 0 surface)
        const boundingInfo = mesh.getBoundingInfo();
        const thicknessHalf = Math.abs(boundingInfo.maximum.y - boundingInfo.minimum.y) / 2;
        mesh.position.y = thicknessHalf; // Place bottom of part on XY plane
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    standOnEndEdge() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Standing board on end edge (3/4" as width)');
        
        // Rotate 90 degrees around X to stand on end edge
        mesh.rotation.x = Math.PI / 2;
        mesh.rotation.y = 0;
        mesh.rotation.z = 0;
        
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    standOnSideEdge() {
        if (!this.selectedPart) return;
        
        const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
        if (!mesh) return;
        
        console.log('Standing board on side edge (3/4" as height)');
        
        // Rotate 90 degrees around Z to stand on side edge
        mesh.rotation.x = 0;
        mesh.rotation.y = 0;
        mesh.rotation.z = Math.PI / 2;
        
        this.keepOnBenchSurface(mesh);
        
        // CRITICAL: Update partData.dimensions to reflect current orientation
        this.updatePartDataDimensions(mesh);
        
        this.updateManipulationUI(mesh);
    }

    updateManipulationUI(mesh) {
        // Update drag handles position (only if Move tool is active)
        if (this.dragHandles && this.activeTool === 'move') {
            this.clearDragHandles();
            this.createDragHandles(mesh);
        }
        
        // Update manipulation buttons position (only if Move tool is active)
        if (this.activeTool === 'move') {
            this.clearManipulationButtons();
            this.createManipulationButtons(mesh);
        }
    }

    // Grid snapping functionality
    snapToGrid(value, gridSize = 2.54) { // Default 1 inch grid (2.54 cm)
        return Math.round(value / gridSize) * gridSize;
    }

    snapPosition(position) {
        return new BABYLON.Vector3(
            this.snapToGrid(position.x),
            this.snapToGrid(position.y, 1.27), // Y axis uses 0.5 inch grid for stacking
            this.snapToGrid(position.z)
        );
    }

    enableDragHandleInteraction() {
        // Modern gizmo handles its own interactions
        
        // Add mouse event handlers for drag handles
        this.dragPointerObserver = this.scene.onPointerObservable.add((pointerInfo) => {
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    this.onDragStart(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    this.onDragMove(pointerInfo);
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    this.onDragEnd(pointerInfo);
                    break;
            }
        });
        
        console.log('Drag handle interaction enabled');
    }

    onDragStart(pointerInfo) {
        const pickedMesh = pointerInfo.pickInfo.pickedMesh;
        
        if (pickedMesh && pickedMesh.isDragHandle) {
            this.isDragging = true;
            this.dragHandle = pickedMesh;
            this.dragStartPosition = pickedMesh.targetPart.position.clone();
            
            // DISABLE camera controls during drag operations
            this.camera.detachControl(this.canvas);
            
            // Initialize mouse tracking for smooth movement
            this.lastMouseX = pointerInfo.event.offsetX;
            this.lastMouseY = pointerInfo.event.offsetY;
            
            // Change handle appearance to show it's active
            pickedMesh.material.emissiveColor = pickedMesh.material.diffuseColor.scale(0.8);
            
            const handleInfo = pickedMesh.handleType === 'plane' ? 
                `${pickedMesh.axes} plane (${pickedMesh.lockedAxis} locked)` : 
                `${pickedMesh.axis} axis`;
            console.log(`Started dragging ${handleInfo} handle - Camera controls DISABLED`);
        } else if (pickedMesh && pickedMesh.partData && this.selectedPart) {
            // PREPARE for potential dragging but don't start yet
            // Only start dragging if mouse actually moves
            this.isDragging = false; // Don't start dragging immediately
            this.dragHandle = null; // No specific axis constraint
            this.dragStartPosition = pickedMesh.position.clone();
            this.draggedPart = pickedMesh;
            this.potentialDragPart = pickedMesh; // Mark part as potential drag target
            
            // Initialize mouse tracking for drag detection
            this.lastMouseX = pointerInfo.event.offsetX;
            this.lastMouseY = pointerInfo.event.offsetY;
            this.dragStartMouseX = pointerInfo.event.offsetX;
            this.dragStartMouseY = pointerInfo.event.offsetY;
            
            console.log('Part clicked - prepared for potential dragging');
        }
    }

    onDragMove(pointerInfo) {
        // Check if we have a potential drag part that hasn't started dragging yet
        if (this.potentialDragPart && !this.isDragging && pointerInfo.event.buttons === 1) {
            // Only check for drag if LEFT mouse button is still pressed
            const deltaX = pointerInfo.event.offsetX - this.dragStartMouseX;
            const deltaY = pointerInfo.event.offsetY - this.dragStartMouseY;
            const mouseDelta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Only start dragging if mouse moved more than 5 pixels AND left button is pressed
            if (mouseDelta > 5) {
                this.isDragging = true;
                this.draggedPart = this.potentialDragPart;
                this.potentialDragPart = null;
                
                // DISABLE camera controls during drag operations
                this.camera.detachControl(this.canvas);
                
                console.log('Started dragging part directly - Camera controls DISABLED');
            }
        }
        
        if (!this.isDragging) return;
        
        if (this.dragHandle) {
            // Check handle type for different movement modes
            if (this.dragHandle.handleType === 'single') {
                // Single-axis constrained dragging
                this.handleAxisDrag(pointerInfo);
            } else if (this.dragHandle.handleType === 'plane') {
                // Dual-axis plane dragging
                this.handlePlaneDrag(pointerInfo);
            }
        } else if (this.draggedPart) {
            // Free movement dragging
            this.handleFreeDrag(pointerInfo);
        }
    }

    onDragEnd(pointerInfo) {
        // Clear potential drag state if mouse was released without dragging
        if (this.potentialDragPart && !this.isDragging) {
            this.potentialDragPart = null;
            console.log('Selection completed - no drag occurred');
            return;
        }
        
        if (!this.isDragging) return;
        
        // RE-ENABLE camera controls when drag ends
        // this.camera.attachControl(this.canvas, true); // Commented out to prevent conflicts with custom camera controls
        
        if (this.dragHandle) {
            // Restore handle appearance
            const color = this.dragHandle.material.diffuseColor;
            this.dragHandle.material.emissiveColor = color.scale(0.3);
            
            // Snap final position to grid
            const targetPart = this.dragHandle.targetPart;
            targetPart.position = this.snapPosition(targetPart.position);
            
            // Update drag handles and buttons to new position (only if Move tool is active)
            if (this.activeTool === 'move') {
                this.clearDragHandles();
                this.createDragHandles(targetPart);
                this.clearManipulationButtons();
                this.createManipulationButtons(targetPart);
            }
            
            const handleInfo = this.dragHandle.handleType === 'plane' ? 
                `${this.dragHandle.axes} plane` : 
                `${this.dragHandle.axis} axis`;
            console.log(`Finished dragging ${handleInfo} handle - Camera controls RE-ENABLED`);
        } else if (this.draggedPart) {
            // Snap free drag to grid
            this.draggedPart.position = this.snapPosition(this.draggedPart.position);
            
            // Update drag handles and buttons to new position (only if Move tool is active)
            if (this.activeTool === 'move') {
                this.clearDragHandles();
                this.createDragHandles(this.draggedPart);
                this.clearManipulationButtons();
                this.createManipulationButtons(this.draggedPart);
            }
            
            console.log('Finished free dragging part - Camera controls RE-ENABLED');
        }
        
        this.isDragging = false;
        this.dragHandle = null;
        this.draggedPart = null;
        this.dragStartPosition = null;
        this.potentialDragPart = null; // Clear potential drag state
    }

    handleAxisDrag(pointerInfo) {
        const dragHandle = this.dragHandle;
        const targetPart = dragHandle.targetPart;
        const axis = dragHandle.axis;
        
        // Get mouse delta for smooth movement
        const deltaX = pointerInfo.event.offsetX - this.lastMouseX;
        const deltaY = pointerInfo.event.offsetY - this.lastMouseY;
        
        // Store current mouse position for next frame
        this.lastMouseX = pointerInfo.event.offsetX;
        this.lastMouseY = pointerInfo.event.offsetY;
        
        // Calculate movement sensitivity
        const sensitivity = 0.2;
        
        // Move along the specified axis based on mouse movement
        switch(axis) {
            case 'X':
                targetPart.position.x += deltaX * sensitivity;
                break;
            case 'Y':
                targetPart.position.y -= deltaY * sensitivity; // Invert Y for proper direction
                break;
            case 'Z':
                targetPart.position.z += (deltaX + deltaY) * sensitivity * 0.5; // Combine for Z movement
                break;
        }
        
        // Apply grid snapping in real-time
        targetPart.position = this.snapPosition(targetPart.position);
        
        // Ensure part stays on bench surface
        this.keepOnBenchSurface(targetPart);
        
        // Update handle positions
        this.updateDragHandlePositions(targetPart);
    }

    handlePlaneDrag(pointerInfo) {
        const dragHandle = this.dragHandle;
        const targetPart = dragHandle.targetPart;
        const axes = dragHandle.axes;
        const lockedAxis = dragHandle.lockedAxis;
        
        // Get mouse delta for smooth movement
        const deltaX = pointerInfo.event.offsetX - this.lastMouseX;
        const deltaY = pointerInfo.event.offsetY - this.lastMouseY;
        
        // Store current mouse position for next frame
        this.lastMouseX = pointerInfo.event.offsetX;
        this.lastMouseY = pointerInfo.event.offsetY;
        
        // Calculate movement sensitivity
        const sensitivity = 0.2;
        
        // Save the locked axis position
        const lockedPosition = lockedAxis === 'X' ? targetPart.position.x : 
                              (lockedAxis === 'Y' ? targetPart.position.y : targetPart.position.z);
        
        // Move along the plane axes based on mouse movement
        switch(axes) {
            case 'XY': // Z locked
                targetPart.position.x += deltaX * sensitivity;
                targetPart.position.y -= deltaY * sensitivity;
                break;
            case 'XZ': // Y locked  
                targetPart.position.x += deltaX * sensitivity;
                targetPart.position.z += deltaY * sensitivity;
                break;
            case 'YZ': // X locked
                targetPart.position.y -= deltaX * sensitivity;
                targetPart.position.z += deltaY * sensitivity;
                break;
        }
        
        // Restore the locked axis position
        if (lockedAxis === 'X') {
            targetPart.position.x = lockedPosition;
        } else if (lockedAxis === 'Y') {
            targetPart.position.y = lockedPosition;
        } else if (lockedAxis === 'Z') {
            targetPart.position.z = lockedPosition;
        }
        
        // Apply grid snapping in real-time
        targetPart.position = this.snapPosition(targetPart.position);
        
        // Ensure part stays on bench surface
        this.keepOnBenchSurface(targetPart);
        
        // Update handle positions
        this.updateDragHandlePositions(targetPart);
    }

    handleFreeDrag(pointerInfo) {
        const part = this.draggedPart;
        
        // Create a picking ray from mouse position
        const ray = this.scene.createPickingRay(
            pointerInfo.event.offsetX,
            pointerInfo.event.offsetY,
            BABYLON.Matrix.Identity(),
            this.camera
        );
        
        // Project onto the grid plane (Y = 0 for now)
        const groundPlane = BABYLON.Plane.FromPositionAndNormal(
            new BABYLON.Vector3(0, 0, 0),
            new BABYLON.Vector3(0, 1, 0)
        );
        
        const distance = ray.intersectsPlane(groundPlane);
        if (distance !== null) {
            const worldPos = ray.origin.add(ray.direction.scale(distance));
            
            // Maintain current Y position, only move in X and Z
            worldPos.y = part.position.y;
            
            // Apply real-time grid snapping for smooth movement
            part.position = this.snapPosition(worldPos);
            
            // Update handle positions
            this.updateDragHandlePositions(part);
        }
    }

    updateDragHandlePositions(targetPart) {
        if (!this.dragHandles) return;
        
        // Recalculate highest point after movement
        targetPart.computeWorldMatrix(true);
        const boundingInfo = targetPart.getBoundingInfo();
        const worldMatrix = targetPart.getWorldMatrix();
        
        const corners = [
            boundingInfo.minimum,
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.maximum.z),
            boundingInfo.maximum
        ];
        
        let highestY = -Infinity;
        corners.forEach(corner => {
            const worldCorner = BABYLON.Vector3.TransformCoordinates(corner, worldMatrix);
            if (worldCorner.y > highestY) {
                highestY = worldCorner.y;
            }
        });
        
        const clearance = 5;
        const handleHeight = highestY + clearance;
        const partPosition = targetPart.getAbsolutePosition();
        
        this.dragHandles.forEach(handle => {
            if (handle.axis) {
                // Update single-axis handles
                if (handle.axis === 'X') {
                    if (handle.name && handle.name.includes('shaft')) {
                        handle.position = new BABYLON.Vector3(partPosition.x + 8, handleHeight, partPosition.z);
                    } else {
                        handle.position = new BABYLON.Vector3(partPosition.x + 12, handleHeight, partPosition.z);
                    }
                } else if (handle.axis === 'Y') {
                    if (handle.name && handle.name.includes('shaft')) {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight + 8, partPosition.z);
                    } else {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight + 12, partPosition.z);
                    }
                } else if (handle.axis === 'Z') {
                    if (handle.name && handle.name.includes('shaft')) {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight, partPosition.z + 8);
                    } else {
                        handle.position = new BABYLON.Vector3(partPosition.x, handleHeight, partPosition.z + 12);
                    }
                }
            } else if (handle.axes) {
                // Update plane handles
                if (handle.axes === 'XY') {
                    handle.position = new BABYLON.Vector3(partPosition.x + 6, handleHeight, partPosition.z + 6);
                } else if (handle.axes === 'XZ') {
                    handle.position = new BABYLON.Vector3(partPosition.x + 6, handleHeight + 2, partPosition.z - 6);
                } else if (handle.axes === 'YZ') {
                    handle.position = new BABYLON.Vector3(partPosition.x - 6, handleHeight + 2, partPosition.z + 6);
                }
            }
        });
    }

    getAxisVector(axis) {
        switch(axis) {
            case 'X': return new BABYLON.Vector3(1, 0, 0);
            case 'Y': return new BABYLON.Vector3(0, 1, 0);
            case 'Z': return new BABYLON.Vector3(0, 0, 1);
            default: return new BABYLON.Vector3(0, 1, 0);
        }
    }

    keepOnBenchSurface(mesh) {
        // Ensure the part never goes below the bench surface (Y = 0)
        // FORCE matrix update after rotation to get accurate bounding box
        mesh.computeWorldMatrix(true);
        
        // Calculate the mesh's bottom position after rotation
        const boundingInfo = mesh.getBoundingInfo();
        const worldMatrix = mesh.getWorldMatrix();
        
        // Get all bounding box corners and transform them to world space
        const corners = [
            boundingInfo.minimum,
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.maximum.y, boundingInfo.minimum.z),
            new BABYLON.Vector3(boundingInfo.maximum.x, boundingInfo.minimum.y, boundingInfo.maximum.z),
            new BABYLON.Vector3(boundingInfo.minimum.x, boundingInfo.maximum.y, boundingInfo.maximum.z),
            boundingInfo.maximum
        ];
        
        // Find the lowest Y coordinate in world space
        let lowestY = Infinity;
        corners.forEach(corner => {
            const worldCorner = BABYLON.Vector3.TransformCoordinates(corner, worldMatrix);
            if (worldCorner.y < lowestY) {
                lowestY = worldCorner.y;
            }
        });
        
        // If any part is below the bench surface, lift the entire mesh
        if (lowestY < 0) {
            const adjustment = Math.abs(lowestY) + 0.1; // Add small buffer
            mesh.position.y += adjustment;
            console.log(`AUTO-LIFTED part by ${adjustment.toFixed(2)} units to keep on bench surface`);
        } else {
            console.log(`Part already on bench surface (lowest Y: ${lowestY.toFixed(2)})`);
        }
    }

    createPrecisionSliders(container) {
        // Create a label for the precision controls
        const label = new BABYLON.GUI.TextBlock();
        label.text = "Precision Move:";
        label.color = "white";
        label.fontSize = 12;
        label.heightInPixels = 20;
        label.paddingBottomInPixels = 5;
        container.addControl(label);
        
        // Create X axis slider
        const xSliderContainer = new BABYLON.GUI.StackPanel();
        xSliderContainer.isVertical = false;
        xSliderContainer.heightInPixels = 25;
        
        const xLabel = new BABYLON.GUI.TextBlock();
        xLabel.text = "X:";
        xLabel.color = "white";
        xLabel.fontSize = 10;
        xLabel.widthInPixels = 20;
        
        const xSlider = new BABYLON.GUI.Slider();
        xSlider.minimum = -50;
        xSlider.maximum = 50;
        xSlider.value = 0;
        xSlider.widthInPixels = 100;
        xSlider.heightInPixels = 20;
        xSlider.color = "#e74c3c";
        xSlider.background = "#34495e";
        
        xSlider.onValueChangedObservable.add((value) => {
            if (this.selectedPart) {
                const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (mesh) {
                    mesh.position.x = this.snapToGrid(value * 0.5); // Scale for fine control
                    this.updateDragHandlePositions(mesh);
                }
            }
        });
        
        xSliderContainer.addControl(xLabel);
        xSliderContainer.addControl(xSlider);
        container.addControl(xSliderContainer);
        
        // Create Z axis slider  
        const zSliderContainer = new BABYLON.GUI.StackPanel();
        zSliderContainer.isVertical = false;
        zSliderContainer.heightInPixels = 25;
        
        const zLabel = new BABYLON.GUI.TextBlock();
        zLabel.text = "Z:";
        zLabel.color = "white";
        zLabel.fontSize = 10;
        zLabel.widthInPixels = 20;
        
        const zSlider = new BABYLON.GUI.Slider();
        zSlider.minimum = -50;
        zSlider.maximum = 50;
        zSlider.value = 0;
        zSlider.widthInPixels = 100;
        zSlider.heightInPixels = 20;
        zSlider.color = "#3498db";
        zSlider.background = "#34495e";
        
        zSlider.onValueChangedObservable.add((value) => {
            if (this.selectedPart) {
                const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (mesh) {
                    mesh.position.z = this.snapToGrid(value * 0.5); // Scale for fine control
                    this.updateDragHandlePositions(mesh);
                }
            }
        });
        
        zSliderContainer.addControl(zLabel);
        zSliderContainer.addControl(zSlider);
        container.addControl(zSliderContainer);
        
        // Reset button
        const resetBtn = BABYLON.GUI.Button.CreateSimpleButton("resetPos", "Reset Position");
        resetBtn.widthInPixels = 120;
        resetBtn.heightInPixels = 25;
        resetBtn.color = "white";
        resetBtn.cornerRadius = 5;
        resetBtn.background = "#7f8c8d";
        resetBtn.fontSize = 10;
        
        resetBtn.onPointerUpObservable.add(() => {
            xSlider.value = 0;
            zSlider.value = 0;
            if (this.selectedPart) {
                const mesh = this.scene.meshes.find(m => m.partData === this.selectedPart);
                if (mesh) {
                    mesh.position.x = 0;
                    mesh.position.z = 0;
                    this.updateDragHandlePositions(mesh);
                }
            }
        });
        
        container.addControl(resetBtn);
    }
}

// Initialize Drawing World when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Create global reference for manipulation buttons
    window.drawingWorld = null;
    
    // Get project ID from URL params
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('id');
    
    if (projectId) {
        // Load project data
        const projects = JSON.parse(localStorage.getItem('cutlist-projects') || '[]');
        const project = projects.find(p => p.id === projectId);
        
        if (project) {
            document.getElementById('project-name').textContent = project.name;
            document.title = `CutList - ${project.name}`;
        }
    }
    
    // Initialize the 3D world
    const drawingWorld = new DrawingWorld();
    window.drawingWorld = drawingWorld;
    
    // Removed auto-spawning chamfered primitive
// DEBUG FUNCTIONS FOR LOADED VS FRESH BOARD INVESTIGATION
window.debugBoardComparison = function() {
    console.log('ðŸ” BOARD COMPARISON DEBUG STARTING...');
    console.log('ðŸ“Š Total workbench parts:', drawingWorld.workBenchParts.length);
    
    drawingWorld.workBenchParts.forEach((part, index) => {
        console.log(`\nðŸ“‹ BOARD ${index}:`, part);
        console.log(`   ðŸ†” ID: ${part.id}`);
        console.log(`   ðŸ“¦ Material: ${part.materialId} (${part.materialName})`);
        console.log(`   ðŸ“ Dimensions: ${part.dimensions.length}x${part.dimensions.width}x${part.dimensions.thickness}`);
        console.log(`   ðŸ·ï¸ Grade: ${part.grade}`);
        console.log(`   ðŸ“ˆ Status: ${part.status}`);
        if (part.cutHistory) console.log(`   âœ‚ï¸ Cut History: `, part.cutHistory);
        if (part.meshGeometry) console.log(`   ðŸ§Š Geometry: `, part.meshGeometry);
    });
    
    const workbenchMeshes = drawingWorld.scene.meshes.filter(m => m.isWorkBenchPart);
    console.log(`\nðŸŽ­ MESH OBJECTS (${workbenchMeshes.length}):`);
    workbenchMeshes.forEach((mesh, index) => {
        console.log(`\nðŸŽ­ MESH ${index}:`, mesh);
        console.log(`   ðŸ†” ID: ${mesh.id}`);
        console.log(`   ðŸŽ¨ Material: `, mesh.material);
        console.log(`   ðŸ“ Position: `, mesh.position);
        console.log(`   ðŸ“ Scaling: `, mesh.scaling);
        if (mesh.partData) console.log(`   ðŸ·ï¸ Part Data: `, mesh.partData);
    });
};

window.testLoadedBoardCutting = function() {
    console.log('âœ‚ï¸ TESTING LOADED BOARD CUTTING...');
    const workbenchMeshes = drawingWorld.scene.meshes.filter(m => m.isWorkBenchPart);
    if (workbenchMeshes.length === 0) {
        console.error('âŒ No workbench parts found for cutting test');
        return;
    }
    
    console.log(`ðŸŽ¯ Found ${workbenchMeshes.length} workbench part(s) for cutting test`);
    workbenchMeshes.forEach((mesh, index) => {
        console.log(`\nðŸŽ¯ TESTING MESH ${index} (ID: ${mesh.id})`);
        console.log('   ðŸ“‹ Part Data:', mesh.partData);
        console.log('   ðŸŽ¨ Material:', mesh.material);
        console.log('   ðŸ“Š Properties:', {
            position: mesh.position,
            scaling: mesh.scaling,
            isWorkBenchPart: mesh.isWorkBenchPart
        });
    });
    
    console.log('ðŸš¨ Ready for manual cutting test - select a cutting tool and try cutting the loaded board');
};

window.identifyBoardDifferences = function() {
    console.log('ðŸ”¬ IDENTIFYING BOARD DIFFERENCES...');
    if (drawingWorld.workBenchParts.length < 2) {
        console.error('âŒ Need at least 2 boards to compare');
        return;
    }
    
    const board1 = drawingWorld.workBenchParts[0];
    const board2 = drawingWorld.workBenchParts[1];
    
    console.log('ðŸ†š COMPARING BOARD PROPERTIES:');
    
    const props = ['id', 'materialId', 'materialName', 'grade', 'status', 'cutHistory', 'meshGeometry'];
    props.forEach(prop => {
        const val1 = board1[prop];
        const val2 = board2[prop];
        const match = JSON.stringify(val1) === JSON.stringify(val2);
        console.log(`   ${match ? 'âœ…' : 'âŒ'} ${prop}: ${match ? 'MATCH' : 'DIFFERENT'}`);
        if (!match) {
            console.log(`      ðŸ”¹ Board 1: `, val1);
            console.log(`      ðŸ”¹ Board 2: `, val2);
        }
    });
    
    console.log('\nðŸŽ­ COMPARING MESH OBJECTS:');
    const meshes = drawingWorld.scene.meshes.filter(m => m.isWorkBenchPart);
    if (meshes.length >= 2) {
        const mesh1 = meshes[0];
        const mesh2 = meshes[1];
        
        const meshProps = ['id', 'material.name', 'position', 'scaling'];
        meshProps.forEach(prop => {
            const val1 = prop.includes('.') ? mesh1[prop.split('.')[0]][prop.split('.')[1]] : mesh1[prop];
            const val2 = prop.includes('.') ? mesh2[prop.split('.')[0]][prop.split('.')[1]] : mesh2[prop];
            const match = JSON.stringify(val1) === JSON.stringify(val2);
            console.log(`   ${match ? 'âœ…' : 'âŒ'} ${prop}: ${match ? 'MATCH' : 'DIFFERENT'}`);
            if (!match) {
                console.log(`      ðŸ”¹ Mesh 1: `, val1);
                console.log(`      ðŸ”¹ Mesh 2: `, val2);
            }
        });
    }
};

console.log('ðŸ› ï¸ DEBUG FUNCTIONS LOADED:');
console.log('   debugBoardComparison() - Compare all boards');
console.log('   testLoadedBoardCutting() - Test cutting loaded boards');
console.log('   identifyBoardDifferences() - Find differences between boards');
});