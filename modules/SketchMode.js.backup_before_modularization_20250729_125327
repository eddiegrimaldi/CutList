// SketchMode.js - Sketch mode environment and drawing tools
// Handles sketch plane creation, drawing tools, and sketch mode interactions

export class SketchMode {
    constructor(scene, camera, shape2D) {
        this.scene = scene;
        this.camera = camera;
        this.shape2D = shape2D;
        
        // Sketch state
        this.isSketchMode = false;
        this.currentSketch = null;
        this.currentSketchSurface = null;
        
        // Coordinate system
        this.sketchForward = null;
        this.sketchRight = null;
        this.sketchUp = null;
        this.sketchOrigin = null;
        
        // Drawing state
        this.isDrawing = false;
        this.startPoint = null;
        this.currentTool = 'rectangle';
        
        // Preview meshes
        this.linePreview = null;
        this.shapePreview = null;
        
        // Sketch environment
        this.sketchGround = null;
        this.sketchGridLines = [];
        
        // Polygon/Triangle state
        this.polygonPoints = [];
        this.trianglePoints = [];
        
        // Event handlers
        this.sketchMouseDownHandler = null;
        this.sketchMouseMoveHandler = null;
        this.sketchMouseUpHandler = null;
        this.sketchKeyHandler = null;
    }
    
    // ==================== SKETCH MODE MANAGEMENT ====================
    
    enterSketchMode(mesh = null, pickPoint = null, surfaceNormal = null) {
        
        // Set up sketch surface
        this.currentSketchSurface = {
            mesh: mesh,
            point: pickPoint || BABYLON.Vector3.Zero(),
            normal: surfaceNormal ? surfaceNormal.normalize() : new BABYLON.Vector3(0, 0, 1)
        };
        
        this.isSketchMode = true;
        
        // Create coordinate system for the surface
        this.createSketchCoordinateSystem(this.currentSketchSurface.normal);
        
        // Animate camera to surface position
        this.animateCameraToSurface(this.currentSketchSurface.point, this.currentSketchSurface.normal, () => {
            // After camera animation completes, create sketch environment
            this.createSketchEnvironment();
        });
    }
    
    exitSketchMode() {
        
        this.isSketchMode = false;
        
        // Clean up sketch environment
        this.cleanupSketchEnvironment();
        
        // Reset state
        this.currentSketch = null;
        this.currentSketchSurface = null;
        this.isDrawing = false;
        
        // Remove event handlers
        this.removeSketchEventHandlers();
    }
    
    // ==================== COORDINATE SYSTEM ====================
    
    createSketchCoordinateSystem(surfaceNormal) {
        // Create a robust coordinate system for any surface orientation
        const normal = surfaceNormal.normalize();
        
        // Choose the most stable reference vector based on the normal
        let up = new BABYLON.Vector3(0, 1, 0); // World up
        
        // If surface normal is nearly vertical, use a different reference
        const dotProduct = Math.abs(BABYLON.Vector3.Dot(normal, up));
        
        if (dotProduct > 0.9) {
            up = new BABYLON.Vector3(1, 0, 0); // World X if normal is too close to Y
        }
        
        // Create orthonormal basis using Gram-Schmidt process
        this.sketchForward = normal.clone(); // Surface normal points "out" from surface
        this.sketchRight = BABYLON.Vector3.Cross(up, this.sketchForward);
        
        if (this.sketchRight.length() < 0.001) {
            // Use a perpendicular vector
            if (Math.abs(normal.x) < 0.9) {
                this.sketchRight = BABYLON.Vector3.Cross(new BABYLON.Vector3(1, 0, 0), this.sketchForward);
            } else {
                this.sketchRight = BABYLON.Vector3.Cross(new BABYLON.Vector3(0, 0, 1), this.sketchForward);
            }
        }
        
        this.sketchRight = this.sketchRight.normalize();
        this.sketchUp = BABYLON.Vector3.Cross(this.sketchForward, this.sketchRight).normalize();
        
        // Verify we have a valid orthonormal basis
        if (this.sketchRight.length() < 0.1 || this.sketchUp.length() < 0.1) {
            // Fallback to a simple XY plane
            this.sketchRight = new BABYLON.Vector3(1, 0, 0);
            this.sketchUp = new BABYLON.Vector3(0, 1, 0);
            this.sketchForward = new BABYLON.Vector3(0, 0, 1);
        }
        
        // Store surface origin (the picked point)
        this.sketchOrigin = this.currentSketchSurface.point.clone();
        
        // Update shape2D coordinate system
        if (this.shape2D) {
            this.shape2D.sketchSystem = {
                sketchForward: this.sketchForward,
                sketchRight: this.sketchRight,
                sketchUp: this.sketchUp,
                sketchOrigin: this.sketchOrigin
            };
        }
    }
    
    // ==================== CAMERA ANIMATION ====================
    
    animateCameraToSurface(pickPoint, surfaceNormal, callback) {
        if (!this.camera || !this.camera.setTarget) {
            if (callback) callback();
            return;
        }
        
        // Calculate camera position for orthographic sketch view
        const distance = 10; // Distance from surface
        const cameraPosition = pickPoint.add(surfaceNormal.scale(distance));
        
        // Animate camera to look at the surface orthographically
        BABYLON.Animation.CreateAndStartAnimation(
            'cameraToSketch',
            this.camera,
            'position',
            60,
            30,
            this.camera.position,
            cameraPosition,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
            null,
            () => {
                // Set camera target to the surface point
                this.camera.setTarget(pickPoint);
                
                // Set orthographic mode (if supported)
                if (this.camera.mode !== undefined) {
                    this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
                    this.camera.orthoLeft = -5;
                    this.camera.orthoRight = 5;
                    this.camera.orthoBottom = -5;
                    this.camera.orthoTop = 5;
                }
                
                if (callback) callback();
            }
        );
    }
    
    // ==================== SKETCH ENVIRONMENT ====================
    
    createSketchEnvironment() {
        // Initialize sketch state
        this.currentSketch = {
            surface: this.currentSketchSurface,
            elements: [],
            isDrawing: false,
            currentTool: this.currentTool,
            startPoint: null,
            polygonPoints: [],
            trianglePoints: []
        };
        
        // Create sketch ground plane
        this.createSketchGround();
        
        // Create sketch grid
        this.createSketchGrid();
        
        // Set up event handlers
        this.setupSketchEventHandlers();
        
    }
    
    createSketchGround() {
        // Create invisible ground plane for mouse picking
        this.sketchGround = BABYLON.MeshBuilder.CreateGround('sketchGround', {
            width: 100,
            height: 100
        }, this.scene);
        
        // Position on the sketch surface
        this.sketchGround.position = this.sketchOrigin.clone();
        
        // Align with sketch plane
        if (this.sketchForward && this.sketchRight && this.sketchUp) {
            // Create rotation matrix from our coordinate system
            const matrix = BABYLON.Matrix.FromValues(
                this.sketchRight.x, this.sketchRight.y, this.sketchRight.z, 0,
                this.sketchUp.x, this.sketchUp.y, this.sketchUp.z, 0,
                this.sketchForward.x, this.sketchForward.y, this.sketchForward.z, 0,
                0, 0, 0, 1
            );
            
            this.sketchGround.rotationQuaternion = BABYLON.Quaternion.FromRotationMatrix(matrix);
        }
        
        // Make it invisible but pickable
        this.sketchGround.isVisible = false;
        this.sketchGround.isPickable = true;
    }
    
    createSketchGrid() {
        // Create visual grid lines
        this.sketchGridLines = [];
        
        const gridSize = 50;
        const spacing = 1;
        const gridCenter = this.sketchOrigin.clone();
        
        // Create grid lines along sketch right direction (X axis)
        for (let i = -gridSize; i <= gridSize; i += spacing) {
            const start = gridCenter.add(this.sketchUp.scale(i)).add(this.sketchRight.scale(-gridSize));
            const end = gridCenter.add(this.sketchUp.scale(i)).add(this.sketchRight.scale(gridSize));
            
            const line = BABYLON.MeshBuilder.CreateLines('sketchGridX_' + i, {
                points: [start, end]
            }, this.scene);
            
            line.color = new BABYLON.Color3(0.8, 0.8, 0.8);
            line.alpha = 0.3;
            line.isPickable = false;
            this.sketchGridLines.push(line);
        }
        
        // Create grid lines along sketch up direction (Y axis)
        for (let i = -gridSize; i <= gridSize; i += spacing) {
            const start = gridCenter.add(this.sketchRight.scale(i)).add(this.sketchUp.scale(-gridSize));
            const end = gridCenter.add(this.sketchRight.scale(i)).add(this.sketchUp.scale(gridSize));
            
            const line = BABYLON.MeshBuilder.CreateLines('sketchGridY_' + i, {
                points: [start, end]
            }, this.scene);
            
            line.color = new BABYLON.Color3(0.8, 0.8, 0.8);
            line.alpha = 0.3;
            line.isPickable = false;
            this.sketchGridLines.push(line);
        }
        
        // Add center lines
        const centerLines = [];
        
        // X axis (red) - along surface Right direction
        centerLines.push(BABYLON.MeshBuilder.CreateLines("sketchCenterX", {
            points: [
                gridCenter.add(this.sketchRight.scale(-gridSize)),
                gridCenter.add(this.sketchRight.scale(gridSize))
            ]
        }, this.scene));
        centerLines[0].color = new BABYLON.Color3(0.9, 0.2, 0.2); // Red
        centerLines[0].isPickable = false;
        
        // Y axis (green) - along surface Up direction
        centerLines.push(BABYLON.MeshBuilder.CreateLines("sketchCenterY", {
            points: [
                gridCenter.add(this.sketchUp.scale(-gridSize)),
                gridCenter.add(this.sketchUp.scale(gridSize))
            ]
        }, this.scene));
        centerLines[1].color = new BABYLON.Color3(0.2, 0.9, 0.2); // Green
        centerLines[1].isPickable = false;
        
        // Store all grid elements for cleanup
        this.sketchGridLines = [...this.sketchGridLines, ...centerLines];
    }
    
    cleanupSketchEnvironment() {
        // Dispose sketch ground
        if (this.sketchGround) {
            this.sketchGround.dispose();
            this.sketchGround = null;
        }
        
        // Dispose grid lines
        this.sketchGridLines.forEach(line => {
            if (line) line.dispose();
        });
        this.sketchGridLines = [];
        
        // Clean up previews
        this.cleanupPreviews();
    }
    
    // ==================== DRAWING TOOLS ====================
    
    setTool(toolName) {
        this.currentTool = toolName;
        if (this.currentSketch) {
            this.currentSketch.currentTool = toolName;
        }
    }
    
    // ==================== EVENT HANDLERS ====================
    
    setupSketchEventHandlers() {
        // Mouse down handler
        this.sketchMouseDownHandler = (event) => {
            if (!this.isSketchMode || !this.currentSketch) return;
            
            const rect = this.scene.getEngine().getRenderingCanvas().getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Use Babylon's picking with proper coordinates
            const pickInfo = this.scene.pick(x, y, (mesh) => {
                // Only pick the sketch ground for drawing
                return mesh.name === 'sketchGround';
            });
            
            if (pickInfo.hit && pickInfo.pickedMesh.name === 'sketchGround') {
                const point = pickInfo.pickedPoint;
                this.handleSketchClick(point);
            }
        };
        
        // Mouse move handler for previews
        this.sketchMouseMoveHandler = (event) => {
            if (!this.isSketchMode || !this.currentSketch) return;
            
            const rect = this.scene.getEngine().getRenderingCanvas().getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const pickInfo = this.scene.pick(x, y, (mesh) => mesh.name === 'sketchGround');
            
            if (pickInfo.hit && this.currentSketch.isDrawing) {
                const point = pickInfo.pickedPoint;
                this.updateSketchPreview(point);
            }
        };
        
        // Key handler for canceling
        this.sketchKeyHandler = (event) => {
            if (!this.isSketchMode) return;
            
            if (event.key === 'Escape') {
                this.cancelCurrentDrawing();
            }
        };
        
        // Add event listeners
        const canvas = this.scene.getEngine().getRenderingCanvas();
        canvas.addEventListener('mousedown', this.sketchMouseDownHandler);
        canvas.addEventListener('mousemove', this.sketchMouseMoveHandler);
        document.addEventListener('keydown', this.sketchKeyHandler);
    }
    
    removeSketchEventHandlers() {
        const canvas = this.scene.getEngine().getRenderingCanvas();
        
        if (this.sketchMouseDownHandler) {
            canvas.removeEventListener('mousedown', this.sketchMouseDownHandler);
            this.sketchMouseDownHandler = null;
        }
        
        if (this.sketchMouseMoveHandler) {
            canvas.removeEventListener('mousemove', this.sketchMouseMoveHandler);
            this.sketchMouseMoveHandler = null;
        }
        
        if (this.sketchKeyHandler) {
            document.removeEventListener('keydown', this.sketchKeyHandler);
            this.sketchKeyHandler = null;
        }
    }
    
    // ==================== DRAWING LOGIC ====================
    
    handleSketchClick(point) {
        switch (this.currentSketch.currentTool) {
            case 'rectangle':
                this.handleRectangleDrawing(point);
                break;
            case 'circle':
                this.handleCircleDrawing(point);
                break;
            case 'ellipse':
                this.handleEllipseDrawing(point);
                break;
            case 'polygon':
                this.handlePolygonDrawing(point);
                break;
            case 'triangle':
                this.handleTriangleDrawing(point);
                break;
        }
    }
    
    handleRectangleDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start rectangle - first click
            this.currentSketch.startPoint = point.clone();
            this.currentSketch.isDrawing = true;
            this.createRectanglePreview(point, point);
        } else {
            // End rectangle - second click
            this.finishRectangle(point);
            this.currentSketch.isDrawing = false;
        }
    }
    
    handleCircleDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start circle - first click
            this.currentSketch.startPoint = point.clone();
            this.currentSketch.isDrawing = true;
            this.createCirclePreview(point, 0);
        } else {
            // End circle - second click
            const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, point);
            this.finishCircle(radius);
            this.currentSketch.isDrawing = false;
        }
    }
    
    handleEllipseDrawing(point) {
        if (!this.currentSketch.isDrawing) {
            // Start ellipse - first click
            this.currentSketch.startPoint = point.clone();
            this.currentSketch.isDrawing = true;
            this.createEllipsePreview(point, 0, 0);
        } else {
            // End ellipse - second click
            this.finishEllipse(point);
            this.currentSketch.isDrawing = false;
        }
    }
    
    handlePolygonDrawing(point) {
        // Add point to polygon
        this.currentSketch.polygonPoints.push(point.clone());
        
        // Update preview
        this.createPolygonPreview(this.currentSketch.polygonPoints);
        
        // Check for double-click or right-click to finish
        // For now, finish after 4 points
        if (this.currentSketch.polygonPoints.length >= 4) {
            this.finishPolygon();
        }
    }
    
    handleTriangleDrawing(point) {
        // Add point to triangle
        this.currentSketch.trianglePoints.push(point.clone());
        
        // Update preview
        this.createTrianglePreview(this.currentSketch.trianglePoints);
        
        // Finish after 3 points
        if (this.currentSketch.trianglePoints.length >= 3) {
            this.finishTriangle();
        }
    }
    
    // ==================== PREVIEW METHODS ====================
    
    createRectanglePreview(start, end) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (this.shape2D) {
            const corners = this.shape2D.getRectangleCorners(start, end);
            const previewMaterial = this.shape2D.createPreviewMaterial('rectPreviewMaterial');
            this.shapePreview = this.shape2D.createThickLineLoop(corners, 'rectPreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    createCirclePreview(center, radius) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (radius > 0 && this.shape2D) {
            const points = this.shape2D.getCirclePoints(center, radius);
            const previewMaterial = this.shape2D.createPreviewMaterial('circlePreviewMaterial');
            this.shapePreview = this.shape2D.createThickLineLoop(points, 'circlePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    createEllipsePreview(center, radiusX, radiusY) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if ((radiusX > 0 || radiusY > 0) && this.shape2D) {
            const points = this.shape2D.getEllipsePoints(center, radiusX, radiusY);
            const previewMaterial = this.shape2D.createPreviewMaterial('ellipsePreviewMaterial');
            this.shapePreview = this.shape2D.createThickLineLoop(points, 'ellipsePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    createPolygonPreview(points) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (points.length >= 2 && this.shape2D) {
            const previewMaterial = this.shape2D.createPreviewMaterial('polygonPreviewMaterial');
            this.shapePreview = this.shape2D.createThickLineLoop(points, 'polygonPreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    createTrianglePreview(points) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
        }
        
        if (points.length >= 2 && this.shape2D) {
            const previewMaterial = this.shape2D.createPreviewMaterial('trianglePreviewMaterial');
            this.shapePreview = this.shape2D.createThickLineLoop(points, 'trianglePreview', previewMaterial);
            
            if (this.shapePreview) {
                this.shapePreview.isPickable = false;
                this.shapePreview.renderingGroupId = 2;
            }
        }
    }
    
    updateSketchPreview(point) {
        switch (this.currentSketch.currentTool) {
            case 'rectangle':
                if (this.currentSketch.startPoint) {
                    this.createRectanglePreview(this.currentSketch.startPoint, point);
                }
                break;
            case 'circle':
                if (this.currentSketch.startPoint) {
                    const radius = BABYLON.Vector3.Distance(this.currentSketch.startPoint, point);
                    this.createCirclePreview(this.currentSketch.startPoint, radius);
                }
                break;
            case 'ellipse':
                if (this.currentSketch.startPoint) {
                    const offset = point.subtract(this.currentSketch.startPoint);
                    const radiusX = Math.abs(BABYLON.Vector3.Dot(offset, this.sketchRight));
                    const radiusY = Math.abs(BABYLON.Vector3.Dot(offset, this.sketchUp));
                    this.createEllipsePreview(this.currentSketch.startPoint, radiusX, radiusY);
                }
                break;
        }
    }
    
    // ==================== FINISH METHODS ====================
    
    finishRectangle(endPoint) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        if (this.shape2D) {
            const corners = this.shape2D.getRectangleCorners(this.currentSketch.startPoint, endPoint);
            const rect = this.shape2D.createFilledRectangle(corners, 'sketchRectangle');
            
            if (rect) {
                rect.isPickable = true;
                rect.renderingGroupId = 1;
                
                // Store as closed shape
                this.currentSketch.elements.push({
                    type: 'rectangle',
                    points: corners,
                    mesh: rect,
                    closed: true
                });
            }
        }
    }
    
    finishCircle(radius) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        if (this.shape2D) {
            const circle = this.shape2D.createFilledCircle(this.currentSketch.startPoint, radius, 'sketchCircle');
            
            if (circle) {
                circle.isPickable = true;
                circle.renderingGroupId = 1;
                
                this.currentSketch.elements.push({
                    type: 'circle',
                    center: this.currentSketch.startPoint,
                    radius: radius,
                    mesh: circle,
                    closed: true
                });
            }
        }
    }
    
    finishEllipse(endPoint) {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        if (this.shape2D) {
            const center = this.currentSketch.startPoint;
            const endOffset = endPoint.subtract(center);
            const radiusX = Math.abs(BABYLON.Vector3.Dot(endOffset, this.sketchRight));
            const radiusY = Math.abs(BABYLON.Vector3.Dot(endOffset, this.sketchUp));
            
            const ellipse = this.shape2D.createFilledEllipse(center, radiusX, radiusY, 'sketchEllipse');
            
            if (ellipse) {
                ellipse.isPickable = true;
                ellipse.renderingGroupId = 1;
                
                this.currentSketch.elements.push({
                    type: 'ellipse',
                    center: center,
                    radiusX: radiusX,
                    radiusY: radiusY,
                    mesh: ellipse,
                    closed: true
                });
            }
        }
    }
    
    finishPolygon() {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        if (this.shape2D) {
            const polygon = this.shape2D.createFilledPolygon(this.currentSketch.polygonPoints, 'sketchPolygon');
            
            if (polygon) {
                polygon.isPickable = true;
                polygon.renderingGroupId = 1;
                
                this.currentSketch.elements.push({
                    type: 'polygon',
                    points: this.currentSketch.polygonPoints,
                    mesh: polygon,
                    closed: true
                });
            }
        }
        
        this.currentSketch.polygonPoints = [];
    }
    
    finishTriangle() {
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
        
        if (this.shape2D) {
            const triangle = this.shape2D.createFilledPolygon(this.currentSketch.trianglePoints, 'sketchTriangle');
            
            if (triangle) {
                triangle.isPickable = true;
                triangle.renderingGroupId = 1;
                
                this.currentSketch.elements.push({
                    type: 'triangle',
                    points: this.currentSketch.trianglePoints,
                    mesh: triangle,
                    closed: true
                });
            }
        }
        
        this.currentSketch.trianglePoints = [];
    }
    
    // ==================== HELPER METHODS ====================
    
    cleanupPreviews() {
        if (this.linePreview) {
            this.linePreview.dispose();
            this.linePreview = null;
        }
        
        if (this.shapePreview) {
            this.shapePreview.dispose();
            this.shapePreview = null;
        }
    }
    
    cancelCurrentDrawing() {
        // Clean up any preview shapes
        this.cleanupPreviews();
        
        // Reset drawing state
        if (this.currentSketch) {
            this.currentSketch.isDrawing = false;
            this.currentSketch.startPoint = null;
            this.currentSketch.polygonPoints = [];
            this.currentSketch.trianglePoints = [];
        }
    }
    
    // ==================== PUBLIC METHODS ====================
    
    getSketchElements() {
        return this.currentSketch ? this.currentSketch.elements : [];
    }
    
    isInSketchMode() {
        return this.isSketchMode;
    }
    
    getCurrentTool() {
        return this.currentTool;
    }
    
    // ==================== DISPOSAL ====================
    
    dispose() {
        this.exitSketchMode();
        
        // Clean up references
        this.scene = null;
        this.camera = null;
        this.shape2D = null;
    }
}