import { ViewCube } from './ViewCube.js';

// The Mill System - A 2D workspace for cutting operations
// Simulates real workshop tools in an orthographic view

class TheMillSystem {
    constructor(drawingWorld) {
        this.drawingWorld = drawingWorld;
        this.scene = drawingWorld.scene;
        this.engine = drawingWorld.engine;
        this.canvas = drawingWorld.canvas;
        
        // Mill state
        this.isActive = false;
        this.currentMaterial = null;
        this.currentOperation = null; // 'cut', 'route', 'drill'
        
        // UI elements
        this.millUI = null;
        this.millCanvas = null;
        this.millScene = null;
        this.millCamera = null;
        
        // Turntable and laser elements
        this.turntable = null;
        this.laserLine = null;
        this.kerfWidth = 0.125 * 2.54; // 1/8 inch kerf in cm        
        // Physics setup for gravity
        this.physicsEnabled = false;
        this.boardAggregate = null;
        this.tableAggregate = null;
        this.boardMesh = null;
        this.bladeAngle = 0; // Angle of the blade in radians
        
        // Turntable interaction
        this.isDraggingTurntable = false;
        this.dragStartAngle = 0;
        
        // Transform gizmos for lumber
        this.gizmoManager = null;
        
        // ViewCube for navigation
        this.viewCube = null;
    }
    
    // Open The Mill with a selected material
    openMill(material, operation = 'cut') {
        if (!material) {
            console.error('No material provided to The Mill');
            return;
        }
        
        console.log('Opening The Mill with material:', material.name);
        
        this.currentMaterial = material;
        this.currentOperation = operation;
        this.isActive = true;
        
        // Hide main 3D view
        this.drawingWorld.canvas.style.display = 'none';
        
        // Create mill interface
        this.createMillInterface();
        
        // Setup 2D scene with material
        this.setupMillScene();
        
        // Add event listeners
        this.setupEventListeners();
    }
    
    // Create the mill UI interface
    createMillInterface() {
        // Create container
        this.millUI = document.createElement('div');
        this.millUI.id = 'the-mill-interface';
        this.millUI.style.position = 'fixed';
        this.millUI.style.top = '0';
        this.millUI.style.left = '0';
        this.millUI.style.width = '100%';
        this.millUI.style.height = '100%';
        this.millUI.style.background = '#f5f5f5';
        this.millUI.style.zIndex = '10000';
        
        // Create header
        const header = document.createElement('div');
        header.style.position = 'absolute';
        header.style.top = '0';
        header.style.left = '0';
        header.style.right = '0';
        header.style.height = '60px';
        header.style.background = '#2c3e50';
        header.style.color = 'white';
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.padding = '0 20px';
        header.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        
        // Title
        const title = document.createElement('h2');
        title.textContent = 'The Mill - ' + this.getOperationName();
        title.style.margin = '0';
        title.style.flex = '1';
        header.appendChild(title);
        
        // Tool selector
        const toolSelector = document.createElement('select');
        toolSelector.style.marginRight = '20px';
        toolSelector.style.padding = '8px 12px';
        toolSelector.style.background = 'white';
        toolSelector.style.border = 'none';
        toolSelector.style.borderRadius = '4px';
        toolSelector.style.cursor = 'pointer';
        
        const cutOption = document.createElement('option');
        cutOption.value = 'cut';
        cutOption.textContent = 'Table Saw';
        toolSelector.appendChild(cutOption);
        
        const routeOption = document.createElement('option');
        routeOption.value = 'route';
        routeOption.textContent = 'Router';
        toolSelector.appendChild(routeOption);
        
        const drillOption = document.createElement('option');
        drillOption.value = 'drill';
        drillOption.textContent = 'Drill Press';
        toolSelector.appendChild(drillOption);
        
        toolSelector.value = this.currentOperation;
        toolSelector.addEventListener('change', (e) => {
            this.currentOperation = e.target.value;
            title.textContent = 'The Mill - ' + this.getOperationName();
        });
        header.appendChild(toolSelector);
        
        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Exit Mill';
        closeBtn.style.padding = '10px 20px';
        closeBtn.style.background = '#e74c3c';
        closeBtn.style.color = 'white';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '4px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.addEventListener('click', () => this.closeMill());
        header.appendChild(closeBtn);
        
        this.millUI.appendChild(header);
        
        // Create canvas container
        const canvasContainer = document.createElement('div');
        canvasContainer.id = 'mill-container';  // ID for controls
        canvasContainer.style.position = 'absolute';
        canvasContainer.style.top = '60px';
        canvasContainer.style.left = '0';
        canvasContainer.style.right = '0';
        canvasContainer.style.bottom = '100px';
        canvasContainer.style.background = 'white';
        canvasContainer.style.margin = '20px';
        canvasContainer.style.borderRadius = '8px';
        canvasContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
        canvasContainer.style.overflow = 'hidden';
        
        // Create canvas
        this.millCanvas = document.createElement('canvas');
        this.millCanvas.id = 'mill-canvas';
        this.millCanvas.style.width = '100%';
        this.millCanvas.style.height = '100%';
        this.millCanvas.style.display = 'block';
        canvasContainer.appendChild(this.millCanvas);
        this.millUI.appendChild(canvasContainer);
        
        // Create bottom toolbar
        const toolbar = document.createElement('div');
        toolbar.style.position = 'absolute';
        toolbar.style.bottom = '0';
        toolbar.style.left = '0';
        toolbar.style.right = '0';
        toolbar.style.height = '80px';
        toolbar.style.background = 'white';
        toolbar.style.borderTop = '1px solid #ddd';
        toolbar.style.display = 'flex';
        toolbar.style.alignItems = 'center';
        toolbar.style.padding = '0 20px';
        toolbar.style.gap = '20px';
        
        // Add instructions
        const instructions = document.createElement('div');
        instructions.style.flex = '1';
        instructions.style.color = '#666';
        const kerfInInches = (this.kerfWidth / 2.54).toFixed(3);
        instructions.innerHTML = '<strong>Instructions:</strong> Right-click to enter perspective mode for manipulation. Press T to return to top view. ' +
                                'Drag turntable to rotate laser. Position lumber under laser. Kerf: ' + kerfInInches + ' inch.';
        toolbar.appendChild(instructions);
        
        // Add execute button
        const executeBtn = document.createElement('button');
        executeBtn.textContent = 'Execute Cut';
        executeBtn.style.padding = '12px 24px';
        executeBtn.style.background = '#27ae60';
        executeBtn.style.color = 'white';
        executeBtn.style.border = 'none';
        executeBtn.style.borderRadius = '4px';
        executeBtn.style.cursor = 'pointer';
        executeBtn.style.fontWeight = 'bold';
        executeBtn.style.fontSize = '16px';
        executeBtn.addEventListener('click', () => this.executeCut());
        toolbar.appendChild(executeBtn);
        
        this.millUI.appendChild(toolbar);
        
        // Add to document
        document.body.appendChild(this.millUI);
        
        // Create UI controls after UI is in DOM
        this.createTransformButtons();
        this.createBevelControl();
    }
    
    // Setup the 2D Babylon scene
    setupMillScene() {
        // Create new engine for mill canvas
        const millEngine = new BABYLON.Engine(this.millCanvas, true);
        
        // Create scene
        this.millScene = new BABYLON.Scene(millEngine);
        this.millScene.clearColor = new BABYLON.Color3(0.98, 0.98, 0.98);
        // Create blade EARLY before physics
        this.blade = BABYLON.MeshBuilder.CreateBox('blade', {
            width: 200,
            height: 12,     // Full 12 inch height
            depth: 0.0078125  // 1/128 inch kerf - very thin realistic kerf
        }, this.millScene);
        this.blade.position.y = 0;  // Center at Y=0 so blade extends -6 to +6
        this.blade.position.z = 0;
        const bladeMat = new BABYLON.StandardMaterial('bladeMat', this.millScene);
        bladeMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.8);
        bladeMat.alpha = 0.7;  // Semi-transparent to see through board
        bladeMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);  // Less shine
        this.blade.material = bladeMat;
        this.blade.renderingGroupId = 1;  // Same layer as board for proper depth
        
        // Set pivot at left edge where blade intersects table (Y=0)
        // Blade is 200 wide, so left edge is at X=-100
        // Pivot must be at (-100, 0, 0) - left edge at table surface
        this.blade.setPivotMatrix(BABYLON.Matrix.Translation(-100, 0, 0));
        this.blade.position.x = -100;  // Compensate for pivot offset
        
        console.log('Blade created with pivot at left edge/table intersection');
        
        
        // Create ArcRotateCamera and FORCE it to top-down view
        this.millCamera = new BABYLON.ArcRotateCamera('millCamera',
            -Math.PI / 2,   // Alpha: -90 degrees
            0,              // Beta: 0 = looking straight down Y axis
            100,            // Radius: distance from target
            BABYLON.Vector3.Zero(),
            this.millScene
        );
        
        // CRITICAL: Force beta to 0 for true top-down view
        this.millCamera.beta = 0;
        
        // Start in orthographic mode for top-down view
        this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        
        // Set initial orthographic bounds for proper aspect ratio
        const aspectRatio = this.millCanvas.width / this.millCanvas.height;
        const orthoSize = 150; // Initial view size
        this.millCamera.orthoLeft = -orthoSize * aspectRatio;
        this.millCamera.orthoRight = orthoSize * aspectRatio;
        this.millCamera.orthoTop = orthoSize;
        this.millCamera.orthoBottom = -orthoSize;
        
        // Set clipping planes to ensure board visibility
        this.millCamera.minZ = 0.1;
        this.millCamera.maxZ = 1000;
        
        // Attach camera to canvas
        this.millCamera.attachControl(this.millCanvas, false);
        
        // Immediately detach default controls since we use manual
        this.millCamera.detachControl();
        
        // Don't attach default controls since we're using manual controls
        
        // Manual camera state tracking
        this.cameraState = {
            isPanning: false,
            isRotating: false,
            lastX: 0,
            lastY: 0
        };
        
        // Set up manual mouse controls to match drawing world
        this.setupManualCameraControls(); // Manual controls already set up inline
        // Keyboard shortcut to return to top-down ortho view (T key)
        window.addEventListener('keydown', (e) => {
            if (e.key === 't' || e.key === 'T') {
                // Return to top-down orthographic view
                this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
                this.currentViewMode = 'top';
                
                // Show rotation control, hide bevel control
                const rotationControl = document.getElementById('mill-rotation-control');
                const bevelControl = document.getElementById('mill-bevel-control');
                if (rotationControl) rotationControl.style.display = 'block';
                if (bevelControl) bevelControl.style.display = 'none';
                
                // Reset camera to top-down position
                this.millCamera.alpha = -Math.PI / 2;
                this.millCamera.beta = 0;
                
                // Re-frame the current board or pieces to 90% of viewport
                if (this.currentBoard) {
                    this.frameBoard(this.currentBoard);
                } else if (this.cutPieces && this.cutPieces.length > 0) {
                    // Frame all pieces together
                    let minX = Infinity, maxX = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    this.cutPieces.forEach(piece => {
                        piece.computeWorldMatrix(true);
                        const bounds = piece.getBoundingInfo().boundingBox;
                        minX = Math.min(minX, bounds.minimumWorld.x);
                        maxX = Math.max(maxX, bounds.maximumWorld.x);
                        minZ = Math.min(minZ, bounds.minimumWorld.z);
                        maxZ = Math.max(maxZ, bounds.maximumWorld.z);
                    });
                    const sizeX = maxX - minX;
                    const sizeZ = maxZ - minZ;
                    const maxSize = Math.max(sizeX, sizeZ);
                    const paddedSize = maxSize * 1.11;  // 90% fill
                    const aspectRatio = this.millCanvas.width / this.millCanvas.height;
                    this.millCamera.orthoLeft = -paddedSize * aspectRatio / 2;
                    this.millCamera.orthoRight = paddedSize * aspectRatio / 2;
                    this.millCamera.orthoTop = paddedSize / 2;
                    this.millCamera.orthoBottom = -paddedSize / 2;
                    this.millCamera.target = new BABYLON.Vector3((minX+maxX)/2, 0, (minZ+maxZ)/2);
            } else if (e.key === 'b' || e.key === 'B') {
                // Switch to blade profile view
                this.switchToBladeProfileView();
                this.currentViewMode = 'side';
                
                // Hide rotation control, show bevel control
                const rotationControl = document.getElementById('mill-rotation-control');
                const bevelControl = document.getElementById('mill-bevel-control');
                if (rotationControl) rotationControl.style.display = 'none';
                if (bevelControl) bevelControl.style.display = 'block';
                
                console.log('Switched to blade-eye view');
            }
        
        // FORCE camera to exact top-down position AFTER everything else
        this.millCamera.position = new BABYLON.Vector3(0, 100, 0.01);
        this.millCamera.setTarget(new BABYLON.Vector3(0, 0, 0));
        
        // Force a render to ensure camera is properly positioned
        this.millScene.render();
        
        // ABSOLUTE FINAL OVERRIDE: Force true top-down view
        this.millCamera.beta = 0;
        this.millCamera.alpha = -Math.PI / 2;
        this.millCamera.rebuildAnglesAndRadius();
        
        // Double-check camera is vertical

        this.millScene.render();
        
        // Camera configuration for UniversalCamera
        // (UniversalCamera doesn't need radius/beta limits)
        
        // Allow switching between ortho and perspective
        this.setupCameraControls();
        
        // Set orthographic size based on material
        const bounds = this.currentMaterial.getBoundingInfo().boundingBox;
        const boardLength = bounds.maximum.x - bounds.minimum.x;
        const boardWidth = bounds.maximum.z - bounds.minimum.z;
        const maxDim = Math.max(boardLength, boardWidth) * 1.5; // Add 50% padding for better view
        
        // Set orthographic bounds to fit board with padding
        this.millCamera.orthoLeft = -maxDim / 2;
        this.millCamera.orthoRight = maxDim / 2;
        this.millCamera.orthoTop = maxDim / 2;
        this.millCamera.orthoBottom = -maxDim / 2;
        
        // Create angled light to reduce direct reflection
        const light = new BABYLON.HemisphericLight('millLight', 
            new BABYLON.Vector3(0.5, 1, 0.5), this.millScene);
        light.intensity = 1.0;
        light.specular = new BABYLON.Color3(0.2, 0.2, 0.2); // Reduce specular
        
        // Clone material mesh to mill scene - create a box with same dimensions
        console.log('Creating material in Mill scene:', this.currentMaterial.name);
        
        // Get dimensions from the original mesh
        const boardThickness = bounds.maximum.y - bounds.minimum.y;
        
        console.log('Board dimensions:', { 
            length: boardLength, 
            thickness: boardThickness, 
            width: boardWidth 
        });
        
        // Create a FLAT board in the Mill scene
        const materialClone = BABYLON.MeshBuilder.CreateBox('millMaterial', {
            width: boardLength,     // X: length of board
            height: boardThickness, // Y: thickness (small)
            depth: boardWidth,      // Z: width of board
            wrap: true
        }, this.millScene);
        
        // Position at origin, flat on table
        materialClone.position = new BABYLON.Vector3(0, boardThickness / 2, 0); // Position board ON TOP of grid
        materialClone.rotation = new BABYLON.Vector3(0, 0, 0);
        
        // Create a material with texture for visualization
        const mat = new BABYLON.StandardMaterial('millMat', this.millScene);
        
        // Try to copy the texture from the original material
        if (this.currentMaterial.material && this.currentMaterial.material.diffuseTexture) {
            // Clone the texture to the new scene
            const originalTexture = this.currentMaterial.material.diffuseTexture;
            if (originalTexture && originalTexture.url) {
                console.log('Copying texture from original:', originalTexture.url);
                const texture = new BABYLON.Texture(originalTexture.url, this.millScene);
                
                // Copy texture properties
                texture.uScale = originalTexture.uScale || 1;
                texture.vScale = originalTexture.vScale || 1;
                texture.hasAlpha = originalTexture.hasAlpha || false;
                
                mat.diffuseTexture = texture;
            }
        }
        
        // Also try to copy the color
        if (this.currentMaterial.material && this.currentMaterial.material.diffuseColor) {
            mat.diffuseColor = this.currentMaterial.material.diffuseColor.clone();
        } else if (!mat.diffuseTexture) {
            // Only use default color if no texture was found
            mat.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
        }
        
        // Set material properties for wood-like appearance
        mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        mat.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        materialClone.material = mat;
        
        // Make sure it's visible and pickable
        materialClone.isVisible = true;
        materialClone.isPickable = true;
        materialClone.renderingGroupId = 1;  // Middle rendering group
        
        console.log('Material created in Mill:', materialClone);
        
        
        // Store the board reference
        this.currentBoard = materialClone;

        // Blade already created earlier
        
        
        
        // Make blade rotate with turntable
        this.updateBladeRotation = () => {
            if (this.blade) {
                this.blade.rotation.y = this.bladeAngle || 0;
                // Apply bevel if set
                if (Math.abs(this.bevelAngle - 90) > 0.1) {
                    const bevelRadians = (90 - this.bevelAngle) * Math.PI / 180;
                    this.blade.rotation.x = -bevelRadians * this.bevelDirection;
                }
            }
        };

        this.currentBoard.isPickable = true; // Ensure board is pickable for dragging
        
        // Force board to render in all camera modes
        this.currentBoard.alwaysSelectAsActiveMesh = true;
        // Fix for orthographic rendering
        this.currentBoard.material.backFaceCulling = false;
        this.currentBoard.material.needDepthPrePass = true;
        this.currentBoard.layerMask = 0x0FFFFFFF; // All layers
        // Add transform gizmos for the lumber
        this.setupGizmos(materialClone);
        
        // Store board reference for camera framing
        this.boardMesh = materialClone;
        
        // Frame the board in view
        this.frameBoard(materialClone);
        
        // Create blade visualization
        // Blade visualization removed - using single blade in CSG
        this.updateBladeTilt(); // Set initial angle
        
        // Add grid for reference
        this.createGrid();
        // Create transform toolbar (no perma-gizmos)
        this.createTransformToolbar();
        
        

        
        // Setup cutting line
        this.setupTurntableAndLaser();
        
        // Force perfect orthographic top-down view
        const forceTopDownView = () => {
            this.millCamera.beta = 0;
            this.millCamera.alpha = -Math.PI / 2;
            this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            
            // Force update the projection matrix
            this.millCamera.getProjectionMatrix(true);
            this.millScene.render();
        };
        
        // Apply it immediately
        forceTopDownView();
        
        // Apply it after a short delay to override any async operations
        setTimeout(forceTopDownView, 100);
        
        // Add ViewCube for navigation
        this.setupViewCube(millEngine);
        
        // Force camera to top-down before starting render
        this.millCamera.beta = 0;  // FORCE top-down
        this.millCamera.alpha = -Math.PI / 2;
        
        // Start render loop
        millEngine.runRenderLoop(() => {
            // Maintain camera angle based on current view mode
            if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA && !this.cameraState.isRotating) {
                if (this.currentViewMode === 'top') {
                    this.millCamera.beta = 0; // Force top-down
                } else if (this.currentViewMode === 'side') {
                    this.millCamera.beta = Math.PI / 2; // Force horizontal
                }
            }
            this.millScene.render();
        });
        
        // Handle resize
        window.addEventListener('resize', () => {
            millEngine.resize();
        });
        }
    

    updateAngleDisplay(degrees) {
        // Update HUD display
        if (this.hudAngleDisplay) {
            this.hudAngleDisplay.textContent = degrees.toFixed(1) + '';
        }
    }
    
    
    
    // Setup event listeners for cutting
    setupCameraControls() {
        // Set up pointer event handling for camera mode switching
        this.millScene.onPointerObservable.add((pointerInfo) => {
            // Handle right-click drag for camera rotation (which switches to perspective)
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && 
                pointerInfo.event.button === 2) {
                // Right-click switches to perspective mode for rotation
                if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                    // Calculate radius from ortho bounds to maintain zoom
                    const orthoSize = Math.abs(this.millCamera.orthoRight - this.millCamera.orthoLeft);
                    this.millCamera.radius = orthoSize * 0.7; // Adjust factor for similar view
                    
                    this.millCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                    // Enable rotation gizmo in perspective
                    if (this.gizmoManager) {
                        this.gizmoManager.rotationGizmoEnabled = true;
                    }
                    console.log('Switched to perspective mode for camera rotation');
                }
            }
        });
    }
    
    setupManualCameraControls() {
        // Mouse down
        this.millCanvas.addEventListener('pointerdown', (e) => {
            
            // B view board dragging (left mouse button)
            if (this.enableBViewDragging && e.button === 0 && this.currentBoard) {
                this.isDraggingBoard = true;
                this.lastMouseX = e.clientX;
                e.preventDefault();
                return;
            }
            
            if (e.button === 1) {
                // Middle mouse - pan
                this.cameraState.isPanning = true;
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
                e.preventDefault();
            } else if (e.button === 2) {
                // Right mouse - rotate (switches to perspective)
                this.cameraState.isRotating = true;
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
                
                // Switch to perspective mode when starting rotation
                if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                    const orthoSize = Math.abs(this.millCamera.orthoRight - this.millCamera.orthoLeft);
                    this.millCamera.radius = orthoSize * 0.7;
                    this.millCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                }
                e.preventDefault();
            }
        });
        
        // Mouse move
        this.millCanvas.addEventListener('pointermove', (e) => {
            // B view board dragging - check FIRST before other conditions
            if (this.isDraggingBoard && this.currentBoard) {
                const deltaX = e.clientX - this.lastMouseX;
                // In B view, move along Z axis (forward/backward relative to blade)
                this.currentBoard.position.z -= deltaX * 0.05;  // Negative for correct direction
                this.lastMouseX = e.clientX;
                return;
            }
            
            if (this.cameraState.isPanning) {
                const deltaX = e.clientX - this.cameraState.lastX;
                const deltaY = e.clientY - this.cameraState.lastY;
                
                if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                    // Ortho pan - move the ortho bounds
                    const panSpeed = Math.abs(this.millCamera.orthoRight - this.millCamera.orthoLeft) * 0.001;
                    const panX = -deltaX * panSpeed;
                    const panY = deltaY * panSpeed;
                    
                    this.millCamera.target.x += panX;
                    this.millCamera.target.z += panY;
                } else {
                    // Perspective pan
                    const panSpeed = this.millCamera.radius * 0.001;
                    const forward = this.millCamera.getDirection(BABYLON.Vector3.Forward());
                    const right = BABYLON.Vector3.Cross(forward, BABYLON.Vector3.Up());
                    const up = BABYLON.Vector3.Cross(right, forward);
                    
                    const panVector = right.scale(-deltaX * panSpeed).add(up.scale(deltaY * panSpeed));
                    this.millCamera.target.addInPlace(panVector);
                }
                
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
            } else if (this.cameraState.isRotating) {
                const deltaX = e.clientX - this.cameraState.lastX;
                const deltaY = e.clientY - this.cameraState.lastY;
                
                this.millCamera.alpha += deltaX * 0.01;
                this.millCamera.beta -= deltaY * 0.01;
                this.millCamera.beta = Math.max(0, Math.min(Math.PI / 2 - 0.01, this.millCamera.beta));
                
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
            }
        });
        
        // Mouse up
        this.millCanvas.addEventListener('pointerup', (e) => {
            this.cameraState.isPanning = false;
            this.cameraState.isRotating = false;
            // Stop B view dragging
            if (this.isDraggingBoard) {
                this.isDraggingBoard = false;
            }
        });
        
        // Mouse wheel - zoom
        this.millCanvas.addEventListener('wheel', (e) => {
            const zoomSensitivity = window.userPreferences?.zoomSensitivity || 0.00005; // Very slow for precise control
            const delta = e.deltaY * zoomSensitivity;
            if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                // Orthographic zoom - adjust ortho bounds
                const zoomFactor = 1 + delta;
                this.millCamera.orthoLeft *= zoomFactor;
                this.millCamera.orthoRight *= zoomFactor;
                this.millCamera.orthoTop *= zoomFactor;
                this.millCamera.orthoBottom *= zoomFactor;
            } else {
                // Perspective zoom - adjust radius
                const zoomSpeed = this.drawingWorld.preferences.zoomSpeed || 0.5;
                this.millCamera.radius *= (1 + delta * zoomSpeed);
                this.millCamera.radius = Math.max(10, Math.min(1000, this.millCamera.radius));
            }
            
            e.preventDefault();
        });
    }
    
        setupEventListeners() {
        this.millCanvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.millCanvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.millCanvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
    }
    
    // Mouse down - handle based on button
    onMouseDown(e) {
        console.log('Mouse down event');
        
        console.log("onMouseDown called, button:", e.button);
        // Check for B view board dragging
        if (this.enableBViewDragging && e.button === 0 && this.currentBoard) { // Left click
            console.log("Starting B view drag");
            console.log("B view drag check - enabled:", this.enableBViewDragging, "button:", e.button, "board:", !!this.currentBoard);
            this.lastMouseX = e.clientX;
            e.preventDefault();
            return;
        }
        
        const pickResult = this.millScene.pick(e.clientX, e.clientY);
        if (pickResult.hit) {
            console.log('Clicked on mesh:', pickResult.pickedMesh.name);
        } else {
            console.log('No mesh clicked');
        }
        console.log('Pick result:', pickResult.hit ? pickResult.pickedMesh.name : 'no hit');
        
        if (!pickResult.hit) return;
        
        // Check if clicking on lumber first (priority over turntable)
        if (pickResult.pickedMesh.name === 'millMaterial') {
            // Let gizmo handle the lumber
            console.log('Clicked on lumber - gizmo will handle movement');
            return;
        }
        
        // Check if clicking on turntable (only with left button)
        console.log('Checking if mesh is turntable:', pickResult.pickedMesh.name === 'turntable');
        if (pickResult.pickedMesh.name === 'turntable') {
            this.isDraggingTurntable = true;
            console.log('Started dragging turntable');
            
            // Calculate starting angle from click position
            const clickPoint = pickResult.pickedPoint;
            this.dragStartAngle = Math.atan2(clickPoint.z, clickPoint.x);
            
            console.log('Started dragging turntable for rotation');
        }
    }
    
    // Mouse move - rotate turntable and laser if dragging
    onMouseMove(e) {
        // Mouse move logging removed
        if (!this.isDraggingTurntable) return;
        
        // Handle B view board dragging (left/right only)
        if (this.enableBViewDragging && this.isDraggingBoard && this.currentBoard) {
            const deltaX = e.clientX - this.lastMouseX;
            console.log("B view drag move, deltaX:", deltaX);
            this.currentBoard.position.x += deltaX * 0.5; // Scale movement
            this.lastMouseX = e.clientX;
            return;
        }
        
        const pickResult = this.millScene.pick(e.clientX, e.clientY);
        console.log('Pick result:', pickResult.hit ? pickResult.pickedMesh.name : 'no hit');
        
        if (pickResult.hit) {
            const currentPoint = pickResult.pickedPoint;
            const currentAngle = Math.atan2(currentPoint.z, currentPoint.x);
            
            // Calculate angle difference
            const angleDiff = currentAngle - this.dragStartAngle;
            this.bladeAngle += angleDiff;
            
            // Rotate the laser line
            if (this.laserTube) {
                this.laserTube.rotation.y = this.bladeAngle;
            }
            if (this.laserLine) {
                this.laserLine.rotation.y = this.bladeAngle;
            }
            // Force blade rotation using different methods
            if (this.blade) {
                console.log('Attempting blade rotation to:', (this.bladeAngle * 180 / Math.PI).toFixed(1), 'degrees');
                
                // Method 1: Direct rotation
                this.blade.rotation.y = this.bladeAngle;
                
                // Method 2: Force compute world matrix
                this.blade.computeWorldMatrix(true);
                
                // Method 3: Try rotating around Y axis
                this.blade.rotate(BABYLON.Axis.Y, this.bladeAngle - (this.blade.rotation.y || 0), BABYLON.Space.LOCAL);
                
                // Check if it actually rotated
                console.log('Blade rotation after all attempts:', this.blade.rotation.y);
                
                // Check if blade is frozen
                if (this.blade.rotationQuaternion) {
                    console.log('WARNING: Blade has quaternion rotation!');
                    this.blade.rotationQuaternion = null;
                }
            }
            

            
            // Update start angle for next frame
            this.dragStartAngle = currentAngle;
            
            // Show angle in degrees for user feedback
            const degrees = (this.bladeAngle * 180 / Math.PI) % 360;
            console.log('Blade angle:', degrees.toFixed(1) + '');
        }
    }
    
    // Mouse up - stop dragging turntable
    onMouseUp(e) {
        if (this.isDraggingTurntable) {
        
        // Stop B view board dragging
        if (this.isDraggingBoard) {
            this.isDraggingBoard = false;
        }
            this.isDraggingTurntable = false;
            console.log('Stopped dragging turntable');
        }
    }
    
    // Execute the cut
    createGrid() {
        const gridSize = 500; // 500cm (5 meter) grid - standard plywood is 244cm
        const gridStep = 10; // 10cm steps
        const gridLines = [];
        
        for (let i = -gridSize/2; i <= gridSize/2; i += gridStep) {
            // Vertical lines
            gridLines.push([
                new BABYLON.Vector3(i, 0, -gridSize/2),
                new BABYLON.Vector3(i, 0, gridSize/2)
            ]);
            
            // Horizontal lines
            gridLines.push([
                new BABYLON.Vector3(-gridSize/2, 0, i),
                new BABYLON.Vector3(gridSize/2, 0, i)
            ]);
        }
        
        // Create grid mesh
        const gridSystem = BABYLON.MeshBuilder.CreateLineSystem('grid', {
            lines: gridLines
        }, this.millScene);
        
        gridSystem.color = new BABYLON.Color3(0.92, 0.92, 0.92);  // Extremely light grey
        gridSystem.renderingGroupId = 0; // Render below everything
        
        // Create table surface below grid for tablesaw bench appearance
        const tableSurface = BABYLON.MeshBuilder.CreateBox("tableSurface", {
            width: gridSize,
            height: 5, // 5cm (2 inch) thick table for realistic profile
            depth: gridSize
        }, this.millScene);
        
        tableSurface.position = new BABYLON.Vector3(0, -2.5, 0); // Center of 5cm thick table
        
        const tableMat = new BABYLON.StandardMaterial("tableMat", this.millScene);
        tableMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4); // Dark grey
        tableMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Low shine
        tableSurface.material = tableMat;
        tableMat.backFaceCulling = false; // Fix for orthographic rendering
        tableMat.needDepthPrePass = true;
        tableSurface.renderingGroupId = 0; // Render with grid
        tableSurface.isVisible = false; // Hidden by default (top view)
        this.tableSurface = tableSurface; // Store reference for B view
    }
    
    setupGizmos(mesh) {
        
        this.gizmoManager = new BABYLON.GizmoManager(this.millScene);
        this.gizmoManager.positionGizmoEnabled = false;
        this.gizmoManager.rotationGizmoEnabled = false;
        this.gizmoManager.scaleGizmoEnabled = false;
        this.gizmoManager.boundingBoxGizmoEnabled = false;
        this.gizmoManager.attachableMeshes = [mesh];
        
        // Store current transform mode
        this.currentTransformMode = null;
        this.currentViewMode = "top"; // "top" or "side"
        this.bevelAngle = 90; // Default 90 degrees (straight cut)
        this.bevelDirection = 1; // Default direction (positive/right)
        this.bevelDirection = 1; // 1 = right, -1 = left
        this.bladeVisual = null;
        this.cuttingPlane = null;
        this.bevelDirection = 1; // 1 = right, -1 = left
        this.bladeVisual = null;
        this.cuttingPlane = null;
    }
    
    createTransformButtons() {
        // Create container for transform buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.id = 'mill-transform-buttons';
        buttonContainer.style.position = 'absolute';
        buttonContainer.style.top = '20px';
        buttonContainer.style.left = '50%';
        buttonContainer.style.transform = 'translateX(-50%)';
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '10px';
        buttonContainer.style.zIndex = '1000';
        buttonContainer.style.backgroundColor = 'rgba(40, 40, 40, 0.9)';
        buttonContainer.style.padding = '10px';
        buttonContainer.style.borderRadius = '8px';
        buttonContainer.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
        
        // Move button
        const moveBtn = this.createTransformButton('', 'Move', 'position');
        const rotateBtn = this.createTransformButton('', 'Rotate', 'rotation');
        const scaleBtn = this.createTransformButton('', 'Scale', 'scale');
        const noneBtn = this.createTransformButton('', 'None', null);
        
        // Store button references
        this.transformButtons = {
            position: moveBtn,
            rotation: rotateBtn,
            scale: scaleBtn,
            none: noneBtn
        };
        
        buttonContainer.appendChild(noneBtn);
        buttonContainer.appendChild(moveBtn);
        buttonContainer.appendChild(rotateBtn);
        buttonContainer.appendChild(scaleBtn);
        
        document.getElementById('mill-container').appendChild(buttonContainer);
    }
    
    createTransformButton(icon, title, mode) {
        const btn = document.createElement('button');
        btn.innerHTML = icon;
        btn.title = title;
        btn.style.width = '50px';
        btn.style.height = '50px';
        btn.style.border = 'none';
        btn.style.borderRadius = '4px';
        btn.style.backgroundColor = '#555';
        btn.style.color = '#fff';
        btn.style.fontSize = '20px';
        btn.style.cursor = 'pointer';
        btn.style.transition = 'all 0.2s';
        
        btn.onclick = () => this.setTransformMode(mode);
        
        btn.onmouseover = () => {
            if (!btn.classList.contains('active')) {
                btn.style.backgroundColor = '#666';
            }
        };
        
        btn.onmouseout = () => {
            if (!btn.classList.contains('active')) {
                btn.style.backgroundColor = '#555';
            }
        };
        
        return btn;
    }
    
    setTransformMode(mode) {
        // Reset all buttons
        Object.values(this.transformButtons).forEach(btn => {
            btn.style.backgroundColor = '#555';
            btn.classList.remove('active');
        });
        
        // Disable all gizmos
        if (this.gizmoManager) {
            this.gizmoManager.positionGizmoEnabled = false;
            this.gizmoManager.rotationGizmoEnabled = false;
            this.gizmoManager.scaleGizmoEnabled = false;
            
            // Enable selected mode
            if (mode === 'position') {
                this.gizmoManager.positionGizmoEnabled = true;
                this.transformButtons.position.style.backgroundColor = '#2196F3';
                this.transformButtons.position.classList.add('active');
            } else if (mode === 'rotation') {
                this.gizmoManager.rotationGizmoEnabled = true;
                this.transformButtons.rotation.style.backgroundColor = '#4CAF50';
                this.transformButtons.rotation.classList.add('active');
            } else if (mode === 'scale') {
                this.gizmoManager.scaleGizmoEnabled = true;
                this.transformButtons.scale.style.backgroundColor = '#FF9800';
                this.transformButtons.scale.classList.add('active');
            } else {
                // None mode
                this.transformButtons.none.style.backgroundColor = '#f44336';
                this.transformButtons.none.classList.add('active');
            }
            
            this.currentTransformMode = mode;
        }
    }

    setupViewCube(engine) {
        // ViewCube will be set up if needed
        // Currently using built-in camera controls
    }
    
        setupTurntableAndLaser() {
        // Create parent transform node for laser assembly
        this.laserAssembly = new BABYLON.TransformNode('laserAssembly', this.millScene);
        
        // Create work table (light grey surface)
        const tableRadius = 200;  // Large work surface
        this.workTable = BABYLON.MeshBuilder.CreateDisc('workTable', {
            radius: tableRadius,
            tessellation: 64
        }, this.millScene);
        
        this.workTable.position.y = 0.01; // Slightly above grid
        this.workTable.rotation.x = Math.PI / 2; // Rotate disc to horizontal plane
        this.workTable.isPickable = false;
        
        const tableMat = new BABYLON.StandardMaterial('tableMat', this.millScene);
        tableMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);  // Light grey
        tableMat.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
        tableMat.alpha = 0.3; // Semi-transparent to see grid
        this.workTable.material = tableMat;
        
        // Create laser line - thin red line extending across entire grid
        const laserPoints = [
            new BABYLON.Vector3(-250, 0.02, 0),  // Extend to grid edge
            new BABYLON.Vector3(250, 0.02, 0)    // Extend to opposite grid edge
        ];
        
        this.laserLine = BABYLON.MeshBuilder.CreateLines('laserLine', {
            points: laserPoints
        }, this.millScene);
        
        // Parent laser to assembly for rotation
        this.laserLine.parent = this.laserAssembly;
        
        // Create laser material
        this.laserLine.color = new BABYLON.Color3(1, 0, 0); // Bright red
        this.laserLine.renderingGroupId = 2; // Render on top
        
        // Create corner rotation control
        this.createRotationControl();
        
        // Setup rotation interaction
        this.setupRotationControl();
    }
    
    createRotationControl() {
        // Create HTML/CSS rotation control in corner
        const control = document.createElement('div');
        control.id = 'mill-rotation-control';
        control.style.position = 'absolute';
        control.style.bottom = '150px';  // Above ViewCube
        control.style.left = '10px';
        control.style.width = '360px';
        control.style.height = '360px';
        control.style.borderRadius = '50%';
        control.style.backgroundColor = 'rgba(40, 40, 40, 0.9)';
        control.style.border = '2px solid #666';
        control.style.cursor = 'grab';
        control.style.userSelect = 'none';
        control.style.display = 'flex';
        control.style.alignItems = 'center';
        control.style.justifyContent = 'center';
        control.style.zIndex = '999';
        
        // Create inner dial with degree markings
        const dial = document.createElement('div');
        dial.style.position = 'relative';
        dial.style.width = '100%';
        dial.style.height = '100%';
        dial.style.borderRadius = '50%';
        dial.id = 'rotationDial';
        
        // Add degree markings
        for (let angle = 0; angle < 360; angle += 30) {
            const mark = document.createElement('div');
            mark.style.position = 'absolute';
            mark.style.width = '2px';
            mark.style.height = '20px';
            mark.style.backgroundColor = '#888';
            mark.style.left = '50%';
            mark.style.top = '5px';
            mark.style.transformOrigin = '1px 175px';
            mark.style.transform = 'rotate(' + angle + 'deg)';
            dial.appendChild(mark);
            
            // Add numbers for major angles
            if (angle % 90 === 0) {
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.fontSize = '24px';
                label.style.fontWeight = 'bold';
                label.style.color = '#fff';
                label.style.fontFamily = 'Helvetica, Arial, sans-serif';
                label.textContent = angle.toString();
                
                // Position labels (0 at right/East)
                const rad = angle * Math.PI / 180;
                const x = 50 + Math.cos(rad) * 35;
                const y = 50 + Math.sin(rad) * 35;
                label.style.left = x + '%';
                label.style.top = y + '%';
                label.style.transform = 'translate(-50%, -50%)';
                dial.appendChild(label);
            }
        }
        
        // Add center display
        const centerDisplay = document.createElement('div');
        centerDisplay.id = 'angleDisplay';
        centerDisplay.style.position = 'absolute';
        centerDisplay.style.top = '50%';
        centerDisplay.style.left = '50%';
        centerDisplay.style.transform = 'translate(-50%, -50%)';
        centerDisplay.style.fontSize = '36px';
        centerDisplay.style.fontWeight = 'bold';
        centerDisplay.style.color = '#ff9933';
        centerDisplay.style.fontFamily = 'Helvetica, Arial, sans-serif';
        centerDisplay.textContent = '0';
        dial.appendChild(centerDisplay);
        
        // Add indicator needle/arrow
        const indicator = document.createElement('div');
        indicator.style.position = 'absolute';
        indicator.style.width = '50%';  // From center to edge
        indicator.style.height = '3px';  // Thickness of needle
        indicator.style.backgroundColor = '#ff9933';
        indicator.style.left = '50%';
        indicator.style.top = '50%';
        indicator.style.transformOrigin = 'left center';  // Rotate from left end (center of dial)
        indicator.style.transform = 'translateY(-50%) rotate(0deg)';  // Start pointing right (0 degrees)
        indicator.id = 'rotationIndicator';
        
        // Add arrow head at the end
        const arrowHead = document.createElement('div');
        arrowHead.style.position = 'absolute';
        arrowHead.style.width = '0';
        arrowHead.style.height = '0';
        arrowHead.style.borderTop = '8px solid transparent';
        arrowHead.style.borderBottom = '8px solid transparent';
        arrowHead.style.borderLeft = '12px solid #ff9933';
        arrowHead.style.right = '-12px';
        arrowHead.style.top = '50%';
        arrowHead.style.transform = 'translateY(-50%)';
        indicator.appendChild(arrowHead);
        dial.appendChild(indicator);
        
        control.appendChild(dial);
        
        // Add to Mill UI
        if (this.millUI) {
            this.millUI.appendChild(control);
        }
        
        this.rotationControl = control;
        this.rotationDial = dial;
        this.angleDisplay = centerDisplay;
        this.rotationIndicator = indicator;
    }
    
    setupRotationControl() {
        if (!this.rotationControl) return;
        
        let isDragging = false;
        let startAngle = 0;
        let currentRotation = 0;
        
        const getAngleFromMouse = (e, rect) => {
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;
            return Math.atan2(dy, dx) * 180 / Math.PI;  // 0 at right
        };
        
        this.rotationControl.addEventListener('mousedown', (e) => {
            isDragging = true;
            this.rotationControl.style.cursor = 'grabbing';
            const rect = this.rotationControl.getBoundingClientRect();
            startAngle = getAngleFromMouse(e, rect) - currentRotation;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = this.rotationControl.getBoundingClientRect();
            const angle = getAngleFromMouse(e, rect);
            currentRotation = angle - startAngle;
            
            // Normalize to 0-360
            while (currentRotation < 0) currentRotation += 360;
            while (currentRotation >= 360) currentRotation -= 360;
            
            // Update indicator rotation
            this.rotationIndicator.style.transform = 'translateY(-50%) rotate(' + currentRotation + 'deg)';
            
            // Update angle display
            this.angleDisplay.textContent = Math.round(currentRotation) + '';
            
            // Rotate the laser
            if (this.laserAssembly) {
                this.laserAssembly.rotation.y = currentRotation * Math.PI / 180;
            if (this.blade) this.blade.rotation.y = currentRotation * Math.PI / 180;  // Natural direction
            }
            
            // Update HUD if exists
            if (this.hudAngleDisplay) {
                this.hudAngleDisplay.textContent = Math.round(currentRotation) + '';
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                this.rotationControl.style.cursor = 'grab';
            }
        });
    }
    
        executeCut() {
        const miterAngleDegrees = (this.bladeAngle * 180 / Math.PI) % 360;
        console.log('Executing cut with miter:', miterAngleDegrees, 'bevel:', this.bevelAngle);
        
        // Use BABYLON.CSG for proper boolean operations
        if (BABYLON.CSG) {
            console.log('Using CSG for cutting');
            this.executeCSGCut();
        } else {
            console.warn('CSG not available, using simple cut');
            this.executeSimpleCut();
        }
    }
    
    updateBladeTilt() {
        if (!this.blade) {
            return;
        }
        
        // Apply bevel angle to blade
        const tiltRadians = (90 - this.bevelAngle) * Math.PI / 180;
        const direction = this.bevelDirection || 1;
        
        // Tilt the blade on X axis for bevel
        this.blade.rotation.x = -tiltRadians * direction;
    }

    executeCSGCut() {
        const miterAngleDegrees = (this.bladeAngle * 180 / Math.PI) % 360;
        console.log('CSG Cut - Miter:', miterAngleDegrees, 'Bevel:', this.bevelAngle);
        
        // Check for pieces and current board
        if (this.cutPieces && this.cutPieces.length > 0 && !this.currentBoard) {
            alert('Please select a piece to cut by clicking on it.');
            return;
        }
        
        if (!this.currentBoard) {
            alert('No material to cut');
            return;
        }
        
        try {
            // Get board dimensions
            const bounds = this.currentBoard.getBoundingInfo();
            const boardSize = bounds.maximum.subtract(bounds.minimum);
            
            // Create a realistic blade with proper kerf
            const kerfWidth = 3.175; // 1/8 inch kerf (standard table saw blade)
            const bladeRadius = 127; // 10 inch blade (254mm diameter)
            
            // Clone the blade for cutting (don't modify the visible one)
            const blade = this.blade.clone('csgBlade');
            
            // The cloned blade already has the correct position and rotation from visual blade
            // Visual blade is updated by updateBladeRotation() which includes both miter and bevel
            console.log('CSG blade cloned with rotation:', blade.rotation);
            console.log('CSG blade position:', blade.position);
            
            // Keep cloned blade invisible for CSG
            blade.isVisible = false;
            
            console.log('Blade positioned at:', blade.position);
            console.log('Blade rotation:', blade.rotation);
            console.log('Board at:', this.currentBoard.position);
            
            // Make blade visible temporarily to debug
            blade.material = new BABYLON.StandardMaterial('bladeMat', this.millScene);
            blade.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
            blade.material.alpha = 0.5;
            blade.isVisible = true; // Let's see where it actually is
            
            console.log('Blade position:', blade.position);
            console.log('Board position:', this.currentBoard.position);
            console.log('Board bounds:', bounds);
            
            // blade.isVisible = false; // Keep visible for debugging
            
            // Perform a single CSG operation - just subtract the blade
            console.log('Creating CSG from board...');
            const boardCSG = BABYLON.CSG.FromMesh(this.currentBoard);
            
            console.log('Creating CSG from blade...');
            const bladeCSG = BABYLON.CSG.FromMesh(blade);
            
            console.log('Creating two pieces from CSG cut...');
            
            // Create separators to isolate each piece
            // Account for blade's left-edge pivot at X=-100
            const separator1 = BABYLON.MeshBuilder.CreateBox('separator1', {
                width: 500,
                height: 100,
                depth: 500
            }, this.millScene);
            
            // Position separator to right of blade center (blade center is at X=0 when blade.position.x=-100)
            // Since blade is 200 wide with pivot at left edge, blade center is 100 units from pivot
            const bladeCenterOffset = new BABYLON.Vector3(100, 0, 0);
            const rotMatrix = BABYLON.Matrix.RotationY(blade.rotation.y);
            const rotatedCenter = BABYLON.Vector3.TransformCoordinates(bladeCenterOffset, rotMatrix);
            const bladeCenter = blade.position.clone().add(rotatedCenter);
            
            // Now position separators relative to blade center
            const offset1 = new BABYLON.Vector3(0, 0, 250);
            const rotatedOffset1 = BABYLON.Vector3.TransformCoordinates(offset1, rotMatrix);
            separator1.position = bladeCenter.clone().add(rotatedOffset1);
            // Separator1 stays unrotated to cut perpendicular
            
            const separator2 = BABYLON.MeshBuilder.CreateBox('separator2', {
                width: 500,
                height: 100,
                depth: 500
            }, this.millScene);
            
            // Position separator to left of blade center
            const offset2 = new BABYLON.Vector3(0, 0, -250);
            const rotatedOffset2 = BABYLON.Vector3.TransformCoordinates(offset2, rotMatrix);
            separator2.position = bladeCenter.clone().add(rotatedOffset2);
            // Separator2 stays unrotated to cut perpendicular
            
            // Create piece 1 (left side) by subtracting blade and right separator
            const piece1CSG = boardCSG.subtract(bladeCSG).subtract(BABYLON.CSG.FromMesh(separator1));
            const piece1 = piece1CSG.toMesh('piece1', this.currentBoard.material.clone(), this.millScene);
            
            // Create piece 2 (right side) by subtracting blade and left separator
            const piece2CSG = boardCSG.subtract(bladeCSG).subtract(BABYLON.CSG.FromMesh(separator2));
            const piece2 = piece2CSG.toMesh('piece2', this.currentBoard.material.clone(), this.millScene);
            
            // Clean up separators
            separator1.dispose();
            separator2.dispose();
            
            console.log('Two pieces created');
            
            // Position pieces with visible gap
            const separation = 10;
            piece1.position = this.currentBoard.position.clone();
            piece1.position.z -= separation / 2;
            
            piece2.position = this.currentBoard.position.clone();
            piece2.position.z += separation / 2;
            
            // Clean up
            // Delay blade disposal so we can see where the cut happened
            setTimeout(() => {
                if (blade) blade.dispose();
            }, 2000);
            
            // Visual feedback
            this.flashBlade();
            if (piece2) this.showCutAnimation(piece1, piece2);
            
            // Handle piece management
            if (this.cutPieces) {
                const index = this.cutPieces.indexOf(this.currentBoard);
                if (index > -1) {
                    this.cutPieces.splice(index, 1);
                }
            }
            
            // Clean up gizmos
            if (this.gizmoManager) {
                this.gizmoManager.attachToMesh(null);
            }
            
            // Dispose original board
            console.log('Disposing original board:', this.currentBoard.name);
            this.currentBoard.isVisible = false;
            this.currentBoard.dispose();
            this.currentBoard = null;
            console.log('Original board disposed');
            
            // Add new pieces
            if (!this.cutPieces) {
                this.cutPieces = [];
            }
            
            // Ensure pieces are visible
            piece1.isVisible = true;
            piece2.isVisible = true;
            
            this.cutPieces.push(piece1);
            this.cutPieces.push(piece2);
            
            console.log('Added cut pieces:', this.cutPieces.length);
            
            // Make pieces selectable
            this.makePiecesSelectable();
            this.updateSelectionDisplay();
            
            // Show success
            const cutData = {
                miterAngle: miterAngleDegrees,
                bevelAngle: this.bevelAngle,
                bevelDirection: this.bevelDirection,
                kerfWidth: kerfWidth
            };
            
            console.log('CSG cut completed successfully');
            this.showCutSuccess(cutData);
            
        } catch (error) {
            console.error('CSG cut failed:', error);
            console.error('Error details:', error.message);
            console.error('Error stack:', error.stack);
            alert('Cut failed: ' + error.message);
        }
    }
    
    executeSimpleCut() {
        const miterAngleDegrees = (this.bladeAngle * 180 / Math.PI) % 360;
        // If we have cut pieces and one is selected, we can cut it
        // If no board is selected from cut pieces, remind user to select one
        if (this.cutPieces && this.cutPieces.length > 0 && !this.currentBoard) {
            alert('Please select a piece to cut by clicking on it.');
            return;
        }
        
        if (!this.currentBoard) {
            alert('No material to cut');
            return;
        }
        
        // Get board dimensions
        const bounds = this.currentBoard.getBoundingInfo();
        const boardSize = bounds.maximum.subtract(bounds.minimum);
        
        // Calculate where the cut happens (blade position in board's local space)
        const cutPositionZ = this.currentBoard.position.z; // Where the board is positioned relative to blade
        
        // Create two pieces
        let piece1, piece2;
        
        // Calculate where the blade cuts through the board
        const boardCenter = this.currentBoard.position.z;
        const halfBoardLength = boardSize.z / 2;
        
        // Calculate the ratio of where the cut happens along the board
        const cutRatio = (halfBoardLength - boardCenter) / boardSize.z;
        const piece1Ratio = Math.max(0.1, Math.min(0.9, cutRatio)); // Keep between 10% and 90%
        const piece2Ratio = 1 - piece1Ratio;
        
        const piece1Length = boardSize.z * piece1Ratio;
        const piece2Length = boardSize.z * piece2Ratio;
        
        // Clone the board for both pieces
        piece1 = this.currentBoard.clone('piece1');
        piece2 = this.currentBoard.clone('piece2');
        
        // Scale the pieces based on the cut position
        piece1.scaling.z = piece1Ratio;
        piece2.scaling.z = piece2Ratio;
        
        // If bevel angle is not 90 degrees, add visual indicators
        if (Math.abs(this.bevelAngle - 90) > 0.1) {
            this.addBevelIndicator(piece1, boardSize, piece1Length, this.bevelAngle, this.bevelDirection, true);
            this.addBevelIndicator(piece2, boardSize, piece2Length, this.bevelAngle, -this.bevelDirection, false);
        }
        
        // Position pieces with gap at the cut line
        const separation = 5; // mm gap between pieces
        piece1.position.z = -piece1Length/2 - separation/2;
        piece2.position.z = piece2Length/2 + separation/2;
        
        // Apply visual feedback
        this.flashBlade();
        this.showCutAnimation(piece1, piece2);
        
        // Clean up gizmos from original board
        if (this.gizmoManager) {
            this.gizmoManager.attachToMesh(null);
        }
        
        // Remove the original board from cutPieces array if it was a cut piece
        if (this.cutPieces) {
            const index = this.cutPieces.indexOf(this.currentBoard);
            if (index > -1) {
                this.cutPieces.splice(index, 1);
            }
        }
        
        // Hide and dispose original board
        this.currentBoard.isVisible = false;
        this.currentBoard.dispose();
        this.currentBoard = null;
        
        // Add new pieces to cut pieces array (or create new array)
        if (!this.cutPieces) {
            this.cutPieces = [];
        }
        this.cutPieces.push(piece1, piece2);
        
        // Add click handlers to pieces for selection
        this.makePiecesSelectable();
        
        // Update selection display
        this.updateSelectionDisplay();
        
        // Store cut data for returning to main scene
        const cutData = {
            miterAngle: miterAngleDegrees,
            bevelAngle: this.bevelAngle,
            bevelDirection: this.bevelDirection,
            cutPosition: cutPositionZ,
            piece1Length: piece1Length,
            piece2Length: piece2Length
        };
        
        console.log('Cut completed:', cutData);
        
        // Show success message
        this.showCutSuccess(cutData);
    }
    
    makePiecesSelectable() {
        if (!this.cutPieces) return;
        
        this.cutPieces.forEach((piece, index) => {
            piece.isPickable = true;
            piece.actionManager = new BABYLON.ActionManager(this.millScene);
            
            // Add click action
            piece.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                () => {
                    this.selectPiece(piece, index);
                }
            ));
            
            // Add hover effect
            piece.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                () => {
                    piece.renderOutline = true;
                    piece.outlineColor = new BABYLON.Color3(0, 1, 0);
                    piece.outlineWidth = 0.1;
                }
            ));
            
            piece.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                () => {
                    piece.renderOutline = false;
                }
            ));
        });
    }
    
    selectPiece(piece, index) {
        console.log('Selected piece', index + 1);
        
        // Don't dispose other pieces - Prime Directive!
        // Just deselect them visually
        this.cutPieces.forEach((p, i) => {
            if (p.renderOutline) {
                p.renderOutline = false;
            }
            // Remove selection highlight
            if (p.material.emissiveColor) {
                p.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
            }
        });
        
        // Set selected piece as current board
        this.currentBoard = piece;
        // Keep cutPieces array so we know there are multiple pieces
        
        // Attach gizmos to selected piece
        if (this.gizmoManager) {
            this.gizmoManager.attachToMesh(piece);
        }
        
        // Visual feedback for selection
        piece.renderOutline = true;
        piece.outlineColor = new BABYLON.Color3(0, 1, 1); // Cyan for selected
        piece.outlineWidth = 0.15;
        
        // Flash to indicate selection
        const originalEmissive = piece.material.emissiveColor ? piece.material.emissiveColor.clone() : new BABYLON.Color3(0, 0, 0);
        piece.material.emissiveColor = new BABYLON.Color3(0.2, 0.5, 0.2);
        setTimeout(() => {
            piece.material.emissiveColor = originalEmissive;
        }, 300);
        
        // Update selection display
        this.updateSelectionDisplay();
    }
    
    showCutAnimation(piece1, piece2) {
        // Animate pieces separating
        const animationFrames = 30;
        let frame = 0;
        
        const animate = () => {
            if (frame < animationFrames) {
                const progress = frame / animationFrames;
                const ease = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                piece1.position.z -= 0.3 * ease;
                piece2.position.z += 0.3 * ease;
                
                frame++;
                requestAnimationFrame(animate);
            }
        };
        
        animate();
    }
    
    flashBlade() {
        // Visual feedback for cutting
        if (!this.bladeVisual) return;
        
        const originalAlpha = this.bladeVisual.material.alpha;
        const originalColor = this.bladeVisual.material.diffuseColor.clone();
        
        // Flash white
        this.bladeVisual.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        this.bladeVisual.material.alpha = 0.8;
        
        setTimeout(() => {
            // Return to red
            this.bladeVisual.material.diffuseColor = originalColor;
            this.bladeVisual.material.alpha = originalAlpha;
        }, 200);
    }
    
    addBevelIndicator(piece, originalSize, pieceLength, bevelAngle, direction, isFirstPiece) {
        // Add a visual indicator for the bevel angle
        const bevelRadians = (90 - bevelAngle) * Math.PI / 180;
        const bevelOffset = Math.tan(bevelRadians) * originalSize.y;
        
        // Create a thin plane to show the cut angle
        const indicator = BABYLON.MeshBuilder.CreatePlane('bevelIndicator', {
            width: originalSize.x,
            height: originalSize.y * 1.2,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
        }, this.millScene);
        
        // Position at the cut end
        if (isFirstPiece) {
            indicator.position.z = pieceLength / 2;
        } else {
            indicator.position.z = -pieceLength / 2;
        }
        
        // Rotate to show the bevel angle
        indicator.rotation.y = Math.PI / 2; // Face the cut direction
        indicator.rotation.z = -bevelRadians * direction;
        
        // Make it semi-transparent colored to show the cut
        const indicatorMat = new BABYLON.StandardMaterial('bevelIndicatorMat', this.millScene);
        indicatorMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);
        indicatorMat.alpha = 0.2;
        indicatorMat.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.1);
        indicator.material = indicatorMat;
        
        // Parent to the piece
        indicator.parent = piece;
    }
    
    updateSelectionDisplay() {
        // Remove existing selection display if any
        const existing = document.getElementById('mill-selection-display');
        if (existing) existing.remove();
        
        if (this.cutPieces && this.cutPieces.length > 0) {
            const display = document.createElement('div');
            display.id = 'mill-selection-display';
            display.style.position = 'fixed';
            display.style.top = '80px';
            display.style.right = '20px';
            display.style.background = 'rgba(0, 0, 0, 0.8)';
            display.style.color = 'white';
            display.style.padding = '10px 15px';
            display.style.borderRadius = '4px';
            display.style.fontSize = '14px';
            display.style.zIndex = '1000';
            
            const selectedIndex = this.currentBoard ? this.cutPieces.indexOf(this.currentBoard) + 1 : 0;
            display.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">Cut Pieces: ${this.cutPieces.length}</div>
                <div style="color: #0ff;">Selected: ${selectedIndex > 0 ? 'Piece ' + selectedIndex : 'None - Click a piece'}</div>
            `;
            document.body.appendChild(display);
        }
    }
    
    showCutSuccess(cutData) {
        // Create success message
        const message = document.createElement('div');
        message.style.position = 'fixed';
        message.style.top = '50%';
        message.style.left = '50%';
        message.style.transform = 'translate(-50%, -50%)';
        message.style.background = 'rgba(39, 174, 96, 0.95)';
        message.style.color = 'white';
        message.style.padding = '20px 40px';
        message.style.borderRadius = '8px';
        message.style.fontSize = '24px';
        message.style.fontWeight = 'bold';
        message.style.zIndex = '10000';
        message.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        message.innerHTML = `
            <div> Cut Successful!</div>
            <div style="font-size: 14px; margin-top: 10px; font-weight: normal;">
                Miter: ${(cutData.miterAngle || 0).toFixed(1)} | Bevel: ${cutData.bevelAngle.toFixed(1)}
            </div>
        `;
        document.body.appendChild(message);
        
        // Remove after 2 seconds
        setTimeout(() => {
            message.style.transition = 'opacity 0.5s';
            message.style.opacity = '0';
            setTimeout(() => message.remove(), 500);
        }, 2000);
    }
    
    // Get operation display name
    getOperationName() {
        switch(this.currentOperation) {
            case 'cut': return 'Table Saw';
            case 'route': return 'Router';
            case 'drill': return 'Drill Press';
            default: return 'Unknown Tool';
        }
    }
    

    createBevelControl() {
        // Create bevel control (hemispherical dial on left)
        const control = document.createElement('div');
        control.id = 'mill-bevel-control';
        control.style.position = 'absolute';
        control.style.bottom = '20px';
        control.style.left = '20px';  // Bevel on left corner
        control.style.width = '360px';
        control.style.height = '180px'; // Half height for hemisphere
        control.style.borderRadius = '180px 180px 0 0'; // Top half circle
        control.style.backgroundColor = 'rgba(40, 40, 40, 0.9)';
        control.style.border = '2px solid #555';
        control.style.cursor = 'grab';
        control.style.userSelect = 'none';
        control.style.display = 'flex';
        control.style.alignItems = 'center';
        control.style.justifyContent = 'center';
        control.style.flexDirection = 'column';
        control.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
        
        // Add degree markings for hemisphere (0 to 90 on each side)
        const markings = document.createElement('div');
        markings.style.position = 'absolute';
        markings.style.width = '100%';
        markings.style.height = '100%';
        markings.style.pointerEvents = 'none';
        
// Fix for bevel control degree labels - 90 at top, 0 on both sides
        // Add degree labels (90 at top, 0 on both sides)
        // Create labels for both sides of the hemisphere
        
        // Left side: 0, 15, 30, 45, 60, 75
        [0, 15, 30, 45, 60, 75].forEach(deg => {
            const label = document.createElement('div');
            label.textContent = deg + '';
            label.style.position = 'absolute';
            label.style.fontSize = '12px';
            label.style.color = '#888';
            
            // Position on left arc
            const angle = (Math.PI / 2) + ((90 - deg) * Math.PI / 180); // Left side angle
            const radius = 150;
            const x = 180 + Math.cos(angle) * radius;
            const y = 180 - Math.sin(angle) * radius;
            
            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.transform = 'translate(-50%, -50%)';
            markings.appendChild(label);
        });
        
        // Top center: 90
        const topLabel = document.createElement('div');
        topLabel.textContent = '90';
        topLabel.style.position = 'absolute';
        topLabel.style.fontSize = '14px';
        topLabel.style.fontWeight = 'bold';
        topLabel.style.color = '#aaa';
        topLabel.style.left = '180px';
        topLabel.style.top = '30px';
        topLabel.style.transform = 'translate(-50%, -50%)';
        markings.appendChild(topLabel);
        
        // Right side: 75, 60, 45, 30, 15, 0
        [75, 60, 45, 30, 15, 0].forEach(deg => {
            const label = document.createElement('div');
            label.textContent = deg + '';
            label.style.position = 'absolute';
            label.style.fontSize = '12px';
            label.style.color = '#888';
            
            // Position on right arc
            const angle = (Math.PI / 2) - ((90 - deg) * Math.PI / 180); // Right side angle
            const radius = 150;
            const x = 180 + Math.cos(angle) * radius;
            const y = 180 - Math.sin(angle) * radius;
            
            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.style.transform = 'translate(-50%, -50%)';
            markings.appendChild(label);
        });
        
        control.appendChild(markings);
        
        // Add needle for current angle
        const needle = document.createElement('div');
        needle.id = 'bevel-needle';
        needle.style.position = 'absolute';
        needle.style.width = '2px';
        needle.style.height = '140px';
        needle.style.backgroundColor = '#ff6b6b';
        needle.style.bottom = '0';
        needle.style.left = '50%';
        needle.style.transformOrigin = 'bottom center';
        needle.style.transform = "translateX(-50%) rotate(0deg)"; // Start at 90 degrees (vertical)
        needle.style.pointerEvents = 'none';
        control.appendChild(needle);
        
        // Add center display
        const display = document.createElement('div');
        display.id = 'bevel-display';
        display.style.position = 'absolute';
        display.style.bottom = '20px';
        display.style.fontSize = '24px';
        display.style.fontWeight = 'bold';
        display.style.color = '#ff6b6b';
        display.style.textShadow = '0 2px 4px rgba(0,0,0,0.5)';
        display.textContent = '90.0';
        control.appendChild(display);
        
        // Handle dragging
        let isDragging = false;
        
        control.addEventListener('mousedown', (e) => {
            isDragging = true;
            control.style.cursor = 'grabbing';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = control.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.bottom; // Bottom center for hemisphere
            
            const dx = e.clientX - centerX;
            const dy = centerY - e.clientY; // Positive when above center
            
            // Only update if mouse is in the upper hemisphere
            if (dy < 0) return; // Don't allow below the base
            
            // Calculate angle from horizontal (0 to 180 degrees for the arc)
            let arcAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            // Convert to bevel angle:
            // arcAngle 0 (far right) = bevel 0
            // arcAngle 90 (top) = bevel 90
            // arcAngle 180 (far left) = bevel 0
            let bevelAngle;
            let direction;
            
            if (arcAngle >= 0 && arcAngle <= 90) {
                // Right side: 0 to 90 degrees
                bevelAngle = arcAngle;
                direction = 1;
            } else if (arcAngle > 90 && arcAngle <= 180) {
                // Left side: 90 to 0 degrees
                bevelAngle = 180 - arcAngle;
                direction = -1;
            } else {
                return; // Shouldn't happen
            }
            
            // Store the values
            this.bevelAngle = bevelAngle;
            this.bevelDirection = direction;
            
            // Needle rotation: 0 degrees = vertical, positive = clockwise
            // When bevel is 90, needle is vertical (0 rotation)
            // When bevel is 0 on right, needle is 90 degrees clockwise
            // When bevel is 0 on left, needle is -90 degrees
            const needleRotation = (90 - bevelAngle) * direction;
            needle.style.transform = `translateX(-50%) rotate(${needleRotation}deg)`;
            
            // Update display
            display.textContent = (direction < 0 ? 'L ' : 'R ') + bevelAngle.toFixed(1) + '';
            
            // Update blade tilt
            this.updateBladeTilt();
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                control.style.cursor = 'grab';
            }
        });
        
        control.style.display = 'none';  // Hidden initially (top view)
        document.getElementById('mill-container').appendChild(control);
    }
    
    /* Removed - using single blade
    createBladeVisualization() {
        // Create blade visual (rectangular plane)
        // Create a more realistic blade visual (10 inch diameter)
        this.bladeVisual = BABYLON.MeshBuilder.CreateBox('blade', {
            width: 200,  // 200 inches long
            height: 6,   // 6 inches high
            depth: 0.25  // 1/4 inch thick for visibility
        }, this.millScene);
        
        // Blade box is already oriented correctly, no rotation needed
        
        // Position blade at cutting height above table
        this.bladeVisual.position.y = 50; // Above table at typical cutting height
        this.bladeVisual.position.z = 0; // Aligned with laser at Z=0
        this.bladeVisual.position.x = 0; // Centered
        
        // Semi-transparent red material for blade
        const bladeMaterial = new BABYLON.StandardMaterial('bladeMat', this.millScene);
        bladeMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.8); // Steel blue
        bladeMaterial.alpha = 0.8; // Mostly opaque
        bladeMaterial.backFaceCulling = false;
        this.bladeVisual.material = bladeMaterial;
        
        // Create cutting plane indicator (only visible in profile view)
        this.cuttingPlane = BABYLON.MeshBuilder.CreatePlane('cuttingPlane', {
            width: 200,
            height: 200,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
        }, this.millScene);
        
        this.cuttingPlane.position.y = 0;
        this.cuttingPlane.isVisible = false; // Hidden by default
        
        const planeMaterial = new BABYLON.StandardMaterial('planeMat', this.millScene);
        planeMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
        planeMaterial.alpha = 0.2;
        planeMaterial.wireframe = true;
        this.cuttingPlane.material = planeMaterial;
    }
    
    updateBladeTilt() {
        if (!this.bladeVisual) {
            return;
        }
        
        // Blade tilt matches the bevel angle
        // bevelAngle 90 = vertical blade (no tilt)
        // bevelAngle 0 = blade tilted 90 degrees
        // bevelDirection: 1 = right tilt, -1 = left tilt
        
        // The blade needs to rotate on X axis to tilt left/right in B view
        // bevelAngle 90 = vertical blade (no tilt)
        // bevelAngle < 90 = blade tilts
        // direction: 1 = right, -1 = left
        const tiltRadians = (90 - this.bevelAngle) * Math.PI / 180;
        const direction = this.bevelDirection || 1;
        
        // Rotate on X axis - this was working before, just wrong direction
        // Negate to match needle direction
        this.bladeVisual.rotation.x = -tiltRadians * direction;
        
        // Update cutting plane to match blade angle
        if (this.cuttingPlane) {
            this.cuttingPlane.rotation.x = -tiltRadians * direction;
        }
        
        // Force scene render
        if (this.millScene) {
            this.millScene.render();
        }
    }
    */
    switchToBladeProfileView() {
        
        // Debug: Check if board exists and is visible
        console.log("Board in B view:", this.currentBoard ? "exists" : "missing", this.currentBoard?.isVisible);
        this.currentViewMode = "side";
        
        this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA; // Back to ORTHO as intended
        const rotationControl = document.getElementById('mill-rotation-control');
        const bevelControl = document.getElementById('mill-bevel-control');
        if (rotationControl) rotationControl.style.display = 'none';
        if (bevelControl) bevelControl.style.display = 'block';
        // Switch to orthographic view looking from the LEFT side (like view cube LEFT face)
        
        // BLADE-EYE VIEW: Camera positioned at blade end, looking down its length
        // This creates a "sight line" view where the blade acts as the aiming reticle
        
        // Get current blade rotation (miter angle)
        const bladeAngle = this.blade ? this.blade.rotation.y : 0;
        const bladeLength = 100;  // Half of 200" blade width
        
        // Position camera at one end of the blade
        const cameraX = Math.cos(bladeAngle) * bladeLength;
        const cameraZ = Math.sin(bladeAngle) * bladeLength;
        const cameraY = 0;  // At table surface where pivot is
        
        // Set camera to look at the opposite end of blade
        this.millCamera.position = new BABYLON.Vector3(cameraX, cameraY, cameraZ);
        this.millCamera.setTarget(new BABYLON.Vector3(-cameraX, cameraY, -cameraZ));
        
        // Switch to orthographic for precision view
        this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        
        // Set view bounds to frame the board cross-section
        const viewSize = 10;  // Show area around board
        const aspectRatio = this.millCanvas.width / this.millCanvas.height;
        
        this.millCamera.orthoLeft = -viewSize;
        this.millCamera.orthoRight = viewSize;
        this.millCamera.orthoTop = viewSize / aspectRatio;
        this.millCamera.orthoBottom = -viewSize / aspectRatio;
        
        // Lock camera rotation - we only look down the blade
        this.millCamera.lowerAlphaLimit = this.millCamera.alpha;
        this.millCamera.upperAlphaLimit = this.millCamera.alpha;
        this.millCamera.lowerBetaLimit = this.millCamera.beta;
        this.millCamera.upperBetaLimit = this.millCamera.beta;
        
        // Make blade visible as our "sight"
        if (this.blade) {
            this.blade.isVisible = true;
            console.log("Blade visibility set to:", this.blade.isVisible);
            console.log("Blade position:", this.blade.position);
            console.log("Blade rotation:", this.blade.rotation);
            console.log("Blade dimensions: 200x12x0.0625");
            
            // Ensure material is visible
            if (this.blade.material) {
                this.blade.material.alpha = 1.0;  // Fully opaque
                this.blade.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                this.blade.material.backFaceCulling = false;  // See both sides
                // Make blade thicker for visibility when looking down its length
                this.blade.scaling.z = 10;  // Slightly thicker for visibility in blade-eye view
            }
            this.blade.computeWorldMatrix(true);
        } else {
            console.error("BLADE NOT FOUND in B view!");
        }
        
        // Ensure board is visible
        if (this.currentBoard) {
            this.currentBoard.isVisible = true;
        }
        
        // Show table for reference
        if (this.tableSurface) {
            this.tableSurface.isVisible = true;
        }
        
        // Hide transform toolbar
        const toolbar = document.getElementById("mill-transform-toolbar");
        if (toolbar) toolbar.style.display = "none";
        
        console.log("BLADE-EYE VIEW ACTIVE: Looking down blade from end to end");
        
        // Force blade to render in orthographic
        if (this.blade) {
            this.blade.refreshBoundingInfo();
            this.blade.showBoundingBox = false;  // Ensure no bounding box
            this.blade.isPickable = false;  // Not pickable in this view
            this.blade.alwaysSelectAsActiveMesh = true;  // Force render
        }
        console.log("Blade angle:", (bladeAngle * 180 / Math.PI), "degrees");
        
        // Enable board dragging in this view
        this.enableBViewDragging = true;
        
        // Force render
        this.millScene.render();


    }
    frameBoard(boardMesh) {
        // Get board bounds
        boardMesh.computeWorldMatrix(true);
        const boundingInfo = boardMesh.getBoundingInfo();
        const min = boundingInfo.boundingBox.minimumWorld;
        const max = boundingInfo.boundingBox.maximumWorld;
        
        // Calculate board size
        const sizeX = max.x - min.x;
        const sizeZ = max.z - min.z;
        const maxSize = Math.max(sizeX, sizeZ);
        
        // Fill 90% of viewport (10% total padding - 5% each side)
        const paddedSize = maxSize * 1.11;  // 1/0.9 = 1.11 to make board fill 90%
        
        // Set orthographic bounds to frame the board
        const aspectRatio = this.millCanvas.width / this.millCanvas.height;
        
        if (aspectRatio > 1) {
            // Wider viewport - adjust horizontal bounds
            this.millCamera.orthoLeft = -paddedSize * aspectRatio / 2;
            this.millCamera.orthoRight = paddedSize * aspectRatio / 2;
            this.millCamera.orthoTop = paddedSize / 2;
            this.millCamera.orthoBottom = -paddedSize / 2;
        } else {
            // Taller viewport - adjust vertical bounds
            this.millCamera.orthoLeft = -paddedSize / 2;
            this.millCamera.orthoRight = paddedSize / 2;
            this.millCamera.orthoTop = paddedSize / (2 * aspectRatio);
            this.millCamera.orthoBottom = -paddedSize / (2 * aspectRatio);
        }
        
        // Also set radius for when switching to perspective
        this.millCamera.radius = paddedSize * 0.8;  // Closer in perspective too
        
        // Center camera on board
        const center = boundingInfo.boundingBox.centerWorld;
        this.millCamera.target = new BABYLON.Vector3(center.x, 0, center.z);
        
        // Force camera to top-down position
        this.millCamera.alpha = -Math.PI / 2;
        this.millCamera.beta = 0;
        
        console.log('Framed board to 90% of viewport, size:', maxSize);
    }
    
    // Close The Mill
    closeMill(cutData = null) {
        console.log('Closing The Mill');
        
        // Clean up mill scene
        if (this.millScene) {
            this.millScene.dispose();
        }
        
        // Remove UI
        if (this.millUI) {
            this.millUI.remove();
        }
        
        // Show main canvas again
        this.drawingWorld.canvas.style.display = 'block';
        
        // Reset state
        this.isActive = false;
        this.currentMaterial = null;
        this.currentOperation = null;
        
        // If we have cut data, execute the cut in the main scene
        if (cutData) {
            // This would trigger the actual cut in the main scene
            // For now, we'll just log it
            console.log('Would execute cut with data:', cutData);
            
            // TODO: Call back to main scene to execute the cut
            // this.drawingWorld.executeCutFromMill(this.currentMaterial, cutData);
        }
    }

    createTransformToolbar() {
        // Create toolbar container
        const toolbar = document.createElement('div');
        toolbar.id = 'mill-transform-toolbar';
        toolbar.style.cssText = `
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(50, 50, 50, 0.9);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        `;
        
        // Move button
        const moveBtn = this.createToolbarButton('Move', () => {
            this.clearGizmos();
            if (this.currentBoard) {
                const gizmoManager = new BABYLON.GizmoManager(this.millScene);
                gizmoManager.positionGizmoEnabled = true;
                gizmoManager.attachToMesh(this.currentBoard);
                this.currentGizmo = gizmoManager;
            }
        });
        
        // Rotate button with dropdown
        const rotateContainer = document.createElement('div');
        rotateContainer.style.position = 'relative';
        
        const rotateBtn = this.createToolbarButton('Rotate ', () => {
            const dropdown = rotateContainer.querySelector('.rotate-dropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        });
        
        // Rotate dropdown menu
        const dropdown = document.createElement('div');
        dropdown.className = 'rotate-dropdown';
        dropdown.style.cssText = `
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(40, 40, 40, 0.95);
            border-radius: 4px;
            padding: 5px;
            display: none;
            min-width: 120px;
            margin-top: 2px;
        `;
        
        // Rotate gizmo option
        const rotateGizmoBtn = this.createToolbarButton('Rotate', () => {
            this.clearGizmos();
            if (this.currentBoard) {
                const gizmoManager = new BABYLON.GizmoManager(this.millScene);
                gizmoManager.rotationGizmoEnabled = true;
                // Restrict to Y-axis rotation only
                gizmoManager.gizmos.rotationGizmo.xGizmo.isEnabled = false;
                gizmoManager.gizmos.rotationGizmo.zGizmo.isEnabled = false;
                gizmoManager.attachToMesh(this.currentBoard);
                this.currentGizmo = gizmoManager;
            }
            dropdown.style.display = 'none';
        });
        
        // Flip 90 right
        const flip90RightBtn = this.createToolbarButton('Flip 90 ', () => {
            if (this.currentBoard) {
                this.currentBoard.rotation.x += Math.PI / 2;
            }
            dropdown.style.display = 'none';
        });
        
        // Flip 90 left  
        const flip90LeftBtn = this.createToolbarButton('Flip 90 ', () => {
            if (this.currentBoard) {
                this.currentBoard.rotation.x -= Math.PI / 2;
            }
            dropdown.style.display = 'none';
        });
        
        dropdown.appendChild(rotateGizmoBtn);
        dropdown.appendChild(flip90RightBtn);
        dropdown.appendChild(flip90LeftBtn);
        
        rotateContainer.appendChild(rotateBtn);
        rotateContainer.appendChild(dropdown);
        
        // Clear button (removes active gizmos)
        const clearBtn = this.createToolbarButton('Clear', () => {
            this.clearGizmos();
        });
        
        toolbar.appendChild(moveBtn);
        toolbar.appendChild(rotateContainer);
        toolbar.appendChild(clearBtn);
        
        const container = document.getElementById('mill-container');
        if (container) {
            container.appendChild(toolbar);
        }
    }
    
    createToolbarButton(text, onClick) {
        const btn = document.createElement('button');
        btn.textContent = text;
        btn.style.cssText = `
            padding: 8px 16px;
            background: rgba(70, 70, 70, 0.9);
            color: white;
            border: 1px solid rgba(100, 100, 100, 0.5);
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            min-width: 100px;
            text-align: left;
        `;
        btn.onmouseover = () => btn.style.background = 'rgba(90, 90, 90, 0.9)';
        btn.onmouseout = () => btn.style.background = 'rgba(70, 70, 70, 0.9)';
        btn.onclick = onClick;
        return btn;
    }
    
    clearGizmos() {
        if (this.currentGizmo) {
            this.currentGizmo.dispose();
            this.currentGizmo = null;
        }
    }
}

export { TheMillSystem };
