import { ViewCube } from './ViewCube.js';

// The Mill System - A 2D workspace for cutting operations
// Simulates real workshop tools in an orthographic view

class TheMillSystem {
    constructor(drawingWorld) {
        this.drawingWorld = drawingWorld;
        this.scene = drawingWorld.scene;
        this.engine = drawingWorld.engine;
        this.canvas = drawingWorld.canvas;
        
        // Mill state
        this.isActive = false;
        this.currentMaterial = null;
        this.currentOperation = null; // 'cut', 'route', 'drill'
        
        // UI elements
        this.millUI = null;
        this.millCanvas = null;
        this.millScene = null;
        this.millCamera = null;
        
        // Turntable and laser elements
        this.turntable = null;
        this.laserLine = null;
        this.kerfWidth = 0.125 * 2.54; // 1/8 inch kerf in cm
        this.bladeAngle = 0; // Angle of the blade in radians
        
        // Turntable interaction
        this.isDraggingTurntable = false;
        this.dragStartAngle = 0;
        
        // Transform gizmos for lumber
        this.gizmoManager = null;
        
        // ViewCube for navigation
        this.viewCube = null;
    }
    
    // Open The Mill with a selected material
    openMill(material, operation = 'cut') {
        if (!material) {
            console.error('No material provided to The Mill');
            return;
        }
        
        console.log('Opening The Mill with material:', material.name);
        
        this.currentMaterial = material;
        this.currentOperation = operation;
        this.isActive = true;
        
        // Hide main 3D view
        this.drawingWorld.canvas.style.display = 'none';
        
        // Create mill interface
        this.createMillInterface();
        
        // Setup 2D scene with material
        this.setupMillScene();
        
        // Add event listeners
        this.setupEventListeners();
    }
    
    // Create the mill UI interface
    createMillInterface() {
        // Create container
        this.millUI = document.createElement('div');
        this.millUI.id = 'the-mill-interface';
        this.millUI.style.position = 'fixed';
        this.millUI.style.top = '0';
        this.millUI.style.left = '0';
        this.millUI.style.width = '100%';
        this.millUI.style.height = '100%';
        this.millUI.style.background = '#f5f5f5';
        this.millUI.style.zIndex = '10000';
        
        // Create header
        const header = document.createElement('div');
        header.style.position = 'absolute';
        header.style.top = '0';
        header.style.left = '0';
        header.style.right = '0';
        header.style.height = '60px';
        header.style.background = '#2c3e50';
        header.style.color = 'white';
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.padding = '0 20px';
        header.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        
        // Title
        const title = document.createElement('h2');
        title.textContent = 'The Mill - ' + this.getOperationName();
        title.style.margin = '0';
        title.style.flex = '1';
        header.appendChild(title);
        
        // Tool selector
        const toolSelector = document.createElement('select');
        toolSelector.style.marginRight = '20px';
        toolSelector.style.padding = '8px 12px';
        toolSelector.style.background = 'white';
        toolSelector.style.border = 'none';
        toolSelector.style.borderRadius = '4px';
        toolSelector.style.cursor = 'pointer';
        
        const cutOption = document.createElement('option');
        cutOption.value = 'cut';
        cutOption.textContent = 'Table Saw';
        toolSelector.appendChild(cutOption);
        
        const routeOption = document.createElement('option');
        routeOption.value = 'route';
        routeOption.textContent = 'Router';
        toolSelector.appendChild(routeOption);
        
        const drillOption = document.createElement('option');
        drillOption.value = 'drill';
        drillOption.textContent = 'Drill Press';
        toolSelector.appendChild(drillOption);
        
        toolSelector.value = this.currentOperation;
        toolSelector.addEventListener('change', (e) => {
            this.currentOperation = e.target.value;
            title.textContent = 'The Mill - ' + this.getOperationName();
        });
        header.appendChild(toolSelector);
        
        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Exit Mill';
        closeBtn.style.padding = '10px 20px';
        closeBtn.style.background = '#e74c3c';
        closeBtn.style.color = 'white';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '4px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontWeight = 'bold';
        closeBtn.addEventListener('click', () => this.closeMill());
        header.appendChild(closeBtn);
        
        this.millUI.appendChild(header);
        
        // Create canvas container
        const canvasContainer = document.createElement('div');
        canvasContainer.style.position = 'absolute';
        canvasContainer.style.top = '60px';
        canvasContainer.style.left = '0';
        canvasContainer.style.right = '0';
        canvasContainer.style.bottom = '100px';
        canvasContainer.style.background = 'white';
        canvasContainer.style.margin = '20px';
        canvasContainer.style.borderRadius = '8px';
        canvasContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
        canvasContainer.style.overflow = 'hidden';
        
        // Create canvas
        this.millCanvas = document.createElement('canvas');
        this.millCanvas.id = 'mill-canvas';
        this.millCanvas.style.width = '100%';
        this.millCanvas.style.height = '100%';
        this.millCanvas.style.display = 'block';
        canvasContainer.appendChild(this.millCanvas);
        this.millUI.appendChild(canvasContainer);
        
        // Create bottom toolbar
        const toolbar = document.createElement('div');
        toolbar.style.position = 'absolute';
        toolbar.style.bottom = '0';
        toolbar.style.left = '0';
        toolbar.style.right = '0';
        toolbar.style.height = '80px';
        toolbar.style.background = 'white';
        toolbar.style.borderTop = '1px solid #ddd';
        toolbar.style.display = 'flex';
        toolbar.style.alignItems = 'center';
        toolbar.style.padding = '0 20px';
        toolbar.style.gap = '20px';
        
        // Add instructions
        const instructions = document.createElement('div');
        instructions.style.flex = '1';
        instructions.style.color = '#666';
        const kerfInInches = (this.kerfWidth / 2.54).toFixed(3);
        instructions.innerHTML = '<strong>Instructions:</strong> Right-click to enter perspective mode for manipulation. Press T to return to top view. ' +
                                'Drag turntable to rotate laser. Position lumber under laser. Kerf: ' + kerfInInches + ' inch.';
        toolbar.appendChild(instructions);
        
        // Add execute button
        const executeBtn = document.createElement('button');
        executeBtn.textContent = 'Execute Cut';
        executeBtn.style.padding = '12px 24px';
        executeBtn.style.background = '#27ae60';
        executeBtn.style.color = 'white';
        executeBtn.style.border = 'none';
        executeBtn.style.borderRadius = '4px';
        executeBtn.style.cursor = 'pointer';
        executeBtn.style.fontWeight = 'bold';
        executeBtn.style.fontSize = '16px';
        executeBtn.addEventListener('click', () => this.executeCut());
        toolbar.appendChild(executeBtn);
        
        this.millUI.appendChild(toolbar);
        
        // Add to document
        document.body.appendChild(this.millUI);
    }
    
    // Setup the 2D Babylon scene
    setupMillScene() {
        // Create new engine for mill canvas
        const millEngine = new BABYLON.Engine(this.millCanvas, true);
        
        // Create scene
        this.millScene = new BABYLON.Scene(millEngine);
        this.millScene.clearColor = new BABYLON.Color3(0.98, 0.98, 0.98);
        
        // Create ArcRotateCamera and FORCE it to top-down view
        this.millCamera = new BABYLON.ArcRotateCamera('millCamera',
            -Math.PI / 2,   // Alpha: -90 degrees
            0,              // Beta: 0 = looking straight down Y axis
            100,            // Radius: distance from target
            BABYLON.Vector3.Zero(),
            this.millScene
        );
        
        // CRITICAL: Force beta to 0 for true top-down view
        this.millCamera.beta = 0;
        
        // Start in orthographic mode for top-down view
        this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
        
        // Don't attach default controls since we're using manual controls
        
        // Manual camera state tracking
        this.cameraState = {
            isPanning: false,
            isRotating: false,
            lastX: 0,
            lastY: 0
        };
        
        // Set up manual mouse controls to match drawing world
        this.setupManualCameraControls(); // Manual controls already set up inline
        
        // FORCE camera to exact top-down position AFTER everything else
        this.millCamera.position = new BABYLON.Vector3(0, 100, 0.01);
        this.millCamera.setTarget(new BABYLON.Vector3(0, 0, 0));
        
        // Force a render to ensure camera is properly positioned
        this.millScene.render();
        
        // ABSOLUTE FINAL OVERRIDE: Force true top-down view
        this.millCamera.beta = 0;
        this.millCamera.alpha = -Math.PI / 2;
        this.millCamera.rebuildAnglesAndRadius();
        
        // Double-check camera is vertical

        this.millScene.render();
        
        // Camera configuration for UniversalCamera
        // (UniversalCamera doesn't need radius/beta limits)
        
        // Allow switching between ortho and perspective
        this.setupCameraControls();
        
        // Set orthographic size based on material
        const bounds = this.currentMaterial.getBoundingInfo().boundingBox;
        const boardLength = bounds.maximum.x - bounds.minimum.x;
        const boardWidth = bounds.maximum.z - bounds.minimum.z;
        const maxDim = Math.max(boardLength, boardWidth) * 1.5; // Add 50% padding for better view
        
        // Set orthographic bounds to fit board with padding
        this.millCamera.orthoLeft = -maxDim / 2;
        this.millCamera.orthoRight = maxDim / 2;
        this.millCamera.orthoTop = maxDim / 2;
        this.millCamera.orthoBottom = -maxDim / 2;
        
        // Create angled light to reduce direct reflection
        const light = new BABYLON.HemisphericLight('millLight', 
            new BABYLON.Vector3(0.5, 1, 0.5), this.millScene);
        light.intensity = 1.0;
        light.specular = new BABYLON.Color3(0.2, 0.2, 0.2); // Reduce specular
        
        // Clone material mesh to mill scene - create a box with same dimensions
        console.log('Creating material in Mill scene:', this.currentMaterial.name);
        
        // Get dimensions from the original mesh
        const boardThickness = bounds.maximum.y - bounds.minimum.y;
        
        console.log('Board dimensions:', { 
            length: boardLength, 
            thickness: boardThickness, 
            width: boardWidth 
        });
        
        // Create a FLAT board in the Mill scene
        const materialClone = BABYLON.MeshBuilder.CreateBox('millMaterial', {
            width: boardLength,     // X: length of board
            height: boardThickness, // Y: thickness (small)
            depth: boardWidth,      // Z: width of board
            wrap: true
        }, this.millScene);
        
        // Position at origin, flat on table
        materialClone.position = new BABYLON.Vector3(0, 0, 0);
        materialClone.rotation = new BABYLON.Vector3(0, 0, 0);
        
        // Create a material with texture for visualization
        const mat = new BABYLON.StandardMaterial('millMat', this.millScene);
        
        // Try to copy the texture from the original material
        if (this.currentMaterial.material && this.currentMaterial.material.diffuseTexture) {
            // Clone the texture to the new scene
            const originalTexture = this.currentMaterial.material.diffuseTexture;
            if (originalTexture && originalTexture.url) {
                console.log('Copying texture from original:', originalTexture.url);
                const texture = new BABYLON.Texture(originalTexture.url, this.millScene);
                
                // Copy texture properties
                texture.uScale = originalTexture.uScale || 1;
                texture.vScale = originalTexture.vScale || 1;
                texture.hasAlpha = originalTexture.hasAlpha || false;
                
                mat.diffuseTexture = texture;
            }
        }
        
        // Also try to copy the color
        if (this.currentMaterial.material && this.currentMaterial.material.diffuseColor) {
            mat.diffuseColor = this.currentMaterial.material.diffuseColor.clone();
        } else if (!mat.diffuseTexture) {
            // Only use default color if no texture was found
            mat.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
        }
        
        // Set material properties for wood-like appearance
        mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        mat.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        materialClone.material = mat;
        
        // Make sure it's visible and pickable
        materialClone.isVisible = true;
        materialClone.isPickable = true;
        materialClone.renderingGroupId = 1;  // Middle rendering group
        
        console.log('Material created in Mill:', materialClone);
        
        // Add transform gizmos for the lumber
        this.setupGizmos(materialClone);
        
        // Add grid for reference
        this.createGrid();
        
        // Setup cutting line
        this.setupTurntableAndLaser();
        
        // Force perfect orthographic top-down view
        const forceTopDownView = () => {
            this.millCamera.beta = 0;
            this.millCamera.alpha = -Math.PI / 2;
            this.millCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            
            // Force update the projection matrix
            this.millCamera.getProjectionMatrix(true);
            this.millScene.render();
        };
        
        // Apply it immediately
        forceTopDownView();
        
        // Apply it after a short delay to override any async operations
        setTimeout(forceTopDownView, 100);
        
        // Add ViewCube for navigation
        this.setupViewCube(millEngine);
        
        // Force camera to top-down before starting render
        this.millCamera.beta = 0;  // FORCE top-down
        this.millCamera.alpha = -Math.PI / 2;
        
        // Start render loop
        millEngine.runRenderLoop(() => {
            // Only force top-down view in orthographic mode when not rotating
            if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA && !this.cameraState.isRotating) {
                this.millCamera.beta = 0;
            }
            this.millScene.render();
        });
        
        // Handle resize
        window.addEventListener('resize', () => {
            millEngine.resize();
        });
    }
    

    updateAngleDisplay(degrees) {
        // Update HUD display
        if (this.hudAngleDisplay) {
            this.hudAngleDisplay.textContent = degrees.toFixed(1) + '°';
        }
    }
    
    
    
    // Setup event listeners for cutting
    setupCameraControls() {
        // Set up pointer event handling for camera mode switching
        this.millScene.onPointerObservable.add((pointerInfo) => {
            // Handle right-click drag for camera rotation (which switches to perspective)
            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN && 
                pointerInfo.event.button === 2) {
                // Right-click switches to perspective mode for rotation
                if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                    // Calculate radius from ortho bounds to maintain zoom
                    const orthoSize = Math.abs(this.millCamera.orthoRight - this.millCamera.orthoLeft);
                    this.millCamera.radius = orthoSize * 0.7; // Adjust factor for similar view
                    
                    this.millCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                    // Enable rotation gizmo in perspective
                    if (this.gizmoManager) {
                        this.gizmoManager.rotationGizmoEnabled = true;
                    }
                    console.log('Switched to perspective mode for camera rotation');
                }
            }
        });
    }
    
        setupManualCameraControls() {
        // Mouse down
        this.millCanvas.addEventListener('pointerdown', (e) => {
            if (e.button === 1) {
                // Middle mouse - pan
                this.cameraState.isPanning = true;
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
                e.preventDefault();
            } else if (e.button === 2) {
                // Right mouse - rotate
                this.cameraState.isRotating = true;
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
                
                // Switch to perspective mode when starting rotation
                if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                    const orthoSize = Math.abs(this.millCamera.orthoRight - this.millCamera.orthoLeft);
                    this.millCamera.radius = orthoSize * 0.7;
                    this.millCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                    if (this.gizmoManager) {
                        this.gizmoManager.rotationGizmoEnabled = true;
                    }
                }
                e.preventDefault();
            }
        });
        
        // Mouse move
        this.millCanvas.addEventListener('pointermove', (e) => {
            if (this.cameraState.isPanning) {
                const deltaX = e.clientX - this.cameraState.lastX;
                const deltaY = e.clientY - this.cameraState.lastY;
                const panSpeed = this.millCamera.radius * 0.001;
                
                const forward = this.millCamera.getDirection(BABYLON.Vector3.Forward());
                const right = BABYLON.Vector3.Cross(forward, BABYLON.Vector3.Up());
                const up = BABYLON.Vector3.Cross(right, forward);
                
                const panVector = right.scale(-deltaX * panSpeed).add(up.scale(deltaY * panSpeed));
                this.millCamera.target.addInPlace(panVector);
                
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
            } else if (this.cameraState.isRotating) {
                const deltaX = e.clientX - this.cameraState.lastX;
                const deltaY = e.clientY - this.cameraState.lastY;
                
                this.millCamera.alpha += deltaX * 0.01;
                this.millCamera.beta -= deltaY * 0.01;
                this.millCamera.beta = Math.max(0, Math.min(Math.PI / 2 - 0.01, this.millCamera.beta));
                
                if (this.millCamera.beta > 0.1 && this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                    const orthoSize = Math.abs(this.millCamera.orthoRight - this.millCamera.orthoLeft);
                    this.millCamera.radius = orthoSize * 0.7;
                    this.millCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                }
                
                this.cameraState.lastX = e.clientX;
                this.cameraState.lastY = e.clientY;
            }
            
            // Lock beta in ortho mode
            if (this.millCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
                this.millCamera.beta = 0;
            }
        });
        
        // Mouse up
        this.millCanvas.addEventListener('pointerup', (e) => {
            this.cameraState.isPanning = false;
            this.cameraState.isRotating = false;
        });
    }
    
        setupEventListeners() {
        this.millCanvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.millCanvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.millCanvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
    }
    
    // Mouse down - handle based on button
    onMouseDown(e) {
        // Only handle left click (button 0) for selection
        if (e.button !== 0) return;
        
        const pickResult = this.millScene.pick(e.clientX, e.clientY);
        
        if (!pickResult.hit) return;
        
        // Check if clicking on lumber first (priority over turntable)
        if (pickResult.pickedMesh.name === 'millMaterial') {
            // Let gizmo handle the lumber
            console.log('Clicked on lumber - gizmo will handle movement');
            return;
        }
        
        // Check if clicking on turntable (only with left button)
        if (pickResult.pickedMesh.name === 'turntable') {
            this.isDraggingTurntable = true;
            
            // Calculate starting angle from click position
            const clickPoint = pickResult.pickedPoint;
            this.dragStartAngle = Math.atan2(clickPoint.z, clickPoint.x);
            
            console.log('Started dragging turntable for rotation');
        }
    }
    
    // Mouse move - rotate turntable and laser if dragging
    onMouseMove(e) {
        if (!this.isDraggingTurntable) return;
        
        const pickResult = this.millScene.pick(e.clientX, e.clientY);
        
        if (pickResult.hit) {
            const currentPoint = pickResult.pickedPoint;
            const currentAngle = Math.atan2(currentPoint.z, currentPoint.x);
            
            // Calculate angle difference
            const angleDiff = currentAngle - this.dragStartAngle;
            this.bladeAngle += angleDiff;
            
            // Rotate the laser line
            if (this.laserTube) {
                this.laserTube.rotation.y = this.bladeAngle;
            }
            if (this.laserLine) {
                this.laserLine.rotation.y = this.bladeAngle;
            }
            
            // Update start angle for next frame
            this.dragStartAngle = currentAngle;
            
            // Show angle in degrees for user feedback
            const degrees = (this.bladeAngle * 180 / Math.PI) % 360;
            console.log('Blade angle:', degrees.toFixed(1) + '°');
        }
    }
    
    // Mouse up - stop dragging turntable
    onMouseUp(e) {
        if (this.isDraggingTurntable) {
            this.isDraggingTurntable = false;
            console.log('Stopped dragging turntable');
        }
    }
    
    // Execute the cut
    createGrid() {
        const gridSize = 500; // 500cm (5 meter) grid - standard plywood is 244cm
        const gridStep = 10; // 10cm steps
        const gridLines = [];
        
        for (let i = -gridSize/2; i <= gridSize/2; i += gridStep) {
            // Vertical lines
            gridLines.push([
                new BABYLON.Vector3(i, 0, -gridSize/2),
                new BABYLON.Vector3(i, 0, gridSize/2)
            ]);
            
            // Horizontal lines
            gridLines.push([
                new BABYLON.Vector3(-gridSize/2, 0, i),
                new BABYLON.Vector3(gridSize/2, 0, i)
            ]);
        }
        
        // Create grid mesh
        const gridSystem = BABYLON.MeshBuilder.CreateLineSystem('grid', {
            lines: gridLines
        }, this.millScene);
        
        gridSystem.color = new BABYLON.Color3(0.92, 0.92, 0.92);  // Extremely light grey
        gridSystem.renderingGroupId = 0; // Render below everything
    }
    
    setupGizmos(mesh) {
        // Create gizmo manager
        this.gizmoManager = new BABYLON.GizmoManager(this.millScene);
        this.gizmoManager.positionGizmoEnabled = true;
        this.gizmoManager.rotationGizmoEnabled = false; // Initially disabled
        this.gizmoManager.scaleGizmoEnabled = false;
        this.gizmoManager.boundingBoxGizmoEnabled = false;
        
        // Attach to mesh
        this.gizmoManager.attachToMesh(mesh);
    }
    
    setupViewCube(engine) {
        // ViewCube will be set up if needed
        // Currently using built-in camera controls
    }
    
        setupTurntableAndLaser() {
        // Create parent transform node for laser assembly
        this.laserAssembly = new BABYLON.TransformNode('laserAssembly', this.millScene);
        
        // Create work table (light grey surface)
        const tableRadius = 200;  // Large work surface
        this.workTable = BABYLON.MeshBuilder.CreateDisc('workTable', {
            radius: tableRadius,
            tessellation: 64
        }, this.millScene);
        
        this.workTable.position.y = 0.01; // Slightly above grid
        this.workTable.rotation.x = Math.PI / 2; // Rotate disc to horizontal plane
        this.workTable.isPickable = false;
        
        const tableMat = new BABYLON.StandardMaterial('tableMat', this.millScene);
        tableMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);  // Light grey
        tableMat.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
        tableMat.alpha = 0.3; // Semi-transparent to see grid
        this.workTable.material = tableMat;
        
        // Create laser line - thin red line extending across entire grid
        const laserPoints = [
            new BABYLON.Vector3(-250, 0.02, 0),  // Extend to grid edge
            new BABYLON.Vector3(250, 0.02, 0)    // Extend to opposite grid edge
        ];
        
        this.laserLine = BABYLON.MeshBuilder.CreateLines('laserLine', {
            points: laserPoints
        }, this.millScene);
        
        // Parent laser to assembly for rotation
        this.laserLine.parent = this.laserAssembly;
        
        // Create laser material
        this.laserLine.color = new BABYLON.Color3(1, 0, 0); // Bright red
        this.laserLine.renderingGroupId = 2; // Render on top
        
        // Create corner rotation control
        this.createRotationControl();
        
        // Setup rotation interaction
        this.setupRotationControl();
    }
    
    createRotationControl() {
        // Create HTML/CSS rotation control in corner
        const control = document.createElement('div');
        control.id = 'rotationControl';
        control.style.position = 'absolute';
        control.style.bottom = '150px';  // Above ViewCube
        control.style.left = '10px';
        control.style.width = '360px';
        control.style.height = '360px';
        control.style.borderRadius = '50%';
        control.style.backgroundColor = 'rgba(40, 40, 40, 0.9)';
        control.style.border = '2px solid #666';
        control.style.cursor = 'grab';
        control.style.userSelect = 'none';
        control.style.display = 'flex';
        control.style.alignItems = 'center';
        control.style.justifyContent = 'center';
        control.style.zIndex = '999';
        
        // Create inner dial with degree markings
        const dial = document.createElement('div');
        dial.style.position = 'relative';
        dial.style.width = '100%';
        dial.style.height = '100%';
        dial.style.borderRadius = '50%';
        dial.id = 'rotationDial';
        
        // Add degree markings
        for (let angle = 0; angle < 360; angle += 30) {
            const mark = document.createElement('div');
            mark.style.position = 'absolute';
            mark.style.width = '2px';
            mark.style.height = '20px';
            mark.style.backgroundColor = '#888';
            mark.style.left = '50%';
            mark.style.top = '5px';
            mark.style.transformOrigin = '1px 175px';
            mark.style.transform = 'rotate(' + angle + 'deg)';
            dial.appendChild(mark);
            
            // Add numbers for major angles
            if (angle % 90 === 0) {
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.fontSize = '24px';
                label.style.fontWeight = 'bold';
                label.style.color = '#fff';
                label.style.fontFamily = 'Helvetica, Arial, sans-serif';
                label.textContent = angle.toString();
                
                // Position labels (0 at right/East)
                const rad = angle * Math.PI / 180;
                const x = 50 + Math.cos(rad) * 35;
                const y = 50 + Math.sin(rad) * 35;
                label.style.left = x + '%';
                label.style.top = y + '%';
                label.style.transform = 'translate(-50%, -50%)';
                dial.appendChild(label);
            }
        }
        
        // Add center display
        const centerDisplay = document.createElement('div');
        centerDisplay.id = 'angleDisplay';
        centerDisplay.style.position = 'absolute';
        centerDisplay.style.top = '50%';
        centerDisplay.style.left = '50%';
        centerDisplay.style.transform = 'translate(-50%, -50%)';
        centerDisplay.style.fontSize = '36px';
        centerDisplay.style.fontWeight = 'bold';
        centerDisplay.style.color = '#ff9933';
        centerDisplay.style.fontFamily = 'Helvetica, Arial, sans-serif';
        centerDisplay.textContent = '0°';
        dial.appendChild(centerDisplay);
        
        // Add indicator needle/arrow
        const indicator = document.createElement('div');
        indicator.style.position = 'absolute';
        indicator.style.width = '50%';  // From center to edge
        indicator.style.height = '3px';  // Thickness of needle
        indicator.style.backgroundColor = '#ff9933';
        indicator.style.left = '50%';
        indicator.style.top = '50%';
        indicator.style.transformOrigin = 'left center';  // Rotate from left end (center of dial)
        indicator.style.transform = 'translateY(-50%) rotate(0deg)';  // Start pointing right (0 degrees)
        indicator.id = 'rotationIndicator';
        
        // Add arrow head at the end
        const arrowHead = document.createElement('div');
        arrowHead.style.position = 'absolute';
        arrowHead.style.width = '0';
        arrowHead.style.height = '0';
        arrowHead.style.borderTop = '8px solid transparent';
        arrowHead.style.borderBottom = '8px solid transparent';
        arrowHead.style.borderLeft = '12px solid #ff9933';
        arrowHead.style.right = '-12px';
        arrowHead.style.top = '50%';
        arrowHead.style.transform = 'translateY(-50%)';
        indicator.appendChild(arrowHead);
        dial.appendChild(indicator);
        
        control.appendChild(dial);
        
        // Add to Mill UI
        if (this.millUI) {
            this.millUI.appendChild(control);
        }
        
        this.rotationControl = control;
        this.rotationDial = dial;
        this.angleDisplay = centerDisplay;
        this.rotationIndicator = indicator;
    }
    
    setupRotationControl() {
        if (!this.rotationControl) return;
        
        let isDragging = false;
        let startAngle = 0;
        let currentRotation = 0;
        
        const getAngleFromMouse = (e, rect) => {
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;
            return Math.atan2(dy, dx) * 180 / Math.PI;  // 0 at right
        };
        
        this.rotationControl.addEventListener('mousedown', (e) => {
            isDragging = true;
            this.rotationControl.style.cursor = 'grabbing';
            const rect = this.rotationControl.getBoundingClientRect();
            startAngle = getAngleFromMouse(e, rect) - currentRotation;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = this.rotationControl.getBoundingClientRect();
            const angle = getAngleFromMouse(e, rect);
            currentRotation = angle - startAngle;
            
            // Normalize to 0-360
            while (currentRotation < 0) currentRotation += 360;
            while (currentRotation >= 360) currentRotation -= 360;
            
            // Update indicator rotation
            this.rotationIndicator.style.transform = 'translateY(-50%) rotate(' + currentRotation + 'deg)';
            
            // Update angle display
            this.angleDisplay.textContent = Math.round(currentRotation) + '°';
            
            // Rotate the laser
            if (this.laserAssembly) {
                this.laserAssembly.rotation.y = currentRotation * Math.PI / 180;  // Natural direction
            }
            
            // Update HUD if exists
            if (this.hudAngleDisplay) {
                this.hudAngleDisplay.textContent = Math.round(currentRotation) + '°';
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                this.rotationControl.style.cursor = 'grab';
            }
        });
    }
    
        executeCut() {
        console.log('Executing cut in The Mill with blade angle:', this.bladeAngle);
        
        // Get the lumber position
        const lumberMesh = this.millScene.getMeshByName('millMaterial');
        if (!lumberMesh) {
            alert('No material to cut');
            return;
        }
        
        // Calculate cut based on laser line intersection with lumber
        const cutData = {
            position: lumberMesh.position.clone(),
            angle: this.bladeAngle,
            kerf: this.kerfWidth
        };
        
        // Close mill and execute cut in main scene
        this.closeMill(cutData);
    }
    
    // Get operation display name
    getOperationName() {
        switch(this.currentOperation) {
            case 'cut': return 'Table Saw';
            case 'route': return 'Router';
            case 'drill': return 'Drill Press';
            default: return 'Unknown Tool';
        }
    }
    
    // Close The Mill
    closeMill(cutData = null) {
        console.log('Closing The Mill');
        
        // Clean up mill scene
        if (this.millScene) {
            this.millScene.dispose();
        }
        
        // Remove UI
        if (this.millUI) {
            this.millUI.remove();
        }
        
        // Show main canvas again
        this.drawingWorld.canvas.style.display = 'block';
        
        // Reset state
        this.isActive = false;
        this.currentMaterial = null;
        this.currentOperation = null;
        
        // If we have cut data, execute the cut in the main scene
        if (cutData) {
            // This would trigger the actual cut in the main scene
            // For now, we'll just log it
            console.log('Would execute cut with data:', cutData);
            
            // TODO: Call back to main scene to execute the cut
            // this.drawingWorld.executeCutFromMill(this.currentMaterial, cutData);
        }
    }
}

// Export for use in drawing-world.js
export { TheMillSystem };
