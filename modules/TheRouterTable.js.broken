class TheRouterTable {
    constructor(drawingWorld) {
        this.drawingWorld = drawingWorld;
        this.isActive = false;
        this.routerContainer = null;
        this.routerCanvas = null;
        this.routerEngine = null;
        this.routerScene = null;
        this.routerCamera = null;
        this.currentBoard = null;
        this.currentPartId = null;
        this.originalMesh = null;
        this.selectedEdge = null;
        this.routerBit = 'roundover';
        this.bitDepth = 0.25;
        this.highlightedEdges = [];
        this.routerCutters = []; // Store all cutters to show what was removed
        this.init();
    }
    
    init() {
        // Load router bit library
        if (typeof RouterBitLibrary !== 'undefined') {
            this.routerBitLibrary = RouterBitLibrary;
            console.log('Router bit library loaded');
        } else {
            console.error('RouterBitLibrary not found - make sure it is loaded');
        }
        
                console.log('TheRouterTable initialized');
    }
    
    setupRouterScene() {
        console.log('Setting up router scene...');
        
        if (!this.routerCanvas) {
            console.error('Router canvas not found!');
            return;
        }
        
        // Make sure canvas has size
        if (this.routerCanvas.width === 0 || this.routerCanvas.height === 0) {
            this.routerCanvas.width = this.routerCanvas.offsetWidth || 800;
            this.routerCanvas.height = this.routerCanvas.offsetHeight || 600;
        }
        
        // Create engine
        this.routerEngine = new BABYLON.Engine(this.routerCanvas, true);
        
        // Create scene
        this.routerScene = new BABYLON.Scene(this.routerEngine);
        this.routerScene.clearColor = new BABYLON.Color3(0.95, 0.95, 0.95);
        
        // Create camera
        this.routerCamera = new BABYLON.ArcRotateCamera(
            'routerCamera',
            Math.PI / 2,
            Math.PI / 3,
            100,  // Reasonable starting distance
            BABYLON.Vector3.Zero(),
            this.routerScene
        );
        
        // Much more responsive zoom
        this.routerCamera.wheelPrecision = 10;  // Lower = MORE responsive
        this.routerCamera.pinchPrecision = 10;  
        this.routerCamera.lowerRadiusLimit = 10;
        this.routerCamera.upperRadiusLimit = 500;  // Not too far
        // Set better initial camera parameters
        this.routerCamera.wheelPrecision = 50; // More precise zoom
        this.routerCamera.panningSensibility = 100; // Better panning
        this.routerCamera.lowerRadiusLimit = 10; // Don't get too close
        this.routerCamera.upperRadiusLimit = 500; // Don't get too far
        this.routerCamera.minZ = 0.1; // Near clipping plane
        this.routerCamera.maxZ = 1000; // Far clipping plane

        
        this.routerCamera.lowerRadiusLimit = 50;   // Don't allow too close
        this.routerCamera.upperRadiusLimit = 600;  // Allow farther out
        this.routerCamera.wheelPrecision = 15;
        this.routerCamera.minZ = 0.1;
        this.routerCamera.maxZ = 10000;
        this.routerCamera.attachControl(this.routerCanvas, true);
        
        // Fix mouse controls: middle button (1) for pan, right button (2) for rotate
        this.routerCamera.inputs.attached.pointers.buttons = [2, 0, 1]; // right=rotate, left=none, middle=pan
        
        // Add light
        const light = new BABYLON.HemisphericLight('light1', 
            new BABYLON.Vector3(0, 1, 0), this.routerScene);
        light.intensity = 0.9;
        
        // Add ViewCube like in workbench
        this.createViewCube();
        
        console.log('Router scene ready with ViewCube');
        
        // CRITICAL: Start render loop for router scene
        if (!this.routerEngine._activeRenderLoops || this.routerEngine._activeRenderLoops.length === 0) {
            console.log('Starting router render loop...');
            this.routerEngine.runRenderLoop(() => {
                if (this.routerScene) {
                    this.routerScene.render();
                }
            });
        }

    }
    
    openRouterTable(boardMesh, operation = 'route') {
        console.log('Opening router table with board:', boardMesh?.name);
        
        // Hide the board in workbench
        if (boardMesh && boardMesh.isVisible !== undefined) {
            boardMesh.isVisible = false;
        }
        
        // Create container if it doesn't exist
        if (!this.routerContainer) {
            this.routerContainer = document.createElement('div');
            this.routerContainer.id = 'routerTableContainer';
            this.routerContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #f0f0f0;
                z-index: 1000;
                display: none;
                flex-direction: column;
            `;
            
            // Add header
            const header = document.createElement('div');
            header.style.cssText = `
                background: #333;
                color: white;
                padding: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <h2>Router Table</h2>
                <div style="display: flex; gap: 20px; align-items: center;">
                    <div id="routerBitButtons" style="display: inline-flex; gap: 5px; align-items: center;">
                        <button class="router-toolbar-btn" 
                                onclick="window.drawingWorld.theRouterTable.selectBit('roundover_quarter_inch_precise')" 
                                title="1/4 inch Roundover"
                                style="width: 36px; height: 36px; padding: 2px; border: 2px solid #666; background: white; cursor: pointer; border-radius: 4px;">
                            <img src="/router-bits/Roundover - Quarter Inch.png" style="width: 30px; height: 30px; transform: rotate(-90deg);" alt="Router Bit" />
                        </button>
                        <button class="router-toolbar-btn" 
                                onclick="window.drawingWorld.theRouterTable.selectBit('roundover_half_inch_precise')" 
                                title="1/2 inch Roundover"
                                style="width: 36px; height: 36px; padding: 2px; border: 2px solid #666; background: white; cursor: pointer; border-radius: 4px;">
                            <img src="/router-bits/Roundover - Half Inch.png" style="width: 30px; height: 30px; transform: rotate(-90deg);" alt="Router Bit" />
                        </button>
                        <button class="router-toolbar-btn" 
                                onclick="window.drawingWorld.theRouterTable.selectBit('chamfer_quarter_inch_precise')" 
                                title="1/4 inch Chamfer"
                                style="width: 36px; height: 36px; padding: 2px; border: 2px solid #666; background: white; cursor: pointer; border-radius: 4px;">
                            <img src="/router-bits/Chamfer - Quarter Inch.png" style="width: 30px; height: 30px; transform: rotate(-90deg);" alt="Router Bit" />
                        </button>
                        <button class="router-toolbar-btn" 
                                onclick="window.drawingWorld.theRouterTable.selectBit('chamfer_half_inch_precise')" 
                                title="1/2 inch Chamfer"
                                style="width: 36px; height: 36px; padding: 2px; border: 2px solid #666; background: white; cursor: pointer; border-radius: 4px;">
                            <img src="/router-bits/Chamfer - Half Inch.png" style="width: 30px; height: 30px; transform: rotate(-90deg);" alt="Router Bit" />
                        </button>
                        <span id="selectedBitName" style="margin-left: 10px; color: white; font-size: 14px;">1/4" Roundover</span>
                    </div>
                    
                    <label style="color: white;">
                        Depth:
                        <input type="range" id="bitDepth" min="0.1" max="0.5" step="0.05" value="0.25" 
                               onchange="window.drawingWorld.theRouterTable.setBitDepth(this.value)"
                               style="width: 100px;">
                        <span id="depthValue">0.25"</span>
                    </label>
                    
                    <button onclick="window.drawingWorld.theRouterTable.routeSelectedEdge()" style="
                        background: #28a745;
                        color: white;
                        border: none;
                        padding: 5px 15px;
                        cursor: pointer;
                    ">Route Edge</button>
                    
                    <button onclick="window.drawingWorld.theRouterTable.keepRoutedBoard()" style="
                        background: #007bff;
                        color: white;
                        border: none;
                        padding: 5px 15px;
                        cursor: pointer;
                    ">KEEP</button>
                    
                    <button onclick="window.drawingWorld.theRouterTable.toggleOrtho()" style="
                        background: #9b59b6;
                        color: white;
                        border: none;
                        padding: 5px 15px;
                        cursor: pointer;
                    ">Ortho View</button>
                    
                    <button onclick="window.drawingWorld.theRouterTable.closeRouterTable()" style="
                        background: #555;
                        color: white;
                        border: none;
                        padding: 5px 10px;
                        cursor: pointer;
                    ">Close</button>
                </div>
            `;
            
            // Canvas container
            const canvasContainer = document.createElement('div');
            canvasContainer.style.cssText = `
                flex: 1;
                position: relative;
            `;
            
            // Create canvas
            this.routerCanvas = document.createElement('canvas');
            this.routerCanvas.id = 'routerCanvas';
            this.routerCanvas.style.cssText = `
                width: 100%;
                height: 100%;
                display: block;
            `;
            
            canvasContainer.appendChild(this.routerCanvas);
            this.routerContainer.appendChild(header);
            this.routerContainer.appendChild(canvasContainer);
            document.body.appendChild(this.routerContainer);
        }
        
        // Show router
        this.routerContainer.style.display = 'flex';
        
        // Setup scene
        this.setupRouterScene();
        
        // Transfer the actual board
        if (boardMesh && boardMesh.name) {
            console.log('Transferring board to router:', boardMesh.name);
            console.log('Board vertices:', boardMesh.getTotalVertices());
            
            // Use CSG to preserve exact geometry
            let boardCSG;
            if (boardMesh.getCSG) {
                boardCSG = boardMesh.getCSG();
                console.log('Got existing CSG');
            } else {
                boardCSG = BABYLON.CSG.FromMesh(boardMesh);
                console.log('Created new CSG from mesh');
            }
            
            // Create mesh in router scene
            this.currentBoard = boardCSG.toMesh('routerBoard', null, this.routerScene);
            
            // Copy material
            if (boardMesh.material) {
                const mat = new BABYLON.StandardMaterial('routerBoardMat', this.routerScene);
                
                // Copy color
                if (boardMesh.material.diffuseColor) {
                    mat.diffuseColor = boardMesh.material.diffuseColor.clone();
                } else {
                    mat.diffuseColor = new BABYLON.Color3(0.6, 0.3, 0.1); // Default wood color
                }
                
                // Copy texture if exists
                if (boardMesh.material.diffuseTexture) {
                    try {
                        const texUrl = boardMesh.material.diffuseTexture.url || 
                                      boardMesh.material.diffuseTexture._texture?.url;
                        if (texUrl) {
                            mat.diffuseTexture = new BABYLON.Texture(texUrl, this.routerScene);
                        }
                    } catch (e) {
                        console.log('Could not copy texture:', e);
                }
                
                mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                this.currentBoard.material = mat;
            } else {
                // Default material if none exists
                const mat = new BABYLON.StandardMaterial('routerBoardMat', this.routerScene);
                mat.diffuseColor = new BABYLON.Color3(0.6, 0.3, 0.1);
                this.currentBoard.material = mat;
            }
            
            // Position at origin
            this.currentBoard.position = BABYLON.Vector3.Zero();
            this.currentBoard.rotation = BABYLON.Vector3.Zero();
            
            console.log('Board transferred successfully');
        
        // Position camera to view board
        if (this.routerCamera && this.currentBoard) {
            // Set camera to view the board from above at an angle
            this.routerCamera.alpha = Math.PI / 2;
            this.routerCamera.beta = Math.PI / 3; 
            this.routerCamera.radius = 100; // Closer view;
            this.routerCamera.setTarget(BABYLON.Vector3.Zero());
            
            // Ensure scene background is visible
            this.routerScene.clearColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            
            console.log('Camera positioned for board viewing');
        }

            
            // DEBUG: Check board visibility
            console.log('DEBUG: currentBoard exists?', !!this.currentBoard);
            if (this.currentBoard) {
                console.log('DEBUG: currentBoard.isVisible:', this.currentBoard.isVisible);
                console.log('DEBUG: currentBoard.material:', this.currentBoard.material);
                console.log('DEBUG: currentBoard position:', this.currentBoard.position);
                console.log('DEBUG: currentBoard bounds:', this.currentBoard.getBoundingInfo());
                
                                // Fix board material appearance
                if (!this.currentBoard.material || this.currentBoard.material.name === 'routerBoardMat') {
                    const woodMaterial = new BABYLON.StandardMaterial("woodMaterial", this.routerScene);
                    woodMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2); // Brown wood color
                    woodMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Low shine
                    woodMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.03, 0.01); // Slight warm glow
                    woodMaterial.backFaceCulling = true; // Prevent see-through edges
                    this.currentBoard.material = woodMaterial;
                    console.log('Applied proper wood material');
                }
                
// Force visibility
                this.currentBoard.isVisible = true;
                this.currentBoard.isPickable = true;
                this.currentBoard.showBoundingBox = true; // Show bounding box for debugging
                
                if (this.currentBoard.material) {
                    this.currentBoard.material.alpha = 1;
                    this.currentBoard.material.backFaceCulling = false;
                }
                
                // Ensure it's in the render list
                if (!this.routerScene.meshes.includes(this.currentBoard)) {
                    this.routerScene.addMesh(this.currentBoard);
                    console.log('DEBUG: Added board to scene meshes');
                }
                
                console.log('DEBUG: Scene meshes count:', this.routerScene.meshes.length);
                console.log('DEBUG: Board in scene?', this.routerScene.meshes.includes(this.currentBoard));
            }
            console.log('Router board vertices:', this.currentBoard.getTotalVertices());
            
            // Setup edge selection for routing
            this.setupEdgeSelection();

            
            // Store reference to original
            this.originalMesh = boardMesh;
            
            // Setup edge selection
            this.setupEdgeSelection();
            
        } else {
            console.log('No board mesh provided, creating test board');
            // Fallback to test board
            const box = BABYLON.MeshBuilder.CreateBox('board', {
                width: 48,
                height: 2,
                depth: 8
            }, this.routerScene);
            
            box.position = BABYLON.Vector3.Zero();
            
            const mat = new BABYLON.StandardMaterial('boardMat', this.routerScene);
            mat.diffuseColor = new BABYLON.Color3(0.6, 0.3, 0.1);
            box.material = mat;
            
            this.currentBoard = box;
        }
        
        // Set camera
        this.routerCamera.radius = 100; // Increased for better view
        this.routerCamera.setTarget(BABYLON.Vector3.Zero());
        
        // Add keyboard listener for blade toggle
        this.routerScene.actionManager = new BABYLON.ActionManager(this.routerScene);
        this.routerScene.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnKeyDownTrigger,
                (evt) => {
                    // H key toggles blade visibility
                    if (evt.sourceEvent.key === 'h' || evt.sourceEvent.key === 'H') {
                        this.toggleBladeVisibility();
                    }
                }
            )
        );
    }
    
    selectCustomBit(bitKey) {
        console.log('Selecting custom router bit:', bitKey);
        
        // Ensure RouterBitLibrary is loaded
        if (!window.RouterBitLibrary || !window.RouterBitLibrary.bits) {
            console.log('RouterBitLibrary not loaded, attempting to load...');
            // Try to load the library
            const script = document.createElement('script');
            script.src = '/modules/RouterBitLibrary.js';
            script.onload = () => {
                console.log('RouterBitLibrary loaded:', window.RouterBitLibrary);
                if (window.RouterBitLibrary && window.RouterBitLibrary.bits) {
                    // Retry the selection
                    this.selectCustomBit(bitKey);
                }
            };
            document.head.appendChild(script);
            return false;
        }
        
        
        // Get bit from RouterBitLibrary
        if (window.RouterBitLibrary && window.RouterBitLibrary.bits && window.RouterBitLibrary.bits[bitKey]) {
            const bitData = window.RouterBitLibrary.bits[bitKey];
            
            // Store the bit data
            this.currentBitKey = bitKey;
            this.routerBit = bitData.name;
            this.routerBitProfile = bitData.profilePoints;
            
            console.log('Router bit set to:', bitData.name);
            console.log('Profile points:', bitData.profilePoints);
            
            // Update UI
            const buttons = document.querySelectorAll('.router-toolbar-btn');
            buttons.forEach(btn => {
                btn.style.background = 'white';
                btn.style.borderColor = '#666';
            });
            
            // Highlight selected button
            buttons.forEach(btn => {
                if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(bitKey)) {
                    btn.style.background = '#e8f4ff';
                    btn.style.borderColor = '#0066cc';
                }
            });
            
            // Update display
            const display = document.getElementById('selectedBitName');
            if (display) {
                display.textContent = bitData.name;
            }
            
            return true;
        } else {
            console.error('Router bit not found in library:', bitKey);
            return false;
    }
    }
    
    toggleBladeVisibility() {
        
        // Display help text
        const helpDiv = document.createElement('div');
        helpDiv.style.position = 'absolute';
        helpDiv.style.bottom = '10px';
        helpDiv.style.left = '10px';
        helpDiv.style.color = '#666';
        helpDiv.style.fontFamily = 'Arial, sans-serif';
        helpDiv.style.fontSize = '12px';
        helpDiv.style.zIndex = '1000';
        helpDiv.innerHTML = 'Press H to toggle blade visibility | Press C to clear all blades';
        helpDiv.id = 'router-help-text';
        
        // Append to the router container which we know exists
        if (this.routerContainer) {
            // Remove old help text if exists
            const oldHelp = document.getElementById('router-help-text');
            if (oldHelp) {
                oldHelp.remove();
            }
            this.routerContainer.appendChild(helpDiv);
        }
        
                // Start render loop
        if (this.routerEngine) {
            this.routerEngine.runRenderLoop(() => {
                this.routerScene.render();
            });
            this.routerEngine.resize();
        }
        
        // Center the board in view
        if (this.routerBoardMesh || this.currentBoard) {
            // Get board bounds
            board.computeWorldMatrix(true);
            const bounds = board.getBoundingInfo();
            const center = bounds.boundingBox.centerWorld;
            
            // Set camera to look at board center
            this.routerCamera.setTarget(center);
            
            // Calculate optimal camera distance based on board size
            const size = bounds.boundingBox.extendSizeWorld;
            const maxDim = Math.max(size.x, size.y, size.z) * 2;
            const distance = maxDim * 2.5; // Good viewing distance
            
            // Position camera at a nice angle
            const alpha = Math.PI / 4; // 45 degrees
            const beta = Math.PI / 3;  // 60 degrees from horizontal
            this.routerCamera.alpha = alpha;
            this.routerCamera.beta = beta;
            this.routerCamera.radius = distance;
            
            // Reset board position to origin for easier manipulation
            board.position = new BABYLON.Vector3(0, 0, 0);
            board.rotation = new BABYLON.Vector3(0, 0, 0);
            
                        // Ensure board is visible
            const board = this.routerBoardMesh || this.currentBoard;
            board.isVisible = true;
            if (board.material) board.material.alpha = 1;
            
            console.log('Board centered in router view');
        }
        

        console.log('Router table opened');

    }
 
    
    toggleBladeVisibility() {
        // Toggle visibility of all router cutters
        if (this.routerCutters && this.routerCutters.length > 0) {
            this.routerCutters.forEach(cutter => {
                if (cutter && !cutter.isDisposed()) {
                    cutter.isVisible = !cutter.isVisible;
                }
            });
            
            const state = this.routerCutters[0]?.isVisible ? 'visible' : 'hidden';
            console.log(`Router blades are now ${state}`);
        } else {
            console.log('No router blades to toggle');
    }
    
    clearAllBlades() {
        // Dispose all router cutters
        if (this.routerCutters && this.routerCutters.length > 0) {
            this.routerCutters.forEach(cutter => {
                if (cutter && !cutter.isDisposed()) {
                    cutter.dispose();
                }
            });
            this.routerCutters = [];
            console.log('All router blades cleared');
        } else {
            console.log('No router blades to clear');
    }   
    closeRouterTable() {
        console.log('Closing router table...');
        
        if (this.routerContainer) {
            this.routerContainer.style.display = 'none';
        }
        
        if (this.routerEngine) {
            this.routerEngine.stopRenderLoop();
        }
        
        this.currentBoard = null;
    }
    selectBit(bitName) {
        console.log('Selected router bit:', bitName);
        
        // Get the bit from the library
        if (this.routerBitLibrary && this.routerBitLibrary.bits[bitName]) {
            this.selectedBit = this.routerBitLibrary.bits[bitName];
            this.routerBit = bitName; // Keep for compatibility
            console.log('Loaded bit from library:', this.selectedBit);
            
            // Update UI
            const display = document.getElementById('selectedBitName');
            if (display) {
                display.textContent = this.selectedBit.name;
            }
        } else {
            console.error('Router bit not found:', bitName);
            this.selectedBit = null;
    }
    
    setBitDepth(depth) {
        this.bitDepth = parseFloat(depth);
        document.getElementById('depthValue').textContent = depth + '"';
        console.log('Set bit depth:', this.bitDepth);
    }
    
    createViewCube() {
        console.log('Creating ViewCube for router...');
        
        // Create ViewCube container
        const viewCubeContainer = document.createElement('div');
        viewCubeContainer.id = 'routerViewCube';
        viewCubeContainer.style.cssText = `
            position: absolute;
            top: 70px;
            right: 20px;
            width: 120px;
            height: 120px;
            z-index: 100;
        `;
        
        // Create ViewCube canvas
        const viewCubeCanvas = document.createElement('canvas');
        viewCubeCanvas.width = 120;
        viewCubeCanvas.height = 120;
        viewCubeCanvas.style.cssText = `
            width: 100%;
            height: 100%;
            cursor: pointer;
        `;
        viewCubeContainer.appendChild(viewCubeCanvas);
        
        // Add to router container
        if (this.routerContainer) {
            this.routerContainer.appendChild(viewCubeContainer);
        }
        
        // Create ViewCube scene
        const vcEngine = new BABYLON.Engine(viewCubeCanvas, true);
        const vcScene = new BABYLON.Scene(vcEngine);
        vcScene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
        
        // Create ViewCube camera
        const vcCamera = new BABYLON.ArcRotateCamera('vcCamera', 
            this.routerCamera.alpha, 
            this.routerCamera.beta, 
            5, 
            BABYLON.Vector3.Zero(), 
            vcScene
        );
        vcCamera.wheelPrecision = 50;
        vcCamera.panningSensibility = 0;
        
        // Create the cube
        const cube = BABYLON.MeshBuilder.CreateBox('viewCube', {size: 2}, vcScene);
        
        // Create face materials with labels
        const faceTextures = [];
        const faceLabels = ['FRONT', 'BACK', 'TOP', 'BOTTOM', 'RIGHT', 'LEFT'];
        const faceColors = [
            new BABYLON.Color3(0.8, 0.8, 0.9),
            new BABYLON.Color3(0.8, 0.8, 0.9),
            new BABYLON.Color3(0.9, 0.9, 1),
            new BABYLON.Color3(0.7, 0.7, 0.8),
            new BABYLON.Color3(0.85, 0.85, 0.95),
            new BABYLON.Color3(0.85, 0.85, 0.95)
        ];
        
        // Create multi-material
        const multiMat = new BABYLON.MultiMaterial('viewCubeMat', vcScene);
        
        for (let i = 0; i < 6; i++) {
            const mat = new BABYLON.StandardMaterial(`face${i}`, vcScene);
            mat.diffuseColor = faceColors[i];
            mat.specularColor = new BABYLON.Color3(0, 0, 0);
            mat.emissiveColor = faceColors[i].scale(0.3);
            multiMat.subMaterials.push(mat);
        }
        
        cube.material = multiMat;
        cube.subMeshes = [];
        
        const verticesCount = cube.getTotalVertices();
        cube.subMeshes.push(new BABYLON.SubMesh(0, 0, verticesCount, 0, 6, cube));
        cube.subMeshes.push(new BABYLON.SubMesh(1, 0, verticesCount, 6, 6, cube));
        cube.subMeshes.push(new BABYLON.SubMesh(2, 0, verticesCount, 12, 6, cube));
        cube.subMeshes.push(new BABYLON.SubMesh(3, 0, verticesCount, 18, 6, cube));
        cube.subMeshes.push(new BABYLON.SubMesh(4, 0, verticesCount, 24, 6, cube));
        cube.subMeshes.push(new BABYLON.SubMesh(5, 0, verticesCount, 30, 6, cube));
        
        // Add lighting
        new BABYLON.HemisphericLight('vcLight', new BABYLON.Vector3(0, 1, 0), vcScene);
        
        // Sync ViewCube with main camera
        this.routerScene.registerBeforeRender(() => {
            if (vcCamera && this.routerCamera) {
                vcCamera.alpha = this.routerCamera.alpha;
                vcCamera.beta = this.routerCamera.beta;
            }
        });
        
        // Handle ViewCube clicks
        viewCubeCanvas.addEventListener('click', (evt) => {
            const pickResult = vcScene.pick(evt.offsetX, evt.offsetY);
            if (pickResult.hit && pickResult.pickedMesh === cube) {
                const faceId = pickResult.subMeshId;
                this.snapToFace(faceId);
            }
        });
        
        // Handle double-click for orthographic toggle
        viewCubeCanvas.addEventListener('dblclick', (evt) => {
            this.toggleOrthographic();
            evt.preventDefault();
        });
        
        // Start ViewCube render loop
        vcEngine.runRenderLoop(() => {
            vcScene.render();
        });
        
        // Store references
        this.viewCubeEngine = vcEngine;
        this.viewCubeScene = vcScene;
        this.viewCubeCamera = vcCamera;
        this.isOrthographic = false;
        
        console.log('ViewCube created');
    }
    
    snapToFace(faceId) {
        console.log('Snapping to face:', faceId);
        
        let alpha = this.routerCamera.alpha;
        let beta = this.routerCamera.beta;
        
        // Define camera positions for each face
        switch(faceId) {
            case 0: // Front
                alpha = -Math.PI / 2;
                beta = Math.PI / 2;
                break;
            case 1: // Back
                alpha = Math.PI / 2;
                beta = Math.PI / 2;
                break;
            case 2: // Top
                alpha = 0;
                beta = 0;
                break;
            case 3: // Bottom
                alpha = 0;
                beta = Math.PI;
                break;
            case 4: // Right
                alpha = 0;
                beta = Math.PI / 2;
                break;
            case 5: // Left
                alpha = Math.PI;
                beta = Math.PI / 2;
                break;
        }
        
        // Animate camera to position
        BABYLON.Animation.CreateAndStartAnimation('snapCamera', this.routerCamera, 'alpha',
            30, 15, this.routerCamera.alpha, alpha, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        BABYLON.Animation.CreateAndStartAnimation('snapCameraBeta', this.routerCamera, 'beta',
            30, 15, this.routerCamera.beta, beta, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
            
        // Set orthographic mode
        this.setOrthographic(true);
    }
    
    toggleOrthographic() {
        this.isOrthographic = !this.isOrthographic;
        this.setOrthographic(this.isOrthographic);
    }
    
    setOrthographic(ortho) {
        this.isOrthographic = ortho;
        
        if (ortho) {
            // Switch to orthographic
            this.routerCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            
            const bounds = this.currentBoard ? 
                this.currentBoard.getBoundingInfo().boundingBox : 
                {maximumWorld: new BABYLON.Vector3(50, 50, 50), minimumWorld: new BABYLON.Vector3(-50, -50, -50)};
            
            const size = bounds.maximumWorld.subtract(bounds.minimumWorld);
            const maxDim = Math.max(size.x, size.y, size.z) * 1.5;
            
            const aspect = this.routerEngine.getRenderWidth() / this.routerEngine.getRenderHeight();
            this.routerCamera.orthoLeft = -maxDim * aspect;
            this.routerCamera.orthoRight = maxDim * aspect;
            this.routerCamera.orthoTop = maxDim;
            this.routerCamera.orthoBottom = -maxDim;
            
            console.log('Switched to orthographic mode');
        } else {
            // Switch to perspective
            this.routerCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
            console.log('Switched to perspective mode');
    }
    
    setupEdgeSelection() {
        if (!this.currentBoard) return;
        
        console.log('Setting up edge highlighting...');
        
        // Clear old highlights
        if (this.highlightedEdges) {
            this.highlightedEdges.forEach(e => e.dispose());
        }
        this.highlightedEdges = [];
        this.selectedEdges = new Set();
        
        // Get board bounds
        this.currentBoard.computeWorldMatrix(true);
        const bounds = this.currentBoard.getBoundingInfo().boundingBox;
        const min = bounds.minimumWorld;
        const max = bounds.maximumWorld;
        
        const width = max.x - min.x;
        const height = max.y - min.y;
        const depth = max.z - min.z;
        
        // Visual edge thickness (what you see when highlighted)
        const edgeThickness = Math.min(width, height, depth) * 0.1; // 10% for visual
        // Collider thickness (invisible hit zone)
        const colliderThickness = edgeThickness * 3; // 3x bigger for easier targeting
        
        // Define all 12 edges
        const edges = [
            // Top edges (4)
            {name: 'top-front', pos: new BABYLON.Vector3(0, max.y, max.z), 
             size: new BABYLON.Vector3(width + colliderThickness, colliderThickness, colliderThickness)},
            {name: 'top-back', pos: new BABYLON.Vector3(0, max.y, min.z), 
             size: new BABYLON.Vector3(width + colliderThickness, colliderThickness, colliderThickness)},
            {name: 'top-left', pos: new BABYLON.Vector3(min.x, max.y, 0), 
             size: new BABYLON.Vector3(colliderThickness, colliderThickness, depth + colliderThickness)},
            {name: 'top-right', pos: new BABYLON.Vector3(max.x, max.y, 0), 
             size: new BABYLON.Vector3(colliderThickness, colliderThickness, depth + colliderThickness)},
            
            // Bottom edges (4)
            {name: 'bottom-front', pos: new BABYLON.Vector3(0, min.y, max.z), 
             size: new BABYLON.Vector3(width + colliderThickness, colliderThickness, colliderThickness)},
            {name: 'bottom-back', pos: new BABYLON.Vector3(0, min.y, min.z), 
             size: new BABYLON.Vector3(width + colliderThickness, colliderThickness, colliderThickness)},
            {name: 'bottom-left', pos: new BABYLON.Vector3(min.x, min.y, 0), 
             size: new BABYLON.Vector3(colliderThickness, colliderThickness, depth + colliderThickness)},
            {name: 'bottom-right', pos: new BABYLON.Vector3(max.x, min.y, 0), 
             size: new BABYLON.Vector3(colliderThickness, colliderThickness, depth + colliderThickness)},
            
            // Vertical edges (4)
            {name: 'vert-front-left', pos: new BABYLON.Vector3(min.x, 0, max.z), 
             size: new BABYLON.Vector3(colliderThickness, height + colliderThickness, colliderThickness)},
            {name: 'vert-front-right', pos: new BABYLON.Vector3(max.x, 0, max.z), 
             size: new BABYLON.Vector3(colliderThickness, height + colliderThickness, colliderThickness)},
            {name: 'vert-back-left', pos: new BABYLON.Vector3(min.x, 0, min.z), 
             size: new BABYLON.Vector3(colliderThickness, height + colliderThickness, colliderThickness)},
            {name: 'vert-back-right', pos: new BABYLON.Vector3(max.x, 0, min.z), 
             size: new BABYLON.Vector3(colliderThickness, height + colliderThickness, colliderThickness)}
        ];
        
        // Create edge meshes
        edges.forEach(edge => {
            const edgeMesh = BABYLON.MeshBuilder.CreateBox(edge.name, {
                width: edge.size.x,
                height: edge.size.y,
                depth: edge.size.z
            }, this.routerScene);
            
            edgeMesh.position = edge.pos;
            
            // Create material - starts invisible
            const mat = new BABYLON.StandardMaterial(edge.name + '_mat', this.routerScene);
            mat.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
            mat.emissiveColor = new BABYLON.Color3(0, 0, 0);
            mat.specularColor = new BABYLON.Color3(0, 0, 0);
            mat.alpha = 0; // Invisible initially
            edgeMesh.material = mat;
            
            edgeMesh.isPickable = true;
            edgeMesh.isVisible = true; // Mesh exists but alpha makes it invisible
            edgeMesh.metadata = {
                edgeName: edge.name,
                isSelected: false
            };
            
            // Setup action manager
            edgeMesh.actionManager = new BABYLON.ActionManager(this.routerScene);
            
            // Hover on - show with glow
            edgeMesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    () => {
                        console.log('Hovering:', edge.name);
                        if (!edgeMesh.metadata.isSelected) {
                            mat.emissiveColor = new BABYLON.Color3(0, 0.7, 1);
                            mat.alpha = 0.8;
                    }
                )
            );
            
            // Hover out - hide unless selected
            edgeMesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    () => {
                        if (!edgeMesh.metadata.isSelected) {
                            mat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                            mat.alpha = 0;
                    }
                )
            );
            
            // Click - toggle selection
            edgeMesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    () => {
                        console.log('Clicked:', edge.name);
                        if (edgeMesh.metadata.isSelected) {
                            // Deselect
                            mat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                            mat.alpha = 0;
                            edgeMesh.metadata.isSelected = false;
                            this.selectedEdges.delete(edge.name);
                        } else {
                            // Select - bright neon blue glow
                            mat.emissiveColor = new BABYLON.Color3(0, 0.9, 1);
                            mat.alpha = 1;
                            edgeMesh.metadata.isSelected = true;
                            this.selectedEdges.add(edge.name);
                        }
                        this.updateEdgeDisplay();
                    }
                )
            );
            
            this.highlightedEdges.push(edgeMesh);
        });
        
        // Add instruction
        const instruction = document.getElementById('edgeInstruction') || document.createElement('div');
        instruction.id = 'edgeInstruction';
        instruction.style.cssText = `
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        `;
        instruction.innerHTML = 'Hover near board edges to highlight them. Click to select for routing.';
        if (!instruction.parentElement) {
            this.routerContainer.appendChild(instruction);
        }
        
        console.log('Edge selection ready - 12 edges with 3x bigger hit zones');
    }
    
    updateEdgeDisplay() {
        const instruction = document.getElementById('edgeInstruction');
        if (instruction) {
            if (this.selectedEdges.size > 0) {
                instruction.innerHTML = `Selected ${this.selectedEdges.size} edge(s): ${Array.from(this.selectedEdges).join(', ')}`;
                instruction.style.background = 'rgba(0,100,200,0.9)';
            } else {
                instruction.innerHTML = 'Hover over board edges to see them glow blue. Click to select/deselect edges for routing.';
                instruction.style.background = 'rgba(0,0,0,0.8)';
    }
    
    toggleOrtho() {
        if (!this.routerCamera || !this.routerEngine) return;
        
        // Store current radius
        const currentRadius = this.routerCamera.radius;
        
        if (this.routerCamera.mode === BABYLON.Camera.PERSPECTIVE_CAMERA) {
            // Switch to orthographic
            this.routerCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
            
            // Get canvas dimensions
            const aspect = this.routerCanvas.width / this.routerCanvas.height;
            
            // Use current radius to set ortho size (like in mill)
            const halfSize = currentRadius * 0.4; // Adjust multiplier for good framing
            
            // Set orthographic bounds
            if (aspect >= 1) {
                this.routerCamera.orthoLeft = -halfSize * aspect;
                this.routerCamera.orthoRight = halfSize * aspect;
                this.routerCamera.orthoTop = halfSize;
                this.routerCamera.orthoBottom = -halfSize;
            } else {
                this.routerCamera.orthoLeft = -halfSize;
                this.routerCamera.orthoRight = halfSize;
                this.routerCamera.orthoTop = halfSize / aspect;
                this.routerCamera.orthoBottom = -halfSize / aspect;
            }
            
            // Adjust camera limits for orthographic
            this.routerCamera.minZ = 0.1;
            this.routerCamera.maxZ = currentRadius * 10;
            
            console.log('Switched to orthographic');
            
            // Update button
            const btn = document.querySelector('button[onclick*="toggleOrtho"]');
            if (btn) btn.textContent = 'Perspective';
            
        } else {
            // Switch back to perspective
            this.routerCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
            
            // Reset camera limits
            this.routerCamera.minZ = 0.1;
            this.routerCamera.maxZ = 10000;
            
            console.log('Switched to perspective');
            
            // Update button
            const btn = document.querySelector('button[onclick*="toggleOrtho"]');
            if (btn) btn.textContent = 'Ortho View';
    }
    
    
    routeSelectedEdge() {
        if ((!this.selectedEdge && (!this.selectedEdges || this.selectedEdges.size === 0)) || !this.currentBoard) {
            alert('Please select an edge first by clicking on the board');
            return;
        }
        
        const edgesToRoute = this.selectedEdges || new Set([this.selectedEdge]);
        console.log('Routing edges:', Array.from(edgesToRoute), 'with bit:', this.routerBit, 'depth:', this.bitDepth);
        
        // Get the current board as CSG BEFORE creating cutter
        let boardCSG;
        try {
            boardCSG = BABYLON.CSG.FromMesh(this.currentBoard);
        } catch (error) {
            console.error('Failed to create CSG from board:', error);
            alert('Failed to prepare board for cutting');
            return;
        }
        
        // Create router bit profile based on selection
        let routerPath;
        const depth = this.bitDepth;
        
        // Create the cutting profile based on bit type
        // The profile defines what to REMOVE from the edge
        let cutterMesh;
        
        // Get board dimensions
        const bounds = this.currentBoard.getBoundingInfo().boundingBox;
        const size = bounds.maximumWorld.subtract(bounds.minimumWorld);
        
        // Determine which edges are selected and create appropriate cutter
        
        // Get the selected edge
        let selectedEdge;
        if (this.selectedEdge) {
            selectedEdge = this.selectedEdge;
        } else if (this.selectedEdges && this.selectedEdges.size > 0) {
            selectedEdge = Array.from(this.selectedEdges)[0];
        } else {
            console.error('No edge selected');
            alert('Please select an edge first');
            return;
        }
        console.log('Creating cutter for edge:', selectedEdge);
        

        
        // Use profile-based cutting if available
        if (this.selectedBit && this.selectedBit.profilePoints) {
            console.log('Using profile points for bit:', this.selectedBit.name);
            
            // Convert profile points to Babylon vectors
            const profilePoints = this.selectedBit.profilePoints;
            const profile = profilePoints.map(p => 
                new BABYLON.Vector3(p[0], -p[1], 0)  // X into wood, Y down
            );
            
            // Create extrusion path based on edge
            let extrudeLength = 100;
            if (selectedEdge.includes('front') || selectedEdge.includes('back')) {
                extrudeLength = size.x + 20;
            } else {
                extrudeLength = size.z + 20;
            }
            
            const path = [
                new BABYLON.Vector3(0, 0, -extrudeLength/2),
                new BABYLON.Vector3(0, 0, extrudeLength/2)
            ];
            
            // Create cutter mesh
            cutterMesh = BABYLON.MeshBuilder.ExtrudeShapeCustom("routerCutter", {
                shape: profile,
                path: path,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, this.routerScene);
            
            console.log('Created profile-based cutter');

            // Position the cutter based on the selected edge
            if (selectedEdge === 'top-front') {
                cutterMesh.position = new BABYLON.Vector3(0, size.y/2, size.z/2);
                cutterMesh.rotation.x = Math.PI/2;
            } else if (selectedEdge === 'top-back') {
                cutterMesh.position = new BABYLON.Vector3(0, size.y/2, -size.z/2);
                cutterMesh.rotation.x = -Math.PI/2;
            } else if (selectedEdge === 'top-left') {
                cutterMesh.position = new BABYLON.Vector3(-size.x/2, size.y/2, 0);
                cutterMesh.rotation.z = -Math.PI/2;
            } else if (selectedEdge === 'top-right') {
                cutterMesh.position = new BABYLON.Vector3(size.x/2, size.y/2, 0);
                cutterMesh.rotation.z = Math.PI/2;
            }

        }
        
        // Make cutter visible as semi-transparent red
        const cutterMat = new BABYLON.StandardMaterial('cutterMat_' + Date.now(), this.routerScene);
        cutterMat.diffuseColor = new BABYLON.Color3(1, 0, 0); // Red
        cutterMat.emissiveColor = new BABYLON.Color3(0.3, 0, 0); // Slight red glow
        cutterMat.alpha = 0.5; // Semi-transparent
        cutterMesh.material = cutterMat;
        
        // Store the cutter for later reference
        this.routerCutters.push(cutterMesh);
        
        console.log('Router cutter created and positioned');
        }
                }
                // Edge normal points in Z direction
                    // Normal points +Z, blade should face -Z
                    cutterMesh.rotation.y = 0;  // No rotation
                    console.log('Edge normal +Z: blade faces -Z (inward)');
                } else {
                    // Normal points -Z, blade should face +Z
                    cutterMesh.rotation.y = Math.PI;  // 180 degrees
                    console.log('Edge normal -Z: blade faces +Z (inward)');
            }
            
            cutterMesh.computeWorldMatrix(true); // Force matrix update
            console.log('Positioned cutter at:', cutterMesh.position, 'with rotation:', cutterMesh.rotation.y);
                
            
            // Force update world matrix after rotation
            cutterMesh.computeWorldMatrix(true);
            console.log('Roundover cutter created with profile');


        
                // Store the original material before CSG operations
        const originalMat = this.currentBoard.material;
        
        // Perform CSG subtraction with error handling
                // Hide edge highlights before cutting so we can see the result
        if (this.highlightedEdges) {
            this.highlightedEdges.forEach(e => {
                e.isVisible = false;
            });
        }
        
        console.log('Performing CSG subtraction...');
        console.log('Board bounds before:', this.currentBoard.getBoundingInfo().boundingBox);
        console.log('Cutter bounds:', cutterMesh.getBoundingInfo().boundingBox);
        
        // Ensure boardCSG exists
        if (!boardCSG) {
            console.error('boardCSG not defined - creating now');
            try {
                boardCSG = BABYLON.CSG.FromMesh(this.currentBoard);
            } catch (error) {
                console.error('Failed to create boardCSG:', error);
                alert('Failed to create CSG from board');
                return;
        }
        
        let resultCSG;
        try {
            // Ensure meshes are ready for CSG
            console.log('Computing world matrices...');
            this.currentBoard.computeWorldMatrix(true);
            cutterMesh.computeWorldMatrix(true);
            console.log('World matrices computed');
            
            // Check if cutter intersects with board
            if (!this.currentBoard.intersectsMesh(cutterMesh, false)) {
                console.warn('WARNING: Cutter does not intersect with board - no cut will occur');
                alert('Cutter is not touching the board. Adjusting position...');
                
                // Try to adjust position to ensure intersection
                const boardBounds = this.currentBoard.getBoundingInfo().boundingBox;
                const cutterBounds = cutterMesh.getBoundingInfo().boundingBox;
                console.log('Board max:', boardBounds.maximumWorld);
                console.log('Cutter min:', cutterBounds.minimumWorld);
            }
            
            console.log('Creating CSG from cutter mesh...');
            let cutterCSG;
            try {
                cutterCSG = BABYLON.CSG.FromMesh(cutterMesh);
                console.log('Cutter CSG created successfully');
            } catch (e) {
                console.error('Failed to create CSG from cutter:', e);
                console.error('Cutter details:', {
                    name: cutterMesh.name,
                    vertices: cutterMesh.getTotalVertices(),
                    position: cutterMesh.position
                });
                throw e;
            }
            
            console.log('Performing subtraction...');
            try {
                // Try the subtraction
                resultCSG = boardCSG.subtract(cutterCSG);
                
                if (!resultCSG) {
                    throw new Error('CSG subtraction returned null');
                }
                
                console.log('Subtraction complete');
            } catch (e) {
                console.error('CSG subtraction failed:', e);
                console.error('Error details:', e.message, e.stack);
                
                // Try a different approach - just hide part of the board for visual feedback
                console.log('Falling back to visual-only cutting');
                
                // Keep the cutter visible to show what would be cut
                cutterMesh.material.alpha = 0.8;
                cutterMesh.material.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green to show success
                
                // Don't throw, just return
                alert('CSG operation failed - showing cut area in green');
                return;
            }
            
            console.log('CSG operation complete');
            
        } catch (error) {
            console.error('CSG Error:', error);
            alert('Error performing cut: ' + error.message);
            
            // Keep the cutter visible to debug
            cutterMesh.material.alpha = 0.8;
            return;
        }
        
        // Dispose of old board mesh
        this.currentBoard.dispose();
        
        // Create new routed board
        this.currentBoard = resultCSG.toMesh('routedBoard', null, this.routerScene);
        
        // Ensure new board is properly set up
        this.currentBoard.computeWorldMatrix(true);
        this.currentBoard.refreshBoundingInfo();
        
        console.log('New board created, vertices:', this.currentBoard.getTotalVertices());
        console.log('New board bounds:', this.currentBoard.getBoundingInfo().boundingBox);
        
        // Reapply the material properly
        if (originalMat) {
            // Clone the original material
            const mat = new BABYLON.StandardMaterial('routedMat_' + Date.now(), this.routerScene);
            
            // Copy all material properties
            if (originalMat.diffuseColor) {
                mat.diffuseColor = originalMat.diffuseColor.clone();
            } else {
                mat.diffuseColor = new BABYLON.Color3(0.6, 0.3, 0.1); // Wood color
            }
            
            // Copy texture if it exists
            if (originalMat.diffuseTexture) {
                try {
                    const texUrl = originalMat.diffuseTexture.url || originalMat.diffuseTexture._texture?.url;
                    if (texUrl) {
                        mat.diffuseTexture = new BABYLON.Texture(texUrl, this.routerScene);
                    }
                } catch (e) {
                    console.log('Could not copy texture:', e);
            }
            
            // Set wood-like properties
            mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            mat.specularPower = 32;
            
            this.currentBoard.material = mat;
            console.log('Material reapplied to routed board');
        } else {
            // Fallback material if none exists
            const mat = new BABYLON.StandardMaterial('routedMat_fallback', this.routerScene);
            mat.diffuseColor = new BABYLON.Color3(0.6, 0.3, 0.1); // Wood brown
            mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            this.currentBoard.material = mat;
            console.log('Fallback material applied');
        }
        
        // Ensure the board is visible
        this.currentBoard.isVisible = true;
        this.currentBoard.position = BABYLON.Vector3.Zero();
        
        // Clean up edges but keep cutter visible
        // cutterMesh.dispose(); // DON'T dispose - keep it visible to show the cut
        
        // Don't dispose edge highlights, just hide them and clear selection
        if (this.highlightedEdges) {
            this.highlightedEdges.forEach(e => {
                e.material.alpha = 0.3;
                e.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                e.isVisible = false;
                if (e.metadata) {
                    e.metadata.isSelected = false;
                }
            });
        }
        
        this.selectedEdge = null;
        if (this.selectedEdges) {
            this.selectedEdges.clear();
        }
        
        // Recreate edge selection for the new board
        // Dispose old edges first
        if (this.highlightedEdges) {
            this.highlightedEdges.forEach(e => e.dispose());
            this.highlightedEdges = [];
        }
        this.setupEdgeSelection();
        
        // Update display to show success
        const instruction = document.getElementById('edgeInstruction');
        if (instruction) {
            instruction.innerHTML = `✓ Edge routed with ${this.routerBit} profile! Select more edges or click KEEP to save.`;
            instruction.style.background = 'rgba(0,128,0,0.9)';
            setTimeout(() => {
                instruction.innerHTML = 'Hover near board edges to highlight them. Click to select for routing.';
                instruction.style.background = 'rgba(0,0,0,0.8)';
            }, 3000);
        }
        
        console.log('Edge routed successfully - material preserved!');
    }
    
    keepRoutedBoard() {
        if (!this.currentBoard) return;
        
        console.log('Keeping routed board...');
        
        // Transfer back to workbench
        const boardCSG = BABYLON.CSG.FromMesh(this.currentBoard);
        const routedMesh = boardCSG.toMesh('routed_' + Date.now(), null, this.drawingWorld.scene);
        
        // Position in workbench
        if (this.originalMesh) {
            routedMesh.position = this.originalMesh.position.clone();
            routedMesh.rotation = this.originalMesh.rotation.clone();
            
            // Hide original
            this.originalMesh.isVisible = false;
            
            // Copy material
            if (this.originalMesh.material) {
                routedMesh.material = this.originalMesh.material.clone();
        }
        
        // Make it pickable and add to workbench
        routedMesh.isPickable = true;
        routedMesh.isWorkBenchPart = true;
        
        // Close router
        this.closeRouterTable();
        
        console.log('Routed board returned to workbench');
    }

    }
export { TheRouterTable };
